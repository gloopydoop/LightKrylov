var tipuesearch = {"pages":[{"title":" LightKrylov ","text":"LightKrylov Warning This API documentation for the LightKrylov pacakge is a work in progress.\n   It is build from the source code in the main branch and does not track the current development in dev or any other branches.\n   If you use another branch, please refer to the in-code documentation.\n   Use the navigation bar at the top of the screen to browse modules , procedures , source files , etc.\n   The listings near the bootom of the page are incomplete. This is the main API documentation landing page generated by FORD . This documentation is released under the CC-BY-SA license while the LightKrylov source code is distribution under the BSD-3 Clause one. Scope The goal of LightKrylov is to provide a lightweight implementation of many standard Krylov techniques using modern Fortran features, including: Linear solvers for cg when is a symmetric (hermitian) positive definite matrix. gmres when is a non-symmetric square linear operator. Krylov-based matrix factorizations arnoldi - Construct an upper Hessenberg matrix and an orthonormal (unitary) basis capturing the dominant eigenspace of a square non-symmetric matrix using the Arnoldi iterative process. lanczos - Construct a symmetric (hermitian) tridiagonal matrix and an orthonormal (unitary) basis capturing the dominant eigenspace of a symmetric (hermitian) linear operator using the Lanczos iterative process. bidiagonalization - Construct a bidiagonal matrix and orthonormal bases and for the dominant column (resp. row) span of a general linear operator using the Lanczos bidiagonalization iterative process. Eigenvalue solvers for eigs to compute the largest eigenvalues and associated eigenvectors of a general square linear operator using the Arnoldi iterative process. eighs to compute the largest eigenvalues and associated eigenvectors of a symmetric (hermitian) linear operator using the Lanczos iterative process. Singular value decomposition svds to compute the leading singular triplets of a general linear operator using the Lanczos bidiagonalization iterative process. Solving a system of nonlinear equations newton to find the solution to using a Newton-Krylov solver with optimal step size found by a simple bisection method. While similar and more feature-complete packages exist (e.g. Arpack , SLEPC or Trilinos ), the use of abstract_type in LightKrylov and its nearly non-existant list of dependencies makes it far easier to incorporate into an existing code base. Preliminary benchmark results moreover show that it is on par with Arpack in terms of accuracy and computational performances. Acknowledgment The development of LightKrylov is part of an on-going research project funded by Agence Nationale pour la Recherche (ANR) under the grant agreement ANR-22-CE46-0008. The project started in January 2023 and will run until December 2026.\nWe are also very grateful to the fortran-lang community and the maintainers of stdlib . Related projects LightKrylov is the base package of our ecosystem. If you like it, you may also be interested in: LightROM : a lightweight Fortran package providing a set of functions for reduced-order modeling, control and estimation of large-scale linear time invariant dynamical systems. neklab : a bifurcation and stability analysis toolbox based on LightKrylov for the massively parallel spectral element solver Nek5000 . Developer Info nekstab/LightKrylov contributors","tags":"home","loc":"index.html"},{"title":"abstract_jacobian_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_cdp ) :: abstract_jacobian_linop_cdp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_jacobian_linop_cdp.html"},{"title":"abstract_jacobian_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_csp ) :: abstract_jacobian_linop_csp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_jacobian_linop_csp.html"},{"title":"abstract_jacobian_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rdp ) :: abstract_jacobian_linop_rdp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_jacobian_linop_rdp.html"},{"title":"abstract_jacobian_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rsp ) :: abstract_jacobian_linop_rsp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_jacobian_linop_rsp.html"},{"title":"abstract_system – LightKrylov ","text":"type, public, abstract :: abstract_system Source Code type , abstract , public :: abstract_system end type abstract_system","tags":"","loc":"type/abstract_system.html"},{"title":"abstract_system_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_cdp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_cdp), public, deferred, pass(self) :: eval Procedure to evaluate the system response . subroutine abstract_eval_cdp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(in) :: self System class( abstract_vector_cdp ), intent(in) :: vec_in State class( abstract_vector_cdp ), intent(out) :: vec_out Response real(kind=dp), intent(in) :: atol Solver tolerance","tags":"","loc":"type/abstract_system_cdp.html"},{"title":"abstract_system_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_csp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_csp), public, deferred, pass(self) :: eval Procedure to evaluate the system response . subroutine abstract_eval_csp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(in) :: self System class( abstract_vector_csp ), intent(in) :: vec_in State class( abstract_vector_csp ), intent(out) :: vec_out Response real(kind=sp), intent(in) :: atol Solver tolerance","tags":"","loc":"type/abstract_system_csp.html"},{"title":"abstract_system_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_rdp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_rdp), public, deferred, pass(self) :: eval Procedure to evaluate the system response . subroutine abstract_eval_rdp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(in) :: self System class( abstract_vector_rdp ), intent(in) :: vec_in State class( abstract_vector_rdp ), intent(out) :: vec_out Response real(kind=dp), intent(in) :: atol Solver tolerance","tags":"","loc":"type/abstract_system_rdp.html"},{"title":"abstract_system_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_system ) :: abstract_system_rsp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_rsp), public, deferred, pass(self) :: eval Procedure to evaluate the system response . subroutine abstract_eval_rsp(self, vec_in, vec_out, atol) Prototype Interface for the evaluation of the system response. Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(in) :: self System class( abstract_vector_rsp ), intent(in) :: vec_in State class( abstract_vector_rsp ), intent(out) :: vec_out Response real(kind=sp), intent(in) :: atol Solver tolerance","tags":"","loc":"type/abstract_system_rsp.html"},{"title":"Id_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: Id_cdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_cdp private  subroutine id_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => id_matvec_cdp private  subroutine id_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out","tags":"","loc":"type/id_cdp.html"},{"title":"Id_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: Id_csp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_csp private  subroutine id_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => id_matvec_csp private  subroutine id_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out","tags":"","loc":"type/id_csp.html"},{"title":"Id_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: Id_rdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_rdp private  subroutine id_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => id_matvec_rdp private  subroutine id_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out","tags":"","loc":"type/id_rdp.html"},{"title":"Id_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: Id_rsp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_rsp private  subroutine id_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => id_matvec_rsp private  subroutine id_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( Id_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out","tags":"","loc":"type/id_rsp.html"},{"title":"abstract_hermitian_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_cdp ) :: abstract_hermitian_linop_cdp Abstract representation of an abstract hermitian (complex-valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_hermitian_linop_cdp.html"},{"title":"abstract_hermitian_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_csp ) :: abstract_hermitian_linop_csp Abstract representation of an abstract hermitian (complex-valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_hermitian_linop_csp.html"},{"title":"abstract_linop – LightKrylov ","text":"type, public, abstract :: abstract_linop Base type to define an abstract linear operator. All other types defined in LightKrylov derive from this fundamental one. Warning Users should not extend this abstract class to define their own types. Source Code type , abstract , public :: abstract_linop !!  Base type to define an abstract linear operator. All other types defined in !!  `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_linop","tags":"","loc":"type/abstract_linop.html"},{"title":"abstract_linop_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_cdp Base type to extend in order to define a complex(dp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_cdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: self Linear operator . class( abstract_vector_cdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_cdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_linop_cdp.html"},{"title":"abstract_linop_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_csp Base type to extend in order to define a complex(sp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_csp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: self Linear operator . class( abstract_vector_csp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_csp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_linop_csp.html"},{"title":"abstract_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_rdp Base type to extend in order to define a real(dp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_linop_rdp.html"},{"title":"abstract_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop ) :: abstract_linop_rsp Base type to extend in order to define a real(sp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_linop_rsp.html"},{"title":"abstract_sym_linop_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rdp ) :: abstract_sym_linop_rdp Abstract representation of an abstract symmetric (real valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rdp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: self Linear operator . class( abstract_vector_rdp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rdp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_sym_linop_rdp.html"},{"title":"abstract_sym_linop_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_linop_rsp ) :: abstract_sym_linop_rsp Abstract representation of an abstract symmetric (real valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec Procedure to compute the matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product. procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec Procedure to compute the reversed matrix-vector product . subroutine abstract_matvec_rsp(self, vec_in, vec_out) Prototype Interface for the matrix-vector product. Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: self Linear operator . class( abstract_vector_rsp ), intent(in) :: vec_in Vector to be multiplied by . class( abstract_vector_rsp ), intent(out) :: vec_out Result of the matrix-vector product.","tags":"","loc":"type/abstract_sym_linop_rsp.html"},{"title":"adjoint_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: adjoint_linop_cdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_cdp private  subroutine adjoint_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_cdp private  subroutine adjoint_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out","tags":"","loc":"type/adjoint_linop_cdp.html"},{"title":"adjoint_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: adjoint_linop_csp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_csp private  subroutine adjoint_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_csp private  subroutine adjoint_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out","tags":"","loc":"type/adjoint_linop_csp.html"},{"title":"adjoint_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: adjoint_linop_rdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_rdp private  subroutine adjoint_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rdp private  subroutine adjoint_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out","tags":"","loc":"type/adjoint_linop_rdp.html"},{"title":"adjoint_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: adjoint_linop_rsp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_rsp private  subroutine adjoint_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rsp private  subroutine adjoint_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( adjoint_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out","tags":"","loc":"type/adjoint_linop_rsp.html"},{"title":"axpby_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: axpby_linop_cdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_cdp ), public, allocatable :: B Underlying linear operators. complex(kind=dp), public :: alpha Scaling factors. complex(kind=dp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_cdp private  subroutine axpby_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => axpby_rmatvec_cdp private  subroutine axpby_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out","tags":"","loc":"type/axpby_linop_cdp.html"},{"title":"axpby_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: axpby_linop_csp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_csp ), public, allocatable :: B Underlying linear operators. complex(kind=sp), public :: alpha Scaling factors. complex(kind=sp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_csp private  subroutine axpby_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => axpby_rmatvec_csp private  subroutine axpby_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out","tags":"","loc":"type/axpby_linop_csp.html"},{"title":"axpby_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: axpby_linop_rdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rdp ), public, allocatable :: B Underlying linear operators. real(kind=dp), public :: alpha Scaling factors. real(kind=dp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_rdp private  subroutine axpby_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rdp private  subroutine axpby_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out","tags":"","loc":"type/axpby_linop_rdp.html"},{"title":"axpby_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: axpby_linop_rsp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rsp ), public, allocatable :: B Underlying linear operators. real(kind=sp), public :: alpha Scaling factors. real(kind=sp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_rsp private  subroutine axpby_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rsp private  subroutine axpby_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( axpby_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out","tags":"","loc":"type/axpby_linop_rsp.html"},{"title":"scaled_linop_cdp – LightKrylov ","text":"type, public, extends( abstract_linop_cdp ) :: scaled_linop_cdp Defines a scaled linear operator with a complex-valued operator and . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Base linear operator to be scaled. complex(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_cdp private  subroutine scaled_matvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => scaled_rmatvec_cdp private  subroutine scaled_rmatvec_cdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_cdp ), intent(in) :: self class( abstract_vector_cdp ), intent(in) :: vec_in class( abstract_vector_cdp ), intent(out) :: vec_out","tags":"","loc":"type/scaled_linop_cdp.html"},{"title":"scaled_linop_csp – LightKrylov ","text":"type, public, extends( abstract_linop_csp ) :: scaled_linop_csp Defines a scaled linear operator with a complex-valued operator and . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Base linear operator to be scaled. complex(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_csp private  subroutine scaled_matvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => scaled_rmatvec_csp private  subroutine scaled_rmatvec_csp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_csp ), intent(in) :: self class( abstract_vector_csp ), intent(in) :: vec_in class( abstract_vector_csp ), intent(out) :: vec_out","tags":"","loc":"type/scaled_linop_csp.html"},{"title":"scaled_linop_rdp – LightKrylov ","text":"type, public, extends( abstract_linop_rdp ) :: scaled_linop_rdp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to\nbe defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Base linear operator to be scaled. real(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_rdp private  subroutine scaled_matvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rdp private  subroutine scaled_rmatvec_rdp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rdp ), intent(in) :: self class( abstract_vector_rdp ), intent(in) :: vec_in class( abstract_vector_rdp ), intent(out) :: vec_out","tags":"","loc":"type/scaled_linop_rdp.html"},{"title":"scaled_linop_rsp – LightKrylov ","text":"type, public, extends( abstract_linop_rsp ) :: scaled_linop_rsp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to\nbe defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Base linear operator to be scaled. real(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_rsp private  subroutine scaled_matvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rsp private  subroutine scaled_rmatvec_rsp(self, vec_in, vec_out) Arguments Type Intent Optional Attributes Name class( scaled_linop_rsp ), intent(in) :: self class( abstract_vector_rsp ), intent(in) :: vec_in class( abstract_vector_rsp ), intent(out) :: vec_out","tags":"","loc":"type/scaled_linop_rsp.html"},{"title":"abstract_precond_cdp – LightKrylov ","text":"type, public, abstract :: abstract_precond_cdp Type-Bound Procedures procedure(abstract_apply_cdp), public, deferred, pass(self) :: apply subroutine abstract_apply_cdp(self, vec) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_cdp ), intent(in) :: self Preconditioner. class( abstract_vector_cdp ), intent(inout) :: vec Input/Output vector.","tags":"","loc":"type/abstract_precond_cdp.html"},{"title":"abstract_precond_csp – LightKrylov ","text":"type, public, abstract :: abstract_precond_csp Type-Bound Procedures procedure(abstract_apply_csp), public, deferred, pass(self) :: apply subroutine abstract_apply_csp(self, vec) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_csp ), intent(in) :: self Preconditioner. class( abstract_vector_csp ), intent(inout) :: vec Input/Output vector.","tags":"","loc":"type/abstract_precond_csp.html"},{"title":"abstract_precond_rdp – LightKrylov ","text":"type, public, abstract :: abstract_precond_rdp Type-Bound Procedures procedure(abstract_apply_rdp), public, deferred, pass(self) :: apply subroutine abstract_apply_rdp(self, vec) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_rdp ), intent(in) :: self Preconditioner. class( abstract_vector_rdp ), intent(inout) :: vec Input/Output vector.","tags":"","loc":"type/abstract_precond_rdp.html"},{"title":"abstract_precond_rsp – LightKrylov ","text":"type, public, abstract :: abstract_precond_rsp Type-Bound Procedures procedure(abstract_apply_rsp), public, deferred, pass(self) :: apply subroutine abstract_apply_rsp(self, vec) Prototype Abstract interface to apply a preconditioner in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_precond_rsp ), intent(in) :: self Preconditioner. class( abstract_vector_rsp ), intent(inout) :: vec Input/Output vector.","tags":"","loc":"type/abstract_precond_rsp.html"},{"title":"abstract_vector – LightKrylov ","text":"type, public, abstract :: abstract_vector Base abstract type from which all other types of vectors used in LightKrylov are being derived from. Warning Users should not extend this abstract class to define their own types. Source Code type , abstract , public :: abstract_vector !!  Base abstract type from which all other types of vectors used in `LightKrylov` !!  are being derived from. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_vector","tags":"","loc":"type/abstract_vector.html"},{"title":"abstract_vector_cdp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_cdp Abstract type to define complex(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp Adds two abstract_vector . private  subroutine add_cdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_cdp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_cdp(self, alpha, vec, beta) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. complex(kind=dp), intent(in) :: alpha class( abstract_vector_cdp ), intent(in) :: vec Vector to be added/subtracted. complex(kind=dp), intent(in) :: beta procedure, public, pass(self) :: chsgn => chsgn_cdp private  subroutine chsgn_cdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_cdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_cdp . function abstract_dot_cdp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_cdp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value complex(kind=dp) Result of the dot product. procedure(abstract_get_size_cdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_cdp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vectors whose dot product will be computed. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_cdp Computes the norm of the abstract_vector . private  function norm_cdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure(abstract_rand_cdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_cdp . subroutine abstract_rand_cdp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure(abstract_scal_cdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_cdp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. complex(kind=dp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_cdp Subtracts two abstract_vector . private  subroutine sub_cdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_cdp ), intent(in) :: vec Vector to be added. procedure(abstract_zero_cdp), public, deferred, pass(self) :: zero Sets an abstract_vector_cdp to zero. subroutine abstract_zero_cdp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: self Vector to be zeroed-out.","tags":"","loc":"type/abstract_vector_cdp.html"},{"title":"abstract_vector_csp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_csp Abstract type to define complex(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_csp Adds two abstract_vector . private  subroutine add_csp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_csp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_csp(self, alpha, vec, beta) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. complex(kind=sp), intent(in) :: alpha class( abstract_vector_csp ), intent(in) :: vec Vector to be added/subtracted. complex(kind=sp), intent(in) :: beta procedure, public, pass(self) :: chsgn => chsgn_csp private  subroutine chsgn_csp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_csp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_csp . function abstract_dot_csp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_csp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value complex(kind=sp) Result of the dot product. procedure(abstract_get_size_csp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_csp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vectors whose dot product will be computed. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_csp Computes the norm of the abstract_vector . private  function norm_csp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure(abstract_rand_csp), public, deferred, pass(self) :: rand Creates a random abstract_vector_csp . subroutine abstract_rand_csp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure(abstract_scal_csp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_csp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. complex(kind=sp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_csp Subtracts two abstract_vector . private  subroutine sub_csp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Input/Output vector. class( abstract_vector_csp ), intent(in) :: vec Vector to be added. procedure(abstract_zero_csp), public, deferred, pass(self) :: zero Sets an abstract_vector_csp to zero. subroutine abstract_zero_csp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: self Vector to be zeroed-out.","tags":"","loc":"type/abstract_vector_csp.html"},{"title":"abstract_vector_rdp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_rdp Abstract type to define real(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp Adds two abstract_vector . private  subroutine add_rdp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_rdp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_rdp(self, alpha, vec, beta) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. real(kind=dp), intent(in) :: alpha class( abstract_vector_rdp ), intent(in) :: vec Vector to be added/subtracted. real(kind=dp), intent(in) :: beta procedure, public, pass(self) :: chsgn => chsgn_rdp private  subroutine chsgn_rdp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_rdp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rdp . function abstract_dot_rdp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_rdp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value real(kind=dp) Result of the dot product. procedure(abstract_get_size_rdp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_rdp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vectors whose dot product will be computed. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_rdp Computes the norm of the abstract_vector . private  function norm_rdp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=dp) Norm of the vector. procedure(abstract_rand_rdp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rdp . subroutine abstract_rand_rdp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure(abstract_scal_rdp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_rdp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. real(kind=dp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_rdp Subtracts two abstract_vector . private  subroutine sub_rdp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rdp ), intent(in) :: vec Vector to be added. procedure(abstract_zero_rdp), public, deferred, pass(self) :: zero Sets an abstract_vector_rdp to zero. subroutine abstract_zero_rdp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: self Vector to be zeroed-out.","tags":"","loc":"type/abstract_vector_rdp.html"},{"title":"abstract_vector_rsp – LightKrylov ","text":"type, public, abstract, extends( abstract_vector ) :: abstract_vector_rsp Abstract type to define real(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp Adds two abstract_vector . private  subroutine add_rsp(self, vec) Add two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure(abstract_axpby_rsp), public, deferred, pass(self) :: axpby In-place computation of . subroutine abstract_axpby_rsp(self, alpha, vec, beta) Prototype Abstract interface to add/scale two vectors in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. real(kind=sp), intent(in) :: alpha class( abstract_vector_rsp ), intent(in) :: vec Vector to be added/subtracted. real(kind=sp), intent(in) :: beta procedure, public, pass(self) :: chsgn => chsgn_rsp private  subroutine chsgn_rsp(self) Changes the sign of the abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector whose entries need to change sign. procedure(abstract_dot_rsp), public, deferred, pass(self) :: dot Computes the dot product between two abstract_vector_rsp . function abstract_dot_rsp(self, vec) result(alpha) Prototype Abstract interface to compute the dot product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vectors whose dot product will be computed. class( abstract_vector_rsp ), intent(in) :: vec Vectors whose dot product will be computed. Return Value real(kind=sp) Result of the dot product. procedure(abstract_get_size_rsp), public, deferred, pass(self) :: get_size Return size of specific abstract vector function abstract_get_size_rsp(self) result(N) Prototype Abstract interface to return the size of the specific abstract vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vectors whose dot product will be computed. Return Value integer Size of the vector procedure, public, pass(self) :: norm => norm_rsp Computes the norm of the abstract_vector . private  function norm_rsp(self) result(alpha) Compute the norm of an abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: self Vector whose norm needs to be computed. Return Value real(kind=sp) Norm of the vector. procedure(abstract_rand_rsp), public, deferred, pass(self) :: rand Creates a random abstract_vector_rsp . subroutine abstract_rand_rsp(self, ifnorm) Prototype Abstract interface to generate a random (normalized) vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self logical, intent(in), optional :: ifnorm procedure(abstract_scal_rsp), public, deferred, pass(self) :: scal Compute the scalar-vector product. subroutine abstract_scal_rsp(self, alpha) Prototype Abstract interface to scale a vector. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. real(kind=sp), intent(in) :: alpha Scaling factor. procedure, public, pass(self) :: sub => sub_rsp Subtracts two abstract_vector . private  subroutine sub_rsp(self, vec) Subtract two abstract_vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Input/Output vector. class( abstract_vector_rsp ), intent(in) :: vec Vector to be added. procedure(abstract_zero_rsp), public, deferred, pass(self) :: zero Sets an abstract_vector_rsp to zero. subroutine abstract_zero_rsp(self) Prototype Abstract interface to zero-out a vector in-place. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: self Vector to be zeroed-out.","tags":"","loc":"type/abstract_vector_rsp.html"},{"title":"abstract_opts – LightKrylov ","text":"type, public, abstract :: abstract_opts Abstract type container for options from which all others are being extended.","tags":"","loc":"type/abstract_opts.html"},{"title":"cg_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: cg_dp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100).","tags":"","loc":"type/cg_dp_opts.html"},{"title":"cg_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: cg_sp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100).","tags":"","loc":"type/cg_sp_opts.html"},{"title":"gmres_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: gmres_dp_opts GMRES options. Components Type Visibility Attributes Name Initial integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10).","tags":"","loc":"type/gmres_dp_opts.html"},{"title":"gmres_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: gmres_sp_opts GMRES options. Components Type Visibility Attributes Name Initial integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10).","tags":"","loc":"type/gmres_sp_opts.html"},{"title":"newton_dp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: newton_dp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false.","tags":"","loc":"type/newton_dp_opts.html"},{"title":"newton_sp_opts – LightKrylov ","text":"type, public, extends( abstract_opts ) :: newton_sp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false.","tags":"","loc":"type/newton_sp_opts.html"},{"title":"eigvals_select_dp – LightKrylov","text":"interface public  function eigvals_select_dp(lambda) result(selected) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Return Value logical(size(lambda))","tags":"","loc":"interface/eigvals_select_dp.html"},{"title":"eigvals_select_sp – LightKrylov","text":"interface public  function eigvals_select_sp(lambda) result(selected) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Return Value logical(size(lambda))","tags":"","loc":"interface/eigvals_select_sp.html"},{"title":"abstract_exptA_cdp – LightKrylov","text":"interface public  subroutine abstract_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","loc":"interface/abstract_expta_cdp.html"},{"title":"abstract_exptA_csp – LightKrylov","text":"interface public  subroutine abstract_exptA_csp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","loc":"interface/abstract_expta_csp.html"},{"title":"abstract_exptA_rdp – LightKrylov","text":"interface public  subroutine abstract_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","loc":"interface/abstract_expta_rdp.html"},{"title":"abstract_exptA_rsp – LightKrylov","text":"interface public  subroutine abstract_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? Description Abstract interface to define the matrix exponential-vector product.","tags":"","loc":"interface/abstract_expta_rsp.html"},{"title":"abstract_linear_solver_cdp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to invert. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","loc":"interface/abstract_linear_solver_cdp.html"},{"title":"abstract_linear_solver_csp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to invert. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","loc":"interface/abstract_linear_solver_csp.html"},{"title":"abstract_linear_solver_rdp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to invert. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","loc":"interface/abstract_linear_solver_rdp.html"},{"title":"abstract_linear_solver_rsp – LightKrylov","text":"interface public  subroutine abstract_linear_solver_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to invert. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. Description Abstract interface to use a user-defined linear solver in LightKrylov .","tags":"","loc":"interface/abstract_linear_solver_rsp.html"},{"title":"greetings – LightKrylov","text":"public  subroutine greetings() Arguments None Source Code subroutine greetings () write ( * , * ) write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) \"      _     _       _     _   _  __           _            \" write ( * , * ) \"     | |   (_) __ _| |__ | |_| |/ /_ __ _   _| | _____   __\" write ( * , * ) \"     | |   | |/ _` | '_ \\| __| ' /| '__| | | | |/ _ \\ \\ / /\" write ( * , * ) \"     | |___| | (_| | | | | |_| . \\| |  | |_| | | (_) \\ V / \" write ( * , * ) \"     |_____|_|\\__, |_| |_|\\__|_|\\_\\_|   \\__, |_|\\___/ \\_/  \" write ( * , * ) \"              |___/                     |___/              \" write ( * , * ) write ( * , * ) \"Developed by: Jean-Christophe Loiseau\" write ( * , * ) \"              J. Simon Kern\" write ( * , * ) \"              Arts & Métiers Institute of Technology, 2023.\" write ( * , * ) \"              jean-christophe.loiseau@ensam.eu\" write ( * , * ) write ( * , * ) \"Version -- beta 0.1.0\" write ( * , * ) \"License -- BSD 3-Clause\" write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) end subroutine greetings","tags":"","loc":"proc/greetings.html"},{"title":"apply_inverse_permutation_matrix – LightKrylov","text":"public interface apply_inverse_permutation_matrix Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector and its inverse. Syntax call apply_inverse_permutation_matrix ( X , perm ) Arguments Q : Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n     column-permuted version computed in-place. It is an intent(inout) argument. perm : Rank-1 array of integer corresponding to the desired permutation vector.\n        It is an intent(in) argument. Module Procedures private  subroutine apply_inverse_permutation_matrix_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation).","tags":"","loc":"interface/apply_inverse_permutation_matrix.html"},{"title":"apply_permutation_matrix – LightKrylov","text":"public interface apply_permutation_matrix Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector . Syntax call apply_permutation_matrix ( X , perm ) Arguments Q : Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n     column-permuted version computed in-place. It is an intent(inout) argument. perm : Rank-1 array of integer corresponding to the desired permutation vector.\n        It is an intent(in) argument. Module Procedures private  subroutine apply_permutation_matrix_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation).","tags":"","loc":"interface/apply_permutation_matrix.html"},{"title":"arnoldi – LightKrylov","text":"public interface arnoldi Description Given a square linear operator , find matrices and such that where is an orthogonal basis and is upper Hessenberg. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Gram-Schmidt process. Constructs an upper Hessenberg matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.3: Arnoldi's method. Syntax call arnoldi ( A , X , H , info [, kstart ] [, kend ] [, tol ] [, transpose ] [, blksize ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. The operator needs to be square, i.e. the dimension of its domain and\n      co-domain is the same. It is an intent(in) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors. The first entry X(1) is the starting vector for\n      the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps\n      is equal to size(X) - 1 . It is an intent(inout) argument. H : real or complex rank-2 array. On exit, it contains the upper Hessenberg matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Arnoldi factorization experienced a lucky breakdown. \n          The array of Krylov vectors X spans an -invariant subpsace of\n          dimension info . kstart ( optional ): integer value determining the index of the first Arnoldi\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Arnoldi step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . transpose ( optional ): logical flag determining whether the Arnoldi factorization\n                           is applied to or . Default transpose = .false. blksize ( optional ): integer value determining the dimension of a block for the\n                        block Arnoldi factorization. Default is blksize=1 . Module Procedures private  subroutine arnoldi_rsp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_rdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_csp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_cdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1).","tags":"","loc":"interface/arnoldi.html"},{"title":"bidiagonalization – LightKrylov","text":"public interface bidiagonalization Description Given a general linear operator , find matrices , and such that where and are orthogonal bases for the column span and row span\nof , respectively, and is a bidiagonal matrix. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis for the column span of . Constructs an orthonormal Krylov basis for the row span of . Constructs a bidiagonal matrix whose singular values approximates \n  those of . Checks for convergence and invariant subspaces. References R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" \n  Technical Report, 1998. (PDF) Syntax call bidiagonalization ( A , U , V , B , info [, kstart ] [, kend ] [, tol ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. It is an intent(in) argument. U : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors for the column span of A . The first entry U(1) is the starting vector for the Lanczos factorization. Additionally, the \n      maximum number of Lanczos steps is equal to size(X) - 1 . \n      It is an intent(inout) argument. V : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors for the row span of A . It is an intent(inout) argument. B : real or complex rank-2 array. On exit, it contains the bidiagonal matrix computed from the Lanczos factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. kstart ( optional ): integer value determining the index of the first Lanczos\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Lanczos step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . Module Procedures private  subroutine lanczos_bidiagonalization_rsp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rsp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_rdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_csp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_csp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_cdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_cdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not.","tags":"","loc":"interface/bidiagonalization.html"},{"title":"double_gram_schmidt_step – LightKrylov","text":"public interface double_gram_schmidt_step Description Given an array of abstract_vector and an abstract_vector (or array of abstract_vectors ) , this subroutine returns a modified \nvector orthogonal to all columns of , i.e. using a double Gram-Schmidt process. On exit, is orthogonal to albeit\ndoes not have unit-norm. Note moreover that is assumed to be an orthonormal \nset of vectors. The function can also return the projection coefficients . Syntax call double_gram_schmidt_step ( y , X , info [, if_chk_orthonormal ] [, beta ]) Arguments y : abstract_vector (or array of abstract_vector ) that needs to be\n      orthogonalize in-place against . X : Array of abstract_vector against which needs to be orthogonalized.\n      Note the function assumes that is an orthonormal set of vectors, i.e. . If it this is not the case, the result are meaningless. info : integer Information flag. if_chk_orthonormal ( optional ) : logical flag (default .true. ) to check\n    whether is an orthonormal set of vectors or not. If the orthonormality\n    returns .false. , the function throws an error. Note that this check is however\n    computationally expensive and can be disable for the sake of performances. beta ( optional ) : real or complex array containing the coefficients . Module Procedures private  subroutine DGS_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested","tags":"","loc":"interface/double_gram_schmidt_step.html"},{"title":"initialize_krylov_subspace – LightKrylov","text":"public interface initialize_krylov_subspace Description Utility function to initialize a basis for a Krylov subspace. Syntax call initialize_krylov_subspace ( X [, X0 ]) Arguments X : Array of vectors that needs to be initialized. It is an intent(inout) argument. Note that the first action in the subroutine is call zero_basis(X) , effectively zeroing-out any data stored. X0 ( optional ) : Collection of vectors which will form the first few\n                    Krylov vectors. Note that X0 need not be an orthonormal\n                    basis as this subroutine includes a call qr(X0) . Module Procedures private  subroutine initialize_krylov_subspace_rsp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) class( abstract_vector_rsp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_rdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) class( abstract_vector_rdp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_csp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) class( abstract_vector_csp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_cdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) class( abstract_vector_cdp ), intent(in), optional :: X0 (:)","tags":"","loc":"interface/initialize_krylov_subspace.html"},{"title":"is_orthonormal – LightKrylov","text":"public interface is_orthonormal Description Utility function returning a logical .true. if the set of vectors stored in form\nan orthonormal set of vectors and .false. otherwise. Syntax out = is_orthonormal ( X ) Arguments X : Array of derived types extended from the base types provided in the AbstractVectors module. Module Procedures private  function is_orthonormal_rsp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_rdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_csp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_cdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value logical","tags":"","loc":"interface/is_orthonormal.html"},{"title":"krylov_schur – LightKrylov","text":"public interface krylov_schur Description Given a partial Krylov decomposition this subroutine implements the Krylov-Schur restarting strategy proposed by\nStewart [1]. References G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\".\n  SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. Syntax call krylov_schur ( n , X , H , select_eigs ) Arguments n : Number of selected eigenvalues moved to the upper left-block of the \n      Schur matrix. It is an intent(out) argument. X : On entry, array of abstract_vector computed using the Arnoldi process.\n      On exit, the first n columns form an orthonormal basis for the eigenspace\n      associated with eigenvalues moved to the upper left-block of the Schur matrix.\n      It is an intent(inout) argument. H : On entry, real of complex upper Hessenberg matrix computed using the\n      Arnoldi process. On exit, the leading block contains the block of the re-ordered Schur matrix containing the selected\n      eigenvalues. It is an intent(inout) argument. select_eigs : Procedure to select which eigenvalues to move in the upper-left\n                block. It is an intent(inout) argument. Module Procedures private  subroutine krylov_schur_rsp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rsp ), intent(inout) :: X (:) Krylov basis. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_sp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_rdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rdp ), intent(inout) :: X (:) Krylov basis. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_dp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_csp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_csp ), intent(inout) :: X (:) Krylov basis. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_sp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_cdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_cdp ), intent(inout) :: X (:) Krylov basis. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_dp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block.","tags":"","loc":"interface/krylov_schur.html"},{"title":"lanczos – LightKrylov","text":"public interface lanczos Description Given a symmetric or Hermitian linear operator , find matrices and such that where is an orthogonal basis and is symmetric tridiagonal. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Lanczos process with full\n  reorthogonalization. Constructs a symmetric tridiagonal matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.6: The symmetric Lanczos algorithm. Syntax call lanczos ( A , X , T , info [, kstart ] [, kend ] [, tol ]) Arguments A : Symmetric or Hermitian linear operator derived from one the base types \n      provided by the AbstractLinops module. It is an intent(in) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors. The first entry X(1) is the starting vector for\n      the Lanczos factorization. Additionally, the maximum number of Lanczos steps\n      is equal to size(X) - 1 . It is an intent(inout) argument. T : real or complex rank-2 array. On exit, it contains the symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. \n          The array of Krylov vectors X spans an -invariant subpsace of\n          dimension info . kstart ( optional ): integer value determining the index of the first Lanczos\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Lanczos step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . Module Procedures private  subroutine lanczos_tridiagonalization_rsp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A class( abstract_vector_rsp ), intent(inout) :: X (:) real(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_rdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A class( abstract_vector_rdp ), intent(inout) :: X (:) real(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_csp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A class( abstract_vector_csp ), intent(inout) :: X (:) complex(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_cdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A class( abstract_vector_cdp ), intent(inout) :: X (:) complex(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol","tags":"","loc":"interface/lanczos.html"},{"title":"orthogonalize_against_basis – LightKrylov","text":"public interface orthogonalize_against_basis Module Procedures private  subroutine orthogonalize_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested","tags":"","loc":"interface/orthogonalize_against_basis.html"},{"title":"orthonormalize_basis – LightKrylov","text":"public interface orthonormalize_basis Description Given an array of vectors, it computes an orthonormal basis for its\ncolumn-span using the double_gram_schmidt process. All computations are done\nin-place. Syntax call orthonormalize_basis ( X ) Arguments X : Array of abstract_vector to orthonormalize. Note that this process is done\n      in-place. It is an intent(inout) argument. Module Procedures private  subroutine orthonormalize_basis_rsp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_rdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_csp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_cdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against","tags":"","loc":"interface/orthonormalize_basis.html"},{"title":"qr – LightKrylov","text":"public interface qr Description Given an array of types derived from abstract_vector , it computes the in-place QR factorization of , i.e. where is an orthonormal arrays of vectors such that and is upper triangular. Note that it can also perform the QR factorization\nwith column pivoting where is a permutation matrix ensuring that the diagonal entries of have non-increasing absolute values. This amounts to using the pivoting QR as a\nrank-revealing factorization. References G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins\n University Press, 2013.\n See Chapter 5.2.8: Modified Gram-Schmidt algorithm. Syntax call qr ( Q [, R ] [, perm ], info [, tol ]) Arguments Q : Array of types derived from one of the base types provided in the AbstractVectors module. On entry, it contains the original array.\n     On exit, it is overwritten by the orthogonal basis for its span.\n     It is an intent(inout) argument. R : real or complex rank-2 array. On exit, its contains the upper triangular\n      matrix resulting from the QR factorization. It is an intent(out) argument. perm ( optional ): Rank-1 array of integer corresponding to the indices of\n                     permuted columns. If perm is absent, the naive QR factorization\n                     is being computed. info : integer information flag. tol ( optional ): Numerical tolerance to determine whether two vectors are colinear\n                    or not. Default tol = atol_sp or tol = atol_dp . Module Procedures private  subroutine qr_no_pivoting_rsp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_rsp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_rdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_rdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_csp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_csp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_cdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_cdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to detect colinearity.","tags":"","loc":"interface/qr.html"},{"title":"expm – LightKrylov","text":"public interface expm Description Evaluate the exponential of a dense matrix using Pade approximations. Syntax E = expm ( A , order ) Arguments E : real or complex rank-2 array with . A : real or complex matrix that needs to be exponentiated. order (optional) : Order of the Pade approximation. By default order = 10 . Module Procedures private  function expm_rsp(A, order) result(E) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value real(kind=sp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_rdp(A, order) result(E) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value real(kind=dp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_csp(A, order) result(E) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value complex(kind=sp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_cdp(A, order) result(E) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value complex(kind=dp), (size(A,1),size(A,1)) Output matrix E = exp(tA).","tags":"","loc":"interface/expm.html"},{"title":"k_exptA – LightKrylov","text":"public interface k_exptA Description Utility function to evaluate the matrix-exponential times vector. Syntax call k_exptA ( vec_out , A , vec_in , tau , info , trans ) Arguments vec_out : Output vector. A : Matrix to be exponentiated. vec_in : Input vector. tau : Integration time. info : Information flag. trans : Whether or is being used. Module Procedures private  subroutine k_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_csp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ?","tags":"","loc":"interface/k_expta.html"},{"title":"kexpm – LightKrylov","text":"public interface kexpm Description This interface provides methods to evaluate the matrix-vector product based on the Arnoldi method. Syntax call kexpm ( c , A , b , tau , tol , info [, trans ] [, kdim ]) Arguments c : Output vector (or vectors). It is an intent(out) argument. A : Linear operator to be exponentiated. It is an intent(in) argument. b : Vector to be multiplied by . It is an intent(in) argument. tau : real (singe or double) time over which the matrix exponential needs to\n        be computed. It is an intent(in) argument. info : integer Information flag. trans (optional) : Whether or is being used.\n                    (default trans=.false. ) kdim (optional) : Dimension of the Krylov subspace used in the Arnoldi method. Module Procedures private  subroutine kexpm_vec_rsp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_rsp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rsp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_rsp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_rdp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_rdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rdp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_rdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_csp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_csp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_csp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_csp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_cdp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_cdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_cdp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_cdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace.","tags":"","loc":"interface/kexpm.html"},{"title":"constant_atol_dp – LightKrylov","text":"public  subroutine constant_atol_dp(tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine constant_atol_dp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag character ( len = 256 ) :: msg tol = target_tol write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'constant_atol_dp' ) return end subroutine constant_atol_dp","tags":"","loc":"proc/constant_atol_dp.html"},{"title":"constant_atol_sp – LightKrylov","text":"public  subroutine constant_atol_sp(tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine constant_atol_sp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag character ( len = 256 ) :: msg tol = target_tol write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'constant_atol_sp' ) return end subroutine constant_atol_sp","tags":"","loc":"proc/constant_atol_sp.html"},{"title":"dynamic_tol_dp – LightKrylov","text":"public  subroutine dynamic_tol_dp(tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine dynamic_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals real ( dp ) :: tol_old character ( len = 256 ) :: msg tol_old = tol tol = max ( 0.1 * rnorm , target_tol ) if ( tol /= tol_old ) then if ( tol == target_tol ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call logger % log_information ( msg , module = this_module , procedure = 'dynamic_tol_dp' ) end if return end subroutine dynamic_tol_dp","tags":"","loc":"proc/dynamic_tol_dp.html"},{"title":"dynamic_tol_sp – LightKrylov","text":"public  subroutine dynamic_tol_sp(tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag Source Code subroutine dynamic_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals real ( sp ) :: tol_old character ( len = 256 ) :: msg tol_old = tol tol = max ( 0.1 * rnorm , target_tol ) if ( tol /= tol_old ) then if ( tol == target_tol ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call logger % log_information ( msg , module = this_module , procedure = 'dynamic_tol_sp' ) end if return end subroutine dynamic_tol_sp","tags":"","loc":"proc/dynamic_tol_sp.html"},{"title":"newton – LightKrylov","text":"public interface newton Implements the simple Newton-Krylov method for finding roots (fixed points) of a nonlinear vector-valued function , i.e. solutions such that starting from an initial guess via successive solution increments based on local linearization (the Jacobian) of the nonlinear function in the vicinity of the current solution. Algorthmic Features At iteration , the standard Newton step is computed as the solution of the linear system where is the residual of the nonlinear function. The new guess for the fixed\n  point is then given by: where parametrizes the step length. The standard Newton algorithm sets . The Jacobian is never assembled and the linear system is solved using one of the available iterative solvers. When the residual norm does not decrease during iteration indicating that the linearization is not a very\n  accurate model of the function's behaviour, which often happens during the initial iterations, a 1D step bisection\n  method based on the golden ratio is implemented to dampen the step and improve convergence of the method. The implementation allows for dynamic tolerances (also known as inexact Newton), where the approximation for \n  the residual and the linear system can be solved with relaxed tolerances to reduce overall time to solution. The method is suitable to both fixed points and periodic orbits via the choice of residual and corresponding\n  Jacobian matrix. In the case of unforced periodic orbits, the period is itself an unknown that must be included\n  in the iteration. Advantages The iterative solution of the linear systems has a comparatively low storage footprint. If the Newton iteration converges, the convergence is formally asymptotically of second order. Using dynamic\n  tolerances and line searches slightly reduce this convergence rate in exchange for a larger convergence region. Limitations The method is not guaranteed to converge if the initial guess is too far from the fixed point. \n  If the Newton iteration diverges even with step bisection, the best suggestion is to find a \n  better initial guess. If this is not feasible, some alternatives to improve the convergence \n  of the Newton iteration are possible (but not implemented to date), including various line search\n  algorithms and trust region methods (doglog, double dogleg, hookstep, ...). References Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov continuation of periodic orbits \n  for Navier–Stokes flows\". Journal of Computational Physics, 201(1), 13-33. Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". Journal of Fluid Mechanics, 580, 339-358. Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits in transitional pipe flow\". Physics\n  of Fluids, 20(11), 114102. Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for large-scale dynamical systems: Application \n  in fluid dynamics\". Applied Mechanics Reviews, 75(3), 030802. Module Procedures private  subroutine newton_rsp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rsp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rsp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: tolerance type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler private  subroutine newton_rdp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: tolerance type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler private  subroutine newton_csp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_csp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_csp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: tolerance type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler private  subroutine newton_cdp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_cdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_cdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: tolerance type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler","tags":"","loc":"interface/newton.html"},{"title":"cg_cdp – LightKrylov","text":"public  subroutine cg_cdp(A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. Source Code subroutine cg_cdp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_hermitian_linop_cdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts ! Working variables. class ( abstract_vector_cdp ), allocatable :: r , p , Ap complex ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_cdp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_cdp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_cdp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_cdp' ) enddo cg_loop return end subroutine cg_cdp","tags":"","loc":"proc/cg_cdp.html"},{"title":"cg_csp – LightKrylov","text":"public  subroutine cg_csp(A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. Source Code subroutine cg_csp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_hermitian_linop_csp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts ! Working variables. class ( abstract_vector_csp ), allocatable :: r , p , Ap complex ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_csp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_csp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_csp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_csp' ) enddo cg_loop return end subroutine cg_csp","tags":"","loc":"proc/cg_csp.html"},{"title":"cg_rdp – LightKrylov","text":"public  subroutine cg_rdp(A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. Source Code subroutine cg_rdp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_sym_linop_rdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts ! Working variables. class ( abstract_vector_rdp ), allocatable :: r , p , Ap real ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_rdp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_rdp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_rdp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_rdp' ) enddo cg_loop return end subroutine cg_rdp","tags":"","loc":"proc/cg_rdp.html"},{"title":"cg_rsp – LightKrylov","text":"public  subroutine cg_rsp(A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. Source Code subroutine cg_rsp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_sym_linop_rsp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts ! Working variables. class ( abstract_vector_rsp ), allocatable :: r , p , Ap real ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_rsp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_rsp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_rsp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_rsp' ) enddo cg_loop return end subroutine cg_rsp","tags":"","loc":"proc/cg_rsp.html"},{"title":"gmres_cdp – LightKrylov","text":"public  subroutine gmres_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. Source Code subroutine gmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts ! Krylov subspace class ( abstract_vector_cdp ), allocatable :: V (:) ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Least-squares variables. complex ( dp ), allocatable :: y (:), e (:) complex ( dp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_cdp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter complex ( dp ), allocatable :: alpha (:) class ( abstract_vector_cdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_dp allocate ( y ( kdim )) ; y = 0.0_dp allocate ( alpha ( kdim )) ; alpha = 0.0_dp allocate ( e ( kdim + 1 )) ; e = 0.0_dp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_cdp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_dp ; y = 0.0_dp ; e = 0.0_dp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_cdp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_cdp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_cdp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_cdp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_cdp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_cdp","tags":"","loc":"proc/gmres_cdp.html"},{"title":"gmres_csp – LightKrylov","text":"public  subroutine gmres_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. Source Code subroutine gmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts ! Krylov subspace class ( abstract_vector_csp ), allocatable :: V (:) ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Least-squares variables. complex ( sp ), allocatable :: y (:), e (:) complex ( sp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_csp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter complex ( sp ), allocatable :: alpha (:) class ( abstract_vector_csp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_sp allocate ( y ( kdim )) ; y = 0.0_sp allocate ( alpha ( kdim )) ; alpha = 0.0_sp allocate ( e ( kdim + 1 )) ; e = 0.0_sp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_csp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_sp ; y = 0.0_sp ; e = 0.0_sp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_csp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_csp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_csp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_csp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_csp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_csp","tags":"","loc":"proc/gmres_csp.html"},{"title":"gmres_rdp – LightKrylov","text":"public  subroutine gmres_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. Source Code subroutine gmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts ! Krylov subspace class ( abstract_vector_rdp ), allocatable :: V (:) ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Least-squares variables. real ( dp ), allocatable :: y (:), e (:) real ( dp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_rdp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter real ( dp ), allocatable :: alpha (:) class ( abstract_vector_rdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_dp allocate ( y ( kdim )) ; y = 0.0_dp allocate ( alpha ( kdim )) ; alpha = 0.0_dp allocate ( e ( kdim + 1 )) ; e = 0.0_dp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_rdp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_dp ; y = 0.0_dp ; e = 0.0_dp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_rdp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_rdp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rdp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_rdp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rdp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_rdp","tags":"","loc":"proc/gmres_rdp.html"},{"title":"gmres_rsp – LightKrylov","text":"public  subroutine gmres_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. Source Code subroutine gmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts ! Krylov subspace class ( abstract_vector_rsp ), allocatable :: V (:) ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Least-squares variables. real ( sp ), allocatable :: y (:), e (:) real ( sp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_rsp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter real ( sp ), allocatable :: alpha (:) class ( abstract_vector_rsp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_sp allocate ( y ( kdim )) ; y = 0.0_sp allocate ( alpha ( kdim )) ; alpha = 0.0_sp allocate ( e ( kdim + 1 )) ; e = 0.0_sp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_rsp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_sp ; y = 0.0_sp ; e = 0.0_sp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_rsp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_rsp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rsp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_rsp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rsp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_rsp","tags":"","loc":"proc/gmres_rsp.html"},{"title":"cg – LightKrylov","text":"public interface cg Description Given a symmetric (positive definite) matrix , solves the linear system using the Conjugate Gradient method. References Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving\nLinear Systems,\" Journal of Research of the National Bureau of Standards,\n49(6), 409–436. Syntax call cg ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ]) Arguments A : Linear operator derived from one of the abstract_sym_linop or abstract_hermitian_linop types provided by the AbstractLinops module. It is an intent(in) argument. b : Right-hand side vector derived from one the abstract_vector types provided\nby the AbstractVectors module. It needs to have the same type and kind as A .\nIt is an intent(in) argument. x : On entry, initial guess for the solution. On exit, the solution computed by\ncg. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\nan intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional) : Right preconditioner used to solve the system. It needs\nto be consistent with the abstract_preconditioner interface. It is an intent(in) argument. options (optional) : Container for the gmres options given by the cg_opts type.\nIt is an intent(in) argument. Note Although the interface to pass a preconditioner is exposed, it is not currently\nimplemented. Module Procedures public  subroutine cg_rsp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_rdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_csp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_cdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver.","tags":"","loc":"interface/cg.html"},{"title":"eighs – LightKrylov","text":"public interface eighs Description Computes the leading eigenpairs of a symmetric operator using the Lanczos iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectors such that: The subspace is constructed via Lanczos factorization, resulting in a symmetric\ntridiagonal matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem\nof Linear Differential and Integral Operators\". United States Governm. Press Office. Syntax call eighs ( A , X , eigvals , residuals , info [, kdim ] [, tolerance ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. X : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the leading eigenvectors of A . Note that the dimension of X fixes\n      the number of eigenpairs computed. eigvals : Rank-1 array of real numbers. On exit, it contains the leading\n            eigenvalues of A . It is an intent(out) argument. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading eigenpairs. It is an intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional ) : real tolerance below which an eigenpair is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . Module Procedures private  subroutine eighs_rsp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_rdp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_csp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_cdp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance","tags":"","loc":"interface/eighs.html"},{"title":"eigs – LightKrylov","text":"public interface eigs Description Computes the leading eigenpairs of a square linear operator using the Arnoldi iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectorss such that: or The subspace is constructed via Arnoldi factorization, resulting in an upper\nHessenberg matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of\n  the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. Syntax call eigs ( A , X , eigvals , residuals , info [, kdim ] [, select ] [, tolerance ] [, transpose ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. X : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the leading eigenvectors of A . Note that the dimension of X fixes\n      the number of eigenpairs computed. eigvals : Rank-1 array of real numbers. On exit, it contains the leading\n            eigenvalues of A . It is an intent(out) argument. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading eigenpairs. It is an intent(in) argument. By default, kdim = 4*size(X) . select ( optional ) : Function to select which eigenvalues to compute. tolerance ( optional ) : real tolerance below which an eigenpair is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . transpose ( optional ) : logical flag determining whether the eigenvalues of or need to be computed. Module Procedures private  subroutine eigs_rsp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_sp ), optional :: select Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_rdp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_dp ), optional :: select Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_csp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_sp ), optional :: select Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_cdp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_dp ), optional :: select Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used.","tags":"","loc":"interface/eigs.html"},{"title":"gmres – LightKrylov","text":"public interface gmres Description Solve a square linear system of equations using the Generalized Minimum RESidual (GMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call gmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A : Linear operator derived from one of the abstract_linop provided by the AbstractLinops module. It is an intent(in) argument. b : Right-hand side vector derived from one the abstract_vector types provided\nby the AbstractVectors module. It needs to have the same type and kind as A .\nIt is an intent(in) argument. x : On entry, initial guess for the solution. On exit, the solution computed by\ngmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\nan intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional) : Right preconditioner used to solve the system. It needs\nto be consistent with the abstract_preconditioner interface. It is an intent(in) argument. options (optional) : Container for the gmres options given by the gmres_opts type.\nIt is an intent(in) argument. transpose (optional) : logical flag controlling whether or is being solver. Module Procedures public  subroutine gmres_rsp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_rdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_csp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_cdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used.","tags":"","loc":"interface/gmres.html"},{"title":"save_eigenspectrum – LightKrylov","text":"public interface save_eigenspectrum Description Utility function to save the eigenspectrum computed from the Arnoldi factorization.\nIt outpost a .npy file. Syntax call save_eigenspectrum ( eigvals , residuals , fname ) Arguments eigvals : complex rank-1 array containing the eigenvalues. residuals : real rank-1 array containing the residuals associated to each\n              eigenvalues. fname : Name of the file to save the eigenspectrum. Module Procedures private  subroutine save_eigenspectrum_sp(eigvals, residuals, fname) Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: eigvals (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private  subroutine save_eigenspectrum_dp(eigvals, residuals, fname) Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvals (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file.","tags":"","loc":"interface/save_eigenspectrum.html"},{"title":"svds – LightKrylov","text":"public interface svds Description Computes the leading singular triplets of an arbitrary linear operator using the Lanczos iterative process. Given a linear operator , it finds\nthe leading singular values and singular vectors such that: The subspaces and are constructed via Lanczos factorization, resulting in\na bidiagonal matrix . The singular values of are approximated by those of and the singular vectors are computed accordingly. References Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and\n Pseudo-Inverse of a Matrix.\" Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos\n bidiagonalization methods.\" R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\"\n Technical Report, 1998. Syntax call svds ( A , U , S , V , residuals , info [, kdim ] [, tolerance ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. U : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the left singular vectors of A . Note that the dimension of U fixes\n      the number of eigenpairs computed. S : Rank-1 array of real numbers. On exit, it contains the leading\n      singular values of A . It is an intent(out) argument. V : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the left singular vectors of A . Note that the dimension of U fixes\n      the number of eigenpairs computed. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each singular triplet. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading singular triplets. It is an intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional ) : real tolerance below which a triplet is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . Module Procedures private  subroutine svds_rsp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rsp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rsp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_rdp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_csp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_csp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_csp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_cdp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_cdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_cdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance.","tags":"","loc":"interface/svds.html"},{"title":"axpby_basis – LightKrylov","text":"public interface axpby_basis In-place addition of two arrays of extended abstract_vector . Description This interface provides methods to add in-place two arrays of\nextended abstract_vector , i.e. No out-of-place alternative is currently available in LightKrylov .\nIf you do need an out-of-place version, you can combine axpby_basis with copy . Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension ( 10 ) :: alpha , beta ! ... Whatever your code is doing ... call axpby_basis ( X , alpha , Y , beta ) ! ... Rest of your code ... Module Procedures private  subroutine axpby_basis_rsp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(sp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . real(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rsp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . real(kind=sp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_rdp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(dp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . real(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rdp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . real(kind=dp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_csp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(sp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . complex(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_csp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . complex(kind=sp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_cdp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(dp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . complex(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_cdp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . complex(kind=dp), intent(in) :: beta Scalar multipliers.","tags":"","loc":"interface/axpby_basis.html"},{"title":"copy – LightKrylov","text":"public interface copy This interface provides methods to copy an array X of abstract_vector into\nanother array Y . Note that Y needs to be pre-allocated. Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y ! ... Your code ... call copy ( Y , X ) ! ... Your code ... Module Procedures private  subroutine copy_vector_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out class( abstract_vector_rsp ), intent(in) :: from private  subroutine copy_basis_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out (:) class( abstract_vector_rsp ), intent(in) :: from (:) private  subroutine copy_vector_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out class( abstract_vector_rdp ), intent(in) :: from private  subroutine copy_basis_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out (:) class( abstract_vector_rdp ), intent(in) :: from (:) private  subroutine copy_vector_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out class( abstract_vector_csp ), intent(in) :: from private  subroutine copy_basis_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out (:) class( abstract_vector_csp ), intent(in) :: from (:) private  subroutine copy_vector_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out class( abstract_vector_cdp ), intent(in) :: from private  subroutine copy_basis_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out (:) class( abstract_vector_cdp ), intent(in) :: from (:)","tags":"","loc":"interface/copy.html"},{"title":"innerprod – LightKrylov","text":"public interface innerprod Compute the inner product vector or matrix . Description This interface provides methods for computing the inner products between a basis\nof real or complex vectors and a single vector or another basis . Depending on the case, it\nreturns a one-dimensional array or a two-dimensional array with the same type as . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. It then computes the inner product\nvector defined as . type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ) :: y real ( dp ), dimension (:), allocatable :: v ! ... Part of your code where you initialize everything ... call innerprod ( v , X , y ) ! ... Rest of your code ... Similarly, computing the matrix of inner products between two bases can be done\nas shown below. type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension (:, :), allocatable :: M ! ... Part of your code where you initialize everything ... call innerprod ( M , X , Y ) ! ... Rest of your code ... Module Procedures private  subroutine innerprod_vector_rsp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_rsp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_rdp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_rdp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_csp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_csp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_cdp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_cdp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed.","tags":"","loc":"interface/innerprod.html"},{"title":"linear_combination – LightKrylov","text":"public interface linear_combination Given a set of extended abstract_vectors and coefficients, return the corresponding\nlinear combinations. Description This interface provides methods for computing linear combinations of a set of extended abstract_vectors . Depending on its input, it either computes i.e. a single vector, or i.e. a set of vectors of the same type as . Example type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension ( m , n ) :: B type ( my_real_vector ) :: Y ! ... Whatever your code is doing ... call linear_combination ( Y , X , B ) ! ... Rest of your code ... Module Procedures private  subroutine linear_combination_vector_rsp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rsp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_rdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_csp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_csp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_cdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_cdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations.","tags":"","loc":"interface/linear_combination.html"},{"title":"rand_basis – LightKrylov","text":"public interface rand_basis This interface provides methods to create an array X of random abstract_vector .\nIt is a simple wrapper around X(i)%rand(ifnorm) . Example type ( my_real_vector ), dimension ( 10 ) :: X logical :: ifnorm = . true . ! ... Your code ... call rand_basis ( X , ifnorm ) ! ... Your code ... Module Procedures private  subroutine rand_basis_rsp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_rdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_csp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_cdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm","tags":"","loc":"interface/rand_basis.html"},{"title":"zero_basis – LightKrylov","text":"public interface zero_basis This interface provides methods to zero-out a collection of abstract_vector X .\nIt is a simple wrapper around X(i)%zero() . Example type ( my_real_vector ), dimension ( 10 ) :: X ! ... Your code ... call zero_basis ( X ) ! ... Your code ... Module Procedures private  subroutine zero_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) private  subroutine zero_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) private  subroutine zero_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) private  subroutine zero_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:)","tags":"","loc":"interface/zero_basis.html"},{"title":"assert_shape – LightKrylov","text":"public interface assert_shape This interface provides methods to assert that the shape of its input vector\nor matrix is the expected shape. It throws an error if not. Module Procedures private  subroutine assert_shape_vector_rsp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_rsp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_rdp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_rdp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_csp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_csp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_cdp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_cdp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done.","tags":"","loc":"interface/assert_shape.html"},{"title":"eig – LightKrylov","text":"public interface eig Computes the eigenvalue decomposition of a general square matrix. Description This interface provides methods to compute the solution to the eigenproblem , where $\\mathbf{A}$ is a square real or complex matrix. Result array lambda returns the eigenvalues of , while vecs returns the corresponding eigenvectors. Note that it follows the LAPACK convention\nwhen is real . The solver is based on LAPACK's *GEEV backends. Syntax call eig(A, vecs, lambda) Arguments A : real or complex square array containing the coefficient matrix. It is an intent(in) argument. vecs : Square array of the same size, type, and kind as A containing the eigenvectors\n(following LAPACK's convention for real matrices). It is an intent(out) argument. lambda : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) argument. Note Due to the abstrct nature of the vector types defined in LightKrylov , it is unlikely\nthat this implementation will be superseeded in favor of the stdlib one as the latter\ndoes not follow the LAPACK's convention. Module Procedures private  subroutine eig_rsp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix to be factorized. real(kind=sp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=sp), intent(out) :: vals (:) private  subroutine eig_rdp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix to be factorized. real(kind=dp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=dp), intent(out) :: vals (:) private  subroutine eig_csp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix to be factorized. complex(kind=sp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=sp), intent(out) :: vals (:) private  subroutine eig_cdp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix to be factorized. complex(kind=dp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=dp), intent(out) :: vals (:)","tags":"","loc":"interface/eig.html"},{"title":"log2 – LightKrylov","text":"public interface log2 Utility function to compute the base-2 logarithm of a real number. Module Procedures private pure function log2_rsp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) private pure function log2_rdp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp)","tags":"","loc":"interface/log2.html"},{"title":"norml – LightKrylov","text":"public interface norml This interface provides methods to compute the infinity norm of a matrix.\nNote that it'll eventually be superseeded by the stdlib implementation. Module Procedures private pure function norml_rsp(A) result(norm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private pure function norml_rdp(A) result(norm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private pure function norml_csp(A) result(norm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private pure function norml_cdp(A) result(norm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)","tags":"","loc":"interface/norml.html"},{"title":"ordschur – LightKrylov","text":"public interface ordschur Given the Schur factorization and basis of a matrix, reorders it to have the selected\neigenvalues in the upper left block. Description This interface provides methods to re-order the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Syntax call ordschur(T, Q, selected) Arguments T : real or complex square array containing the Schur factorization of a matrix. \nOn exit, it is overwritten with its re-ordered counterpart. It is an intent(inout) argument. Q : Two-dimensional square array of the same size, type and kind as A . It contains\nthe original Schur basis on entry and the re-ordered one on exit.\nIt is an intent(inout) argument. selected : logical rank-1 array selecting which eigenvalues need to be moved in the\nupper left block of the Schur factorization.\nIt is an intent(in) arguement. Module Procedures private  subroutine ordschur_rsp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. real(kind=sp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_rdp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. real(kind=dp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_csp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. complex(kind=sp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_cdp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. complex(kind=dp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues.","tags":"","loc":"interface/ordschur.html"},{"title":"schur – LightKrylov","text":"public interface schur Computes the Schur factorization of a general square matrix. Description This interface provides methods to compute the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Result array eigvals returns the eigenvalues of while Z contains the Schur basis. Syntax call schur(A, Z, eigvals) Arguments A : real or complex square array containing the coefficient matrix. On exit, it\nis overwritten with its (real) Schur factorization. It is an intent(inout) argument. Z : Two-dimensional square array of the same size, type and kind as A . It contains\nthe Schur basis. It is an intent(out) argument. eigvals : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) arguement. Module Procedures private  subroutine schur_rsp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: A (:,:) Matrix to be factorized. real(kind=sp), intent(out) :: Z (:,:) Schur basis. complex(kind=sp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_rdp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) Matrix to be factorized. real(kind=dp), intent(out) :: Z (:,:) Schur basis. complex(kind=dp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_csp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: A (:,:) Matrix to be factorized. complex(kind=sp), intent(out) :: Z (:,:) Schur basis. complex(kind=sp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_cdp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: A (:,:) Matrix to be factorized. complex(kind=dp), intent(out) :: Z (:,:) Schur basis. complex(kind=dp), intent(out) :: eigvals (:) Eigenvalues.","tags":"","loc":"interface/schur.html"},{"title":"sqrtm – LightKrylov","text":"public interface sqrtm Computes the non-negative square root of a symmetric positive definite matrix\nusing its singular value decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. Module Procedures private  subroutine sqrtm_rsp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt real(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_rdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt real(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_csp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt complex(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_cdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt complex(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag","tags":"","loc":"interface/sqrtm.html"},{"title":"sqrtm_eig – LightKrylov","text":"public interface sqrtm_eig Computes the non-negative square root of a symmetric positive definite matrix\nusing its eigenvalue decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm_eig(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. Module Procedures private  subroutine sqrtm_eig_rsp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: X (:,:) Matrix of which to compute the sqrt real(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_rdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: X (:,:) Matrix of which to compute the sqrt real(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_csp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: X (:,:) Matrix of which to compute the sqrt complex(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_cdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: X (:,:) Matrix of which to compute the sqrt complex(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag","tags":"","loc":"interface/sqrtm_eig.html"},{"title":"get_comm_size – LightKrylov","text":"public pure function get_comm_size() result(c_size) Utility function to get the dimension of the communicator known to LightKrylov . Arguments None Return Value integer Source Code pure integer function get_comm_size () result ( c_size ) !! Utility function to get the dimension of the communicator known to `LightKrylov`. c_size = comm_size end function get_comm_size","tags":"","loc":"proc/get_comm_size.html"},{"title":"get_rank – LightKrylov","text":"public pure function get_rank() result(rank) Utility function to get the rank of the current MPI process. Arguments None Return Value integer Source Code pure integer function get_rank () result ( rank ) !! Utility function to get the rank of the current MPI process. rank = nid end function get_rank","tags":"","loc":"proc/get_rank.html"},{"title":"io_rank – LightKrylov","text":"public pure function io_rank() result(is_io) Utility function to determine whether the current MPI process can do I/O. Arguments None Return Value logical Source Code pure logical function io_rank () result ( is_io ) !! Utility function to determine whether the current MPI process can do I/O. is_io = . false . if ( nid == nio ) is_io = . true . end function io_rank","tags":"","loc":"proc/io_rank.html"},{"title":"set_comm_size – LightKrylov","text":"public  subroutine set_comm_size(c_size) Utility function to inform LightKrylov of the MPI-communicator's dimension. Arguments Type Intent Optional Attributes Name integer :: c_size Dimension of the MPI communicator. Source Code subroutine set_comm_size ( c_size ) !! Utility function to inform `LightKrylov` of the MPI-communicator's dimension. integer :: c_size !! Dimension of the MPI communicator. comm_size = c_size end subroutine set_comm_size","tags":"","loc":"proc/set_comm_size.html"},{"title":"set_io_rank – LightKrylov","text":"public  subroutine set_io_rank(rk) Utility function to set the rank of the process doing I/O. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk Desired rank for the IO process.","tags":"","loc":"proc/set_io_rank.html"},{"title":"set_rank – LightKrylov","text":"public  subroutine set_rank(rank) Utility function to set the rank of an MPI process. Arguments Type Intent Optional Attributes Name integer :: rank Desired rank identification. Source Code subroutine set_rank ( rank ) !! Utility function to set the rank of an MPI process. integer :: rank !! Desired rank identification. nid = rank end subroutine set_rank","tags":"","loc":"proc/set_rank.html"},{"title":"LightKrylov – LightKrylov","text":"Uses LightKrylov_AbstractLinops LightKrylov_AbstractVectors LightKrylov_ExpmLib LightKrylov_Constants LightKrylov_utils LightKrylov_AbstractSystems LightKrylov_BaseKrylov LightKrylov_NewtonKrylov LightKrylov_IterativeSolvers Subroutines public  subroutine greetings () Arguments None","tags":"","loc":"module/lightkrylov.html"},{"title":"LightKrylov_BaseKrylov – LightKrylov","text":"This module provides a collection of Krylov-based factorizations forming the\ncomputational core of LightKrylov . It also provides a set of utility functions\nto operate on arrays of abstract_vector . The most important ones are: arnoldi(A, X, H, info) : Arnoldi factorization for general square matrices. lanczos(A, X, H, info) : Lanczos factorization for general symmetric/hermitian matrices. bidiagonalization(A, U, V, B) : Lanczos bidiagonalization for arbitrary matrices. qr(X, R, perm, info) : QR factorization (with and without column pivoting) of an array of abstract_vector . Uses LightKrylov_AbstractLinops stdlib_linalg LightKrylov_AbstractVectors stdlib_optval LightKrylov_Constants LightKrylov_utils iso_fortran_env LightKrylov_Logger Interfaces public        interface apply_inverse_permutation_matrix Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector and its inverse. Syntax call apply_inverse_permutation_matrix ( X , perm ) Arguments Q : Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n     column-permuted version computed in-place. It is an intent(inout) argument. perm : Rank-1 array of integer corresponding to the desired permutation vector.\n        It is an intent(in) argument. private  subroutine apply_inverse_permutation_matrix_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_inverse_permutation_matrix_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be (un-) permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). public        interface apply_permutation_matrix Description Given an array and a permutation vector , this function computes in-place the column-permuted matrix where is the column-permutation matrix constructed from the permutation\nvector . Syntax call apply_permutation_matrix ( X , perm ) Arguments Q : Array of vectors derived from the base types defined in the AbstractVectors module. On entry, it is the original array. On exit, it contains the\n     column-permuted version computed in-place. It is an intent(inout) argument. perm : Rank-1 array of integer corresponding to the desired permutation vector.\n        It is an intent(in) argument. private  subroutine apply_permutation_matrix_rsp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_rsp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_rdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_rdp(Q, perm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_csp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_csp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_cdp(Q, perm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). private  subroutine apply_permutation_matrix_array_cdp(Q, perm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: Q (:,:) Basis vectors to be permuted. integer, intent(in) :: perm (:) Permutation matrix (vector representation). public        interface arnoldi Description Given a square linear operator , find matrices and such that where is an orthogonal basis and is upper Hessenberg. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Gram-Schmidt process. Constructs an upper Hessenberg matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.3: Arnoldi's method. Syntax call arnoldi ( A , X , H , info [, kstart ] [, kend ] [, tol ] [, transpose ] [, blksize ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. The operator needs to be square, i.e. the dimension of its domain and\n      co-domain is the same. It is an intent(in) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors. The first entry X(1) is the starting vector for\n      the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps\n      is equal to size(X) - 1 . It is an intent(inout) argument. H : real or complex rank-2 array. On exit, it contains the upper Hessenberg matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Arnoldi factorization experienced a lucky breakdown. \n          The array of Krylov vectors X spans an -invariant subpsace of\n          dimension info . kstart ( optional ): integer value determining the index of the first Arnoldi\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Arnoldi step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . transpose ( optional ): logical flag determining whether the Arnoldi factorization\n                           is applied to or . Default transpose = .false. blksize ( optional ): integer value determining the dimension of a block for the\n                        block Arnoldi factorization. Default is blksize=1 . private  subroutine arnoldi_rsp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_rdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_csp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=sp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). private  subroutine arnoldi_cdp(A, X, H, info, kstart, kend, tol, transpose, blksize) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: X (:) Orthogonal basis for the generated Krylov subspace. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Arnoldi factorization (default 1). integer, intent(in), optional :: kend Final index for the Arnoldi factorization (default size(X)-1 ) real(kind=dp), intent(in), optional :: tol Tolerance to determine whether an invariant subspace has been computed or not. logical, intent(in), optional :: transpose Whether is being transposed or not (default .false. ) integer, intent(in), optional :: blksize Block size for block Arnoldi (default 1). public        interface bidiagonalization Description Given a general linear operator , find matrices , and such that where and are orthogonal bases for the column span and row span\nof , respectively, and is a bidiagonal matrix. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis for the column span of . Constructs an orthonormal Krylov basis for the row span of . Constructs a bidiagonal matrix whose singular values approximates \n  those of . Checks for convergence and invariant subspaces. References R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" \n  Technical Report, 1998. (PDF) Syntax call bidiagonalization ( A , U , V , B , info [, kstart ] [, kend ] [, tol ]) Arguments A : Linear operator derived from one the base types provided by the AbstractLinops module. It is an intent(in) argument. U : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors for the column span of A . The first entry U(1) is the starting vector for the Lanczos factorization. Additionally, the \n      maximum number of Lanczos steps is equal to size(X) - 1 . \n      It is an intent(inout) argument. V : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors for the row span of A . It is an intent(inout) argument. B : real or complex rank-2 array. On exit, it contains the bidiagonal matrix computed from the Lanczos factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. kstart ( optional ): integer value determining the index of the first Lanczos\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Lanczos step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . private  subroutine lanczos_bidiagonalization_rsp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rsp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rsp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_rdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_rdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_rdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . real(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_csp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_csp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_csp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=sp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=sp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. private  subroutine lanczos_bidiagonalization_cdp(A, U, V, B, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be factorized. class( abstract_vector_cdp ), intent(inout) :: U (:) Orthonormal basis for the column span of . On entry, U(1) needs to be set to\nthe starting Krylov vector. class( abstract_vector_cdp ), intent(inout) :: V (:) Orthonormal basis for the row span of . complex(kind=dp), intent(inout) :: B (:,:) Bidiagonal matrix. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kstart Starting index for the Lanczos factorization (default 1). integer, intent(in), optional :: kend Final index for the Lanczos factorization (default 1). real(kind=dp), intent(in), optional :: tol Tolerance to determine whether invariant subspaces have been computed or not. public        interface double_gram_schmidt_step Description Given an array of abstract_vector and an abstract_vector (or array of abstract_vectors ) , this subroutine returns a modified \nvector orthogonal to all columns of , i.e. using a double Gram-Schmidt process. On exit, is orthogonal to albeit\ndoes not have unit-norm. Note moreover that is assumed to be an orthonormal \nset of vectors. The function can also return the projection coefficients . Syntax call double_gram_schmidt_step ( y , X , info [, if_chk_orthonormal ] [, beta ]) Arguments y : abstract_vector (or array of abstract_vector ) that needs to be\n      orthogonalize in-place against . X : Array of abstract_vector against which needs to be orthogonalized.\n      Note the function assumes that is an orthonormal set of vectors, i.e. . If it this is not the case, the result are meaningless. info : integer Information flag. if_chk_orthonormal ( optional ) : logical flag (default .true. ) to check\n    whether is an orthonormal set of vectors or not. If the orthonormality\n    returns .false. , the function throws an error. Note that this check is however\n    computationally expensive and can be disable for the sake of performances. beta ( optional ) : real or complex array containing the coefficients . private  subroutine DGS_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine DGS_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine DGS_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Computes one step of the double Gram-Schmidt orthogonalization process of the abstract_vector y against the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested public        interface initialize_krylov_subspace Description Utility function to initialize a basis for a Krylov subspace. Syntax call initialize_krylov_subspace ( X [, X0 ]) Arguments X : Array of vectors that needs to be initialized. It is an intent(inout) argument. Note that the first action in the subroutine is call zero_basis(X) , effectively zeroing-out any data stored. X0 ( optional ) : Collection of vectors which will form the first few\n                    Krylov vectors. Note that X0 need not be an orthonormal\n                    basis as this subroutine includes a call qr(X0) . private  subroutine initialize_krylov_subspace_rsp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) class( abstract_vector_rsp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_rdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) class( abstract_vector_rdp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_csp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) class( abstract_vector_csp ), intent(in), optional :: X0 (:) private  subroutine initialize_krylov_subspace_cdp(X, X0) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) class( abstract_vector_cdp ), intent(in), optional :: X0 (:) public        interface is_orthonormal Description Utility function returning a logical .true. if the set of vectors stored in form\nan orthonormal set of vectors and .false. otherwise. Syntax out = is_orthonormal ( X ) Arguments X : Array of derived types extended from the base types provided in the AbstractVectors module. private  function is_orthonormal_rsp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_rdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_csp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(in) :: X (:) Return Value logical private  function is_orthonormal_cdp(X) result(ortho) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(in) :: X (:) Return Value logical public        interface krylov_schur Description Given a partial Krylov decomposition this subroutine implements the Krylov-Schur restarting strategy proposed by\nStewart [1]. References G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\".\n  SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. Syntax call krylov_schur ( n , X , H , select_eigs ) Arguments n : Number of selected eigenvalues moved to the upper left-block of the \n      Schur matrix. It is an intent(out) argument. X : On entry, array of abstract_vector computed using the Arnoldi process.\n      On exit, the first n columns form an orthonormal basis for the eigenspace\n      associated with eigenvalues moved to the upper left-block of the Schur matrix.\n      It is an intent(inout) argument. H : On entry, real of complex upper Hessenberg matrix computed using the\n      Arnoldi process. On exit, the leading block contains the block of the re-ordered Schur matrix containing the selected\n      eigenvalues. It is an intent(inout) argument. select_eigs : Procedure to select which eigenvalues to move in the upper-left\n                block. It is an intent(inout) argument. private  subroutine krylov_schur_rsp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rsp ), intent(inout) :: X (:) Krylov basis. real(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_sp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_rdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_rdp ), intent(inout) :: X (:) Krylov basis. real(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_dp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_csp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_csp ), intent(inout) :: X (:) Krylov basis. complex(kind=sp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_sp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. private  subroutine krylov_schur_cdp(n, X, H, select_eigs) Arguments Type Intent Optional Attributes Name integer, intent(out) :: n Number eigenvalues that have been moved to the upper\nleft block of the Schur factorization of H . class( abstract_vector_cdp ), intent(inout) :: X (:) Krylov basis. complex(kind=dp), intent(inout) :: H (:,:) Upper Hessenberg matrix. procedure( eigvals_select_dp ) :: select_eigs Procedure to select the eigenvalues to move in the upper left-block. public        interface lanczos Description Given a symmetric or Hermitian linear operator , find matrices and such that where is an orthogonal basis and is symmetric tridiagonal. Algorithmic Features The operator only needs to be accessed through matrix-vector products. Constructs an orthonormal Krylov basis via the Lanczos process with full\n  reorthogonalization. Constructs a symmetric tridiagonal matrix whose eigenvalues approximates those of . Checks for convergence and invariant subspaces. References Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003.\n  see Chapter 6.6: The symmetric Lanczos algorithm. Syntax call lanczos ( A , X , T , info [, kstart ] [, kend ] [, tol ]) Arguments A : Symmetric or Hermitian linear operator derived from one the base types \n      provided by the AbstractLinops module. It is an intent(in) argument. X : Array of types derived from one the base types provided by the AbstractVectors module. It needs to be consistent with the type of A . On exit, it contains the\n      the computed Krylov vectors. The first entry X(1) is the starting vector for\n      the Lanczos factorization. Additionally, the maximum number of Lanczos steps\n      is equal to size(X) - 1 . It is an intent(inout) argument. T : real or complex rank-2 array. On exit, it contains the symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an intent(inout) argument. info : integer variable. It is the LightKrylov information flag. On exit, if info > 0, the Lanczos factorization experienced a lucky breakdown. \n          The array of Krylov vectors X spans an -invariant subpsace of\n          dimension info . kstart ( optional ): integer value determining the index of the first Lanczos\n                        step to be computed. By default, kstart = 1 . kend ( optional ): integer value determining the index of the last Lanczos step\n                      to be computed. By default, kend = size(X) - 1 . tol ( optional ): Numerical tolerance below which a subspace is considered\n                    to be -invariant. By default tol = atol_sp or tol = atol_rp depending on the kind of A . private  subroutine lanczos_tridiagonalization_rsp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A class( abstract_vector_rsp ), intent(inout) :: X (:) real(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_rdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A class( abstract_vector_rdp ), intent(inout) :: X (:) real(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_csp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A class( abstract_vector_csp ), intent(inout) :: X (:) complex(kind=sp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=sp), intent(in), optional :: tol private  subroutine lanczos_tridiagonalization_cdp(A, X, T, info, kstart, kend, tol) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A class( abstract_vector_cdp ), intent(inout) :: X (:) complex(kind=dp), intent(inout) :: T (:,:) integer, intent(out) :: info integer, intent(in), optional :: kstart integer, intent(in), optional :: kend real(kind=dp), intent(in), optional :: tol public        interface orthogonalize_against_basis private  subroutine orthogonalize_vector_against_basis_rsp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_rsp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rsp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_rdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_rdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_rdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal real(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_csp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_csp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_csp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=sp), intent(out), optional :: beta (:,:) Projection coefficients if requested private  subroutine orthogonalize_vector_against_basis_cdp(y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: y Input abstract_vector to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:) Projection coefficients if requested private  subroutine orthogonalize_basis_against_basis_cdp(Y, X, info, if_chk_orthonormal, beta) Orthogonalizes the abstract_vector basis Y against a basis X of abstract_vector . Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Y (:) Input abstract_vector basis to orthogonalize class( abstract_vector_cdp ), intent(in) :: X (:) Input abstract_vector basis to orthogonalize against integer, intent(out) :: info Information flag. logical, intent(in), optional :: if_chk_orthonormal complex(kind=dp), intent(out), optional :: beta (:,:) Projection coefficients if requested public        interface orthonormalize_basis Description Given an array of vectors, it computes an orthonormal basis for its\ncolumn-span using the double_gram_schmidt process. All computations are done\nin-place. Syntax call orthonormalize_basis ( X ) Arguments X : Array of abstract_vector to orthonormalize. Note that this process is done\n      in-place. It is an intent(inout) argument. private  subroutine orthonormalize_basis_rsp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_rdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_csp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against private  subroutine orthonormalize_basis_cdp(X) Orthonormalizes the abstract_vector basis X Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input abstract_vector basis to orthogonalize against public        interface qr Description Given an array of types derived from abstract_vector , it computes the in-place QR factorization of , i.e. where is an orthonormal arrays of vectors such that and is upper triangular. Note that it can also perform the QR factorization\nwith column pivoting where is a permutation matrix ensuring that the diagonal entries of have non-increasing absolute values. This amounts to using the pivoting QR as a\nrank-revealing factorization. References G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins\n University Press, 2013.\n See Chapter 5.2.8: Modified Gram-Schmidt algorithm. Syntax call qr ( Q [, R ] [, perm ], info [, tol ]) Arguments Q : Array of types derived from one of the base types provided in the AbstractVectors module. On entry, it contains the original array.\n     On exit, it is overwritten by the orthogonal basis for its span.\n     It is an intent(inout) argument. R : real or complex rank-2 array. On exit, its contains the upper triangular\n      matrix resulting from the QR factorization. It is an intent(out) argument. perm ( optional ): Rank-1 array of integer corresponding to the indices of\n                     permuted columns. If perm is absent, the naive QR factorization\n                     is being computed. info : integer information flag. tol ( optional ): Numerical tolerance to determine whether two vectors are colinear\n                    or not. Default tol = atol_sp or tol = atol_dp . private  subroutine qr_no_pivoting_rsp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_rsp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_rdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_rdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. real(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_csp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_csp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=sp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: tol Tolerance to detect colinearity. private  subroutine qr_no_pivoting_cdp(Q, R, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to determine colinearity. private  subroutine qr_with_pivoting_cdp(Q, R, perm, info, tol) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: Q (:) Array of abstract_vector to be orthogonalized. complex(kind=dp), intent(out) :: R (:,:) Upper triangular matrix resulting from the QR factorization. integer, intent(out) :: perm (size(Q)) Permutation matrix. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: tol Tolerance to detect colinearity. Abstract Interfaces abstract interface public  function eigvals_select_dp(lambda) result(selected) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: lambda (:) Return Value logical, (size(lambda)) abstract interface public  function eigvals_select_sp(lambda) result(selected) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: lambda (:) Return Value logical, (size(lambda))","tags":"","loc":"module/lightkrylov_basekrylov.html"},{"title":"LightKrylov_AbstractSystems – LightKrylov","text":"This module provides the abstract types necessary to define an algebraic system of\nnonlinear equations to be solved using the Newton method. Uses LightKrylov_Constants LightKrylov_AbstractLinops LightKrylov_AbstractVectors Derived Types type, public, abstract, extends( abstract_linop_cdp ) :: abstract_jacobian_linop_cdp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_cdp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_csp ) :: abstract_jacobian_linop_csp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_csp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rdp ) :: abstract_jacobian_linop_rdp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_rdp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rsp ) :: abstract_jacobian_linop_rsp Abstract type for the local linearization of the system around the state X Components Type Visibility Attributes Name Initial class( abstract_vector_rsp ), public, allocatable :: X System state around which the equatons are linearized. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract :: abstract_system type, public, abstract, extends( abstract_system ) :: abstract_system_cdp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_cdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_cdp), public, deferred, pass(self) :: eval ../../ Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_csp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_csp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_csp), public, deferred, pass(self) :: eval ../../ Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_rdp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rdp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_rdp), public, deferred, pass(self) :: eval ../../ Procedure to evaluate the system response . type, public, abstract, extends( abstract_system ) :: abstract_system_rsp System for Newton fixed-point iteration via the Jacobian Components Type Visibility Attributes Name Initial class( abstract_jacobian_linop_rsp ), public, allocatable :: jacobian System Jacobian . Type-Bound Procedures procedure(abstract_eval_rsp), public, deferred, pass(self) :: eval ../../ Procedure to evaluate the system response .","tags":"","loc":"module/lightkrylov_abstractsystems.html"},{"title":"LightKrylov_ExpmLib – LightKrylov","text":"This module implements the evaluation of the \"matrix-exponential times vector\" procedure\nusing Krylov methods. Uses LightKrylov_AbstractLinops stdlib_linalg LightKrylov_AbstractVectors stdlib_optval LightKrylov_Constants LightKrylov_utils LightKrylov_BaseKrylov iso_fortran_env LightKrylov_Logger Interfaces public        interface expm Description Evaluate the exponential of a dense matrix using Pade approximations. Syntax E = expm ( A , order ) Arguments E : real or complex rank-2 array with . A : real or complex matrix that needs to be exponentiated. order (optional) : Order of the Pade approximation. By default order = 10 . private  function expm_rsp(A, order) result(E) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value real(kind=sp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_rdp(A, order) result(E) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value real(kind=dp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_csp(A, order) result(E) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value complex(kind=sp), (size(A,1),size(A,1)) Output matrix E = exp(tA). private  function expm_cdp(A, order) result(E) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix to be exponentiated. integer, intent(in), optional :: order Order of the Pade approximation. Return Value complex(kind=dp), (size(A,1),size(A,1)) Output matrix E = exp(tA). public        interface k_exptA Description Utility function to evaluate the matrix-exponential times vector. Syntax call k_exptA ( vec_out , A , vec_in , tau , info , trans ) Arguments vec_out : Output vector. A : Matrix to be exponentiated. vec_in : Input vector. tau : Integration time. info : Information flag. trans : Whether or is being used. private  subroutine k_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_csp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? private  subroutine k_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector to be multiplied by . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use adjoint ? public        interface kexpm Description This interface provides methods to evaluate the matrix-vector product based on the Arnoldi method. Syntax call kexpm ( c , A , b , tau , tol , info [, trans ] [, kdim ]) Arguments c : Output vector (or vectors). It is an intent(out) argument. A : Linear operator to be exponentiated. It is an intent(in) argument. b : Vector to be multiplied by . It is an intent(in) argument. tau : real (singe or double) time over which the matrix exponential needs to\n        be computed. It is an intent(in) argument. info : integer Information flag. trans (optional) : Whether or is being used.\n                    (default trans=.false. ) kdim (optional) : Dimension of the Krylov subspace used in the Arnoldi method. private  subroutine kexpm_vec_rsp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_rsp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rsp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_rsp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_rdp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_rdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_rdp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_rdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_csp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_csp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: b Input vector on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_csp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_csp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=sp), intent(in) :: tau Time horizon for the exponentiation. real(kind=sp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_vec_cdp(c, A, b, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: c Best approximation of in the computed Krylov subspace class( abstract_linop_cdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: b Input vector on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution tolerance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. private  subroutine kexpm_mat_cdp(C, A, B, tau, tol, info, trans, kdim) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: C (:) Best Krylov approximation of . class( abstract_linop_cdp ), intent(in) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: B (:) Input matrix on which to apply . real(kind=dp), intent(in) :: tau Time horizon for the exponentiation. real(kind=dp), intent(in) :: tol Solution toleance based on error estimates. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? integer, intent(in), optional :: kdim Maximum size of the Krylov subspace. Abstract Interfaces abstract interface public  subroutine abstract_exptA_cdp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_cdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_cdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_csp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: vec_out Solution vector. class( abstract_linop_csp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_csp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_rdp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rdp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rdp ), intent(in) :: vec_in Input vector. real(kind=dp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ? abstract interface public  subroutine abstract_exptA_rsp(vec_out, A, vec_in, tau, info, trans) Abstract interface to define the matrix exponential-vector product. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: vec_out Solution vector. class( abstract_linop_rsp ), intent(inout) :: A Linear operator to be exponentiated. class( abstract_vector_rsp ), intent(in) :: vec_in Input vector. real(kind=sp), intent(in) :: tau Time horizon for integration. integer, intent(out) :: info Information flag. logical, intent(in), optional :: trans Use transpose ?","tags":"","loc":"module/lightkrylov_expmlib.html"},{"title":"LightKrylov_NewtonKrylov – LightKrylov","text":"Uses LightKrylov_AbstractLinops LightKrylov_AbstractVectors stdlib_optval LightKrylov_Constants LightKrylov_utils LightKrylov_AbstractSystems LightKrylov_Logger LightKrylov_IterativeSolvers Interfaces public        interface newton Implements the simple Newton-Krylov method for finding roots (fixed points) of a nonlinear vector-valued function , i.e. solutions such that starting from an initial guess via successive solution increments based on local linearization (the Jacobian) of the nonlinear function in the vicinity of the current solution. Algorthmic Features At iteration , the standard Newton step is computed as the solution of the linear system where is the residual of the nonlinear function. The new guess for the fixed\n  point is then given by: where parametrizes the step length. The standard Newton algorithm sets . The Jacobian is never assembled and the linear system is solved using one of the available iterative solvers. When the residual norm does not decrease during iteration indicating that the linearization is not a very\n  accurate model of the function's behaviour, which often happens during the initial iterations, a 1D step bisection\n  method based on the golden ratio is implemented to dampen the step and improve convergence of the method. The implementation allows for dynamic tolerances (also known as inexact Newton), where the approximation for \n  the residual and the linear system can be solved with relaxed tolerances to reduce overall time to solution. The method is suitable to both fixed points and periodic orbits via the choice of residual and corresponding\n  Jacobian matrix. In the case of unforced periodic orbits, the period is itself an unknown that must be included\n  in the iteration. Advantages The iterative solution of the linear systems has a comparatively low storage footprint. If the Newton iteration converges, the convergence is formally asymptotically of second order. Using dynamic\n  tolerances and line searches slightly reduce this convergence rate in exchange for a larger convergence region. Limitations The method is not guaranteed to converge if the initial guess is too far from the fixed point. \n  If the Newton iteration diverges even with step bisection, the best suggestion is to find a \n  better initial guess. If this is not feasible, some alternatives to improve the convergence \n  of the Newton iteration are possible (but not implemented to date), including various line search\n  algorithms and trust region methods (doglog, double dogleg, hookstep, ...). References Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov continuation of periodic orbits \n  for Navier–Stokes flows\". Journal of Computational Physics, 201(1), 13-33. Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". Journal of Fluid Mechanics, 580, 339-358. Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits in transitional pipe flow\". Physics\n  of Fluids, 20(11), 114102. Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for large-scale dynamical systems: Application \n  in fluid dynamics\". Applied Mechanics Reviews, 75(3), 030802. private  subroutine newton_rsp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_rsp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rsp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rsp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: tolerance type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler private  subroutine newton_rdp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_rdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_rdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_rdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: tolerance type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler private  subroutine newton_csp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_csp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_csp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_csp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=sp), intent(in), optional :: tolerance type( newton_sp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_sp), optional :: scheduler private  subroutine newton_cdp(sys, X, solver, info, tolerance, options, linear_solver_options, preconditioner, scheduler) Arguments Type Intent Optional Attributes Name class( abstract_system_cdp ), intent(inout) :: sys Dynamical system for which we wish to compute a fixed point class( abstract_vector_cdp ), intent(inout) :: X Initial guess for the fixed point, will be overwritten with solution procedure( abstract_linear_solver_cdp ) :: solver Linear solver to be used to find Newton step integer, intent(out) :: info Information flag real(kind=dp), intent(in), optional :: tolerance type( newton_dp_opts ), intent(in), optional :: options class( abstract_opts ), intent(in), optional :: linear_solver_options Options for the linear solver class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner for the linear solver procedure(abstract_scheduler_dp), optional :: scheduler Subroutines public  subroutine constant_atol_dp (tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine constant_atol_sp (tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine dynamic_tol_dp (tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: tol Tolerance to be used real(kind=dp), intent(in) :: target_tol Target tolerance real(kind=dp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag public  subroutine dynamic_tol_sp (tol, target_tol, rnorm, iter, info) Abstract interface to define tolerance scheduler for the Newton iteration Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: tol Tolerance to be used real(kind=sp), intent(in) :: target_tol Target tolerance real(kind=sp), intent(in) :: rnorm Norm of the residual of the current iterate integer, intent(in) :: iter Newton iteration count integer, intent(out) :: info Information flag","tags":"","loc":"module/lightkrylov_newtonkrylov.html"},{"title":"LightKrylov_AbstractLinops – LightKrylov","text":"This module provides the base classes abtract_linop_rsp , abstract_linop_rdp , abstract_linop_csp and abstract_linop_cdp which can be used to define your own\nlinear operators. To do so, you simply need to provide two type-bound procedures: matvec(self, vec_in, vec_out) : Computes the matrix-vector product. rmatvec(self, vec_in, vec_out) : Computes the transpose matrix-vector product. It also provides extended types to define the identity operator, symmetric linear\noperators, scalar-multiplication of a linear multiplication, as well as addition\nof two linear operators. Uses LightKrylov_Constants LightKrylov_utils LightKrylov_AbstractVectors Derived Types type, public, extends( abstract_linop_cdp ) :: Id_cdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_cdp procedure, public, pass(self) :: rmatvec => id_matvec_cdp type, public, extends( abstract_linop_csp ) :: Id_csp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_csp procedure, public, pass(self) :: rmatvec => id_matvec_csp type, public, extends( abstract_linop_rdp ) :: Id_rdp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_rdp procedure, public, pass(self) :: rmatvec => id_matvec_rdp type, public, extends( abstract_linop_rsp ) :: Id_rsp Utility type to define the Identity operator. Note that the type-bound procedures\nfor matvec and rmatvec do not have to be defined by the user. Type-Bound Procedures procedure, public, pass(self) :: matvec => id_matvec_rsp procedure, public, pass(self) :: rmatvec => id_matvec_rsp type, public, abstract, extends( abstract_linop_cdp ) :: abstract_hermitian_linop_cdp Abstract representation of an abstract hermitian (complex-valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_csp ) :: abstract_hermitian_linop_csp Abstract representation of an abstract hermitian (complex-valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract :: abstract_linop Base type to define an abstract linear operator. All other types defined in LightKrylov derive from this fundamental one. Read more… type, public, abstract, extends( abstract_linop ) :: abstract_linop_cdp Base type to extend in order to define a complex(dp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_cdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_cdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_csp Base type to extend in order to define a complex(sp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_csp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_csp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_rdp Base type to extend in order to define a real(dp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop ) :: abstract_linop_rsp Base type to extend in order to define a real(sp)-valued linear operator. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rdp ) :: abstract_sym_linop_rdp Abstract representation of an abstract symmetric (real valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_rdp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rdp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, abstract, extends( abstract_linop_rsp ) :: abstract_sym_linop_rsp Abstract representation of an abstract symmetric (real valued) linear operator. Type-Bound Procedures procedure(abstract_matvec_rsp), public, deferred, pass(self) :: matvec ../../ Procedure to compute the matrix-vector product . procedure(abstract_matvec_rsp), public, deferred, pass(self) :: rmatvec ../../ Procedure to compute the reversed matrix-vector product . type, public, extends( abstract_linop_cdp ) :: adjoint_linop_cdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_cdp procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: adjoint_linop_csp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_csp procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: adjoint_linop_rdp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_rdp procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: adjoint_linop_rsp Utility type to define an adjoint linear operator. The definition of matvec and rmatvec are directly inherited from those used to define A . Note that this utility does not\ncompute the adjoint for you. It simply provides a utility to define a new operator\nwith matvec and rmatvec being switched. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Linear operator whose adjoint needs to be defined. Type-Bound Procedures procedure, public, pass(self) :: matvec => adjoint_matvec_rsp procedure, public, pass(self) :: rmatvec => adjoint_rmatvec_rsp type, public, extends( abstract_linop_cdp ) :: axpby_linop_cdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_cdp ), public, allocatable :: B Underlying linear operators. complex(kind=dp), public :: alpha Scaling factors. complex(kind=dp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_cdp procedure, public, pass(self) :: rmatvec => axpby_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: axpby_linop_csp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_csp ), public, allocatable :: B Underlying linear operators. complex(kind=sp), public :: alpha Scaling factors. complex(kind=sp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_csp procedure, public, pass(self) :: rmatvec => axpby_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: axpby_linop_rdp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rdp ), public, allocatable :: B Underlying linear operators. real(kind=dp), public :: alpha Scaling factors. real(kind=dp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_rdp procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: axpby_linop_rsp Utility type to define a composite linear operator .\nThe definitions of matvec and rmatvec are directly inherited from those used to\ndefine A and B . Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Underlying linear operators. class( abstract_linop_rsp ), public, allocatable :: B Underlying linear operators. real(kind=sp), public :: alpha Scaling factors. real(kind=sp), public :: beta Scaling factors. logical, public :: transA = .false. Logical flag to control whether and/or need to be transposed. logical, public :: transB = .false. Logical flag to control whether and/or need to be transposed. Type-Bound Procedures procedure, public, pass(self) :: matvec => axpby_matvec_rsp procedure, public, pass(self) :: rmatvec => axpby_rmatvec_rsp type, public, extends( abstract_linop_cdp ) :: scaled_linop_cdp Defines a scaled linear operator with a complex-valued operator and . Components Type Visibility Attributes Name Initial class( abstract_linop_cdp ), public, allocatable :: A Base linear operator to be scaled. complex(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_cdp procedure, public, pass(self) :: rmatvec => scaled_rmatvec_cdp type, public, extends( abstract_linop_csp ) :: scaled_linop_csp Defines a scaled linear operator with a complex-valued operator and . Components Type Visibility Attributes Name Initial class( abstract_linop_csp ), public, allocatable :: A Base linear operator to be scaled. complex(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_csp procedure, public, pass(self) :: rmatvec => scaled_rmatvec_csp type, public, extends( abstract_linop_rdp ) :: scaled_linop_rdp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to\nbe defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rdp ), public, allocatable :: A Base linear operator to be scaled. real(kind=dp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_rdp procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rdp type, public, extends( abstract_linop_rsp ) :: scaled_linop_rsp Defines a scaled linear operator with a real-valued operator and . The definitions of matvec and rmatvec are directly inherited from those used to define A and do not have to\nbe defined by the user. Components Type Visibility Attributes Name Initial class( abstract_linop_rsp ), public, allocatable :: A Base linear operator to be scaled. real(kind=sp), public :: sigma Scaling factor. Type-Bound Procedures procedure, public, pass(self) :: matvec => scaled_matvec_rsp procedure, public, pass(self) :: rmatvec => scaled_rmatvec_rsp","tags":"","loc":"module/lightkrylov_abstractlinops.html"},{"title":"LightKrylov_IterativeSolvers – LightKrylov","text":"This module provides some of the most important computational routines provided by LightKrylov . These include: eigs : Compute the leading eigenpairs of a square linear operator . eighs : Compute the leading eigenpairs of a symmetric positive definite \n            operator . svds : Compute the leading singular triplets of a linear operator . gmres : Solve the linear system using the generalized minimum\n            residual method . cg : Solve the linear system where is symmetric\n         positive definite using the Conjugate Gradient method. It also provides abstract interfaces to pass user-defined solvers and preconditioners\nto LightKrylov . Note that these features are still experimental however. Uses stdlib_sorting LightKrylov_AbstractLinops stdlib_stats stdlib_linalg LightKrylov_AbstractVectors stdlib_optval LightKrylov_Constants stdlib_io_npy LightKrylov_utils LightKrylov_BaseKrylov iso_fortran_env LightKrylov_Logger Interfaces public        interface cg Description Given a symmetric (positive definite) matrix , solves the linear system using the Conjugate Gradient method. References Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving\nLinear Systems,\" Journal of Research of the National Bureau of Standards,\n49(6), 409–436. Syntax call cg ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ]) Arguments A : Linear operator derived from one of the abstract_sym_linop or abstract_hermitian_linop types provided by the AbstractLinops module. It is an intent(in) argument. b : Right-hand side vector derived from one the abstract_vector types provided\nby the AbstractVectors module. It needs to have the same type and kind as A .\nIt is an intent(in) argument. x : On entry, initial guess for the solution. On exit, the solution computed by\ncg. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\nan intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional) : Right preconditioner used to solve the system. It needs\nto be consistent with the abstract_preconditioner interface. It is an intent(in) argument. options (optional) : Container for the gmres options given by the cg_opts type.\nIt is an intent(in) argument. Note Although the interface to pass a preconditioner is exposed, it is not currently\nimplemented. public  subroutine cg_rsp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_rdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_csp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_cdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public        interface eighs Description Computes the leading eigenpairs of a symmetric operator using the Lanczos iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectors such that: The subspace is constructed via Lanczos factorization, resulting in a symmetric\ntridiagonal matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem\nof Linear Differential and Integral Operators\". United States Governm. Press Office. Syntax call eighs ( A , X , eigvals , residuals , info [, kdim ] [, tolerance ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. X : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the leading eigenvectors of A . Note that the dimension of X fixes\n      the number of eigenpairs computed. eigvals : Rank-1 array of real numbers. On exit, it contains the leading\n            eigenvalues of A . It is an intent(out) argument. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading eigenpairs. It is an intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional ) : real tolerance below which an eigenpair is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . private  subroutine eighs_rsp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_rdp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_csp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigevectors of . real(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance private  subroutine eighs_cdp(A, X, eigvals, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigevectors of . real(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpairs. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance public        interface eigs Description Computes the leading eigenpairs of a square linear operator using the Arnoldi iterative process. Given a square linear operator , it finds\nthe leading eigvalues and eigvectorss such that: or The subspace is constructed via Arnoldi factorization, resulting in an upper\nHessenberg matrix . The eigenvalues of are approximated by those of and the eigenvectors are computed accordingly. References Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of\n  the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. Syntax call eigs ( A , X , eigvals , residuals , info [, kdim ] [, select ] [, tolerance ] [, transpose ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. X : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the leading eigenvectors of A . Note that the dimension of X fixes\n      the number of eigenpairs computed. eigvals : Rank-1 array of real numbers. On exit, it contains the leading\n            eigenvalues of A . It is an intent(out) argument. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each eigenpairs. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading eigenpairs. It is an intent(in) argument. By default, kdim = 4*size(X) . select ( optional ) : Function to select which eigenvalues to compute. tolerance ( optional ) : real tolerance below which an eigenpair is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . transpose ( optional ) : logical flag determining whether the eigenvalues of or need to be computed. private  subroutine eigs_rsp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rsp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_sp ), optional :: select Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_rdp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_rdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_dp ), optional :: select Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_csp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_csp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=sp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_sp ), optional :: select Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. private  subroutine eigs_cdp(A, X, eigvals, residuals, info, kdim, select, tolerance, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator whose leading eigenpairs need to be computed. class( abstract_vector_cdp ), intent(out) :: X (:) Leading eigenvectors of . complex(kind=dp), intent(out), allocatable :: eigvals (:) Leading eigenvalues of . real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim procedure( eigvals_select_dp ), optional :: select Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. logical, intent(in), optional :: transpose Determine whether or is being used. public        interface gmres Description Solve a square linear system of equations using the Generalized Minimum RESidual (GMRES) method. References Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for\nsolving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical\nComputing, 7(3), 1986. Syntax call gmres ( A , b , x , info [, rtol ] [, atol ] [, preconditioner ] [, options ] [, transpose ]) Arguments A : Linear operator derived from one of the abstract_linop provided by the AbstractLinops module. It is an intent(in) argument. b : Right-hand side vector derived from one the abstract_vector types provided\nby the AbstractVectors module. It needs to have the same type and kind as A .\nIt is an intent(in) argument. x : On entry, initial guess for the solution. On exit, the solution computed by\ngmres. It is a vector derived from one the abstract_vector types provided by the AbstractVectors module. It needs to have the same type and kind as A . It is\nan intent(inout) argument. info : integer information flag. rtol (optional) : real relative tolerance for the solver. atol (optional) : real absolute tolerance for the solver. preconditioner (optional) : Right preconditioner used to solve the system. It needs\nto be consistent with the abstract_preconditioner interface. It is an intent(in) argument. options (optional) : Container for the gmres options given by the gmres_opts type.\nIt is an intent(in) argument. transpose (optional) : logical flag controlling whether or is being solver. public  subroutine gmres_rsp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_rdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_csp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_cdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public        interface save_eigenspectrum Description Utility function to save the eigenspectrum computed from the Arnoldi factorization.\nIt outpost a .npy file. Syntax call save_eigenspectrum ( eigvals , residuals , fname ) Arguments eigvals : complex rank-1 array containing the eigenvalues. residuals : real rank-1 array containing the residuals associated to each\n              eigenvalues. fname : Name of the file to save the eigenspectrum. private  subroutine save_eigenspectrum_sp(eigvals, residuals, fname) Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: eigvals (:) Eigenalues. real(kind=sp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. private  subroutine save_eigenspectrum_dp(eigvals, residuals, fname) Saves the eigenspectrum and corresponding residuals to disk use the npy binary format. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: eigvals (:) Eigenalues. real(kind=dp), intent(in) :: residuals (:) Residual of the corresponding Ritz eigenpairs. character(len=*), intent(in) :: fname Name of the output file. public        interface svds Description Computes the leading singular triplets of an arbitrary linear operator using the Lanczos iterative process. Given a linear operator , it finds\nthe leading singular values and singular vectors such that: The subspaces and are constructed via Lanczos factorization, resulting in\na bidiagonal matrix . The singular values of are approximated by those of and the singular vectors are computed accordingly. References Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and\n Pseudo-Inverse of a Matrix.\" Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos\n bidiagonalization methods.\" R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\"\n Technical Report, 1998. Syntax call svds ( A , U , S , V , residuals , info [, kdim ] [, tolerance ]) Arguments A : Linear operator derived from abstract_sym_linop_rsp , abstract_sym_linop_rdp , abstract_hermitian_linop_csp or abstract_hermitian_linop_cdp whose leading\n      eigenpairs need to be computed. It is an intent(in) argument. U : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the left singular vectors of A . Note that the dimension of U fixes\n      the number of eigenpairs computed. S : Rank-1 array of real numbers. On exit, it contains the leading\n      singular values of A . It is an intent(out) argument. V : Array of abstract_vectors with the same type and kind as A . On exit, it\n      contains the left singular vectors of A . Note that the dimension of U fixes\n      the number of eigenpairs computed. residuals : Rank-1 array of real numbers. On exit, it contains the residuals\n              associated with each singular triplet. It is an intent(out) argument. info : integer Information flag. kdim ( optional ) : integer , maximum dimension of the Krylov subspace used to\n                      approximate the leading singular triplets. It is an intent(in) argument. By default, kdim = 4*size(X) . tolerance ( optional ) : real tolerance below which a triplet is considered as\n                           being converged. It is an intent(in) agument. By default, tolerance = rtol_sp or tolerance = rtol_dp . private  subroutine svds_rsp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rsp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rsp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_rdp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_rdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_rdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_csp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_csp ), intent(out) :: U (:) Leading left singular vectors. real(kind=sp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_csp ), intent(out) :: V (:) Leading right singular vectors. real(kind=sp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=sp), intent(in), optional :: tolerance Tolerance. private  subroutine svds_cdp(A, U, S, V, residuals, info, kdim, tolerance) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator whose leading singular triplets need to be computed. class( abstract_vector_cdp ), intent(out) :: U (:) Leading left singular vectors. real(kind=dp), intent(out), allocatable :: S (:) Leading singular values. class( abstract_vector_cdp ), intent(out) :: V (:) Leading right singular vectors. real(kind=dp), intent(out), allocatable :: residuals (:) Residuals associated to each Ritz eigenpair. integer, intent(out) :: info Information flag. integer, intent(in), optional :: kdim Desired number of eigenpairs. real(kind=dp), intent(in), optional :: tolerance Tolerance. Abstract Interfaces abstract interface public  subroutine abstract_linear_solver_cdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to invert. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. abstract interface public  subroutine abstract_linear_solver_csp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to invert. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. abstract interface public  subroutine abstract_linear_solver_rdp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to invert. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. abstract interface public  subroutine abstract_linear_solver_rsp(A, b, x, info, rtol, atol, preconditioner, options, transpose) Abstract interface to use a user-defined linear solver in LightKrylov . Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to invert. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner. class( abstract_opts ), intent(in), optional :: options Options passed to the linear solver. logical, intent(in), optional :: transpose Determine whether ( .false. ) or ( .true. ) is being used. Derived Types type, public, abstract :: abstract_precond_cdp Type-Bound Procedures procedure(abstract_apply_cdp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_csp Type-Bound Procedures procedure(abstract_apply_csp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_rdp Type-Bound Procedures procedure(abstract_apply_rdp), public, deferred, pass(self) :: apply type, public, abstract :: abstract_precond_rsp Type-Bound Procedures procedure(abstract_apply_rsp), public, deferred, pass(self) :: apply Subroutines public  subroutine cg_cdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_csp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_hermitian_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_rdp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_dp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine cg_rsp (A, b, x, info, rtol, atol, preconditioner, options) Arguments Type Intent Optional Attributes Name class( abstract_sym_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (not yet supported). type( cg_sp_opts ), intent(in), optional :: options Options for the conjugate gradient solver. public  subroutine gmres_cdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_cdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_cdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_cdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_cdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_csp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_csp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_csp ), intent(in) :: b Right-hand side vector. class( abstract_vector_csp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_csp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_rdp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rdp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rdp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rdp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=dp), intent(in), optional :: rtol Relative solver tolerance real(kind=dp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rdp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used. public  subroutine gmres_rsp (A, b, x, info, rtol, atol, preconditioner, options, transpose) Arguments Type Intent Optional Attributes Name class( abstract_linop_rsp ), intent(in) :: A Linear operator to be inverted. class( abstract_vector_rsp ), intent(in) :: b Right-hand side vector. class( abstract_vector_rsp ), intent(inout) :: x Solution vector. integer, intent(out) :: info Information flag. real(kind=sp), intent(in), optional :: rtol Relative solver tolerance real(kind=sp), intent(in), optional :: atol Absolute solver tolerance class( abstract_precond_rsp ), intent(in), optional :: preconditioner Preconditioner (optional). class( abstract_opts ), intent(in), optional :: options GMRES options. logical, intent(in), optional :: transpose Whether or is being used.","tags":"","loc":"module/lightkrylov_iterativesolvers.html"},{"title":"LightKrylov_AbstractVectors – LightKrylov","text":"This module provides the base class absract_vector from which all Krylov vectors\nneeds to be derived. To use LightKrylov , you need to extend one of the\nfollowings: abstract_vector_rsp : Real-valued vector with single precision arithmetic. abstract_vector_rdp : Real-valued vector with double precision arithmetic. abstract_vector_csp : Complex-valued vector with single precision arithmetic. abstract_vector_cdp : Complex-valued vector with double precision arithmetic. To extend either of these abstract types, you need to provide an associated implementation\nfor the following type-bound procedures: zero(self) : A subroutine zeroing-out the vector. rand(self, ifnorm) : A subroutine creating a random vector, possibily normalized to have unit-norm ( ifnorm = .true. ). scal(self, alpha) : A subroutine computing in-place the scalar multiplication . axpby(self, alpha, vec, beta) : A subroutine computing in-place the product . dot(self, vec) : A function computing the inner product . get_size(self) : A function returning the dimension of the vector . Once these type-bound procedures have been implemented by the user, they will automatically \nbe used to define: vector addition add(self, vec) = axpby(self, 1, vec, 1) vector subtraction sub(self, vec) = axpby(self, 1, vec, -1) vector norm norm(self) = sqrt(dot_product(self, self)) . This module also provides the following utility subroutines: innerprod(v, X, y) and innerprod(M, X, Y) : Subroutine to compute the \ninner-product matrix/vector between a Krylov basis X and a Krylov vector \n(resp. basis) y (resp. Y ). linear_combination(y, X, v) and linear_combination(Y, X, B) : Subroutine to \ncompute the linear combination . axpby_basis(X, alpha, Y, beta) : In-place computation of where and are two arrays of abstract_vector s. zero_basis(X) : Zero-out a collection of abstract_vectors . copy(out, from) : Copy a collection of abstract_vectors . rand_basis(X, ifnorm) : Create a collection of random abstract_vectors . If ifnorm = .true. , the vectors are normalized to have unit-norm. Uses stdlib_optval LightKrylov_Constants LightKrylov_utils LightKrylov_Logger Interfaces public        interface axpby_basis In-place addition of two arrays of extended abstract_vector . Description This interface provides methods to add in-place two arrays of\nextended abstract_vector , i.e. No out-of-place alternative is currently available in LightKrylov .\nIf you do need an out-of-place version, you can combine axpby_basis with copy . Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension ( 10 ) :: alpha , beta ! ... Whatever your code is doing ... call axpby_basis ( X , alpha , Y , beta ) ! ... Rest of your code ... private  subroutine axpby_basis_rsp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(sp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . real(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rsp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . real(kind=sp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_rdp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are real(dp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . real(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_rdp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . real(kind=dp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_csp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(sp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . complex(kind=sp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_csp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . complex(kind=sp), intent(in) :: beta Scalar multipliers. private  subroutine axpby_basis_cdp(X, alpha, Y, beta) Compute in-place where X and Y are arrays of abstract_vector and alpha and beta are complex(dp)\nnumbers. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Input/Ouput array of abstract_vector . complex(kind=dp), intent(in) :: alpha Scalar multipliers. class( abstract_vector_cdp ), intent(in) :: Y (:) Array of abstract_vector to be added/subtracted to X . complex(kind=dp), intent(in) :: beta Scalar multipliers. public        interface copy This interface provides methods to copy an array X of abstract_vector into\nanother array Y . Note that Y needs to be pre-allocated. Example type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y ! ... Your code ... call copy ( Y , X ) ! ... Your code ... private  subroutine copy_vector_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out class( abstract_vector_rsp ), intent(in) :: from private  subroutine copy_basis_rsp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out) :: out (:) class( abstract_vector_rsp ), intent(in) :: from (:) private  subroutine copy_vector_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out class( abstract_vector_rdp ), intent(in) :: from private  subroutine copy_basis_rdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out) :: out (:) class( abstract_vector_rdp ), intent(in) :: from (:) private  subroutine copy_vector_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out class( abstract_vector_csp ), intent(in) :: from private  subroutine copy_basis_csp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out) :: out (:) class( abstract_vector_csp ), intent(in) :: from (:) private  subroutine copy_vector_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out class( abstract_vector_cdp ), intent(in) :: from private  subroutine copy_basis_cdp(out, from) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out) :: out (:) class( abstract_vector_cdp ), intent(in) :: from (:) public        interface innerprod Compute the inner product vector or matrix . Description This interface provides methods for computing the inner products between a basis\nof real or complex vectors and a single vector or another basis . Depending on the case, it\nreturns a one-dimensional array or a two-dimensional array with the same type as . Example The example below assumes that you have already extended the abstract_vector_rdp class to define your own my_real_vector type. It then computes the inner product\nvector defined as . type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ) :: y real ( dp ), dimension (:), allocatable :: v ! ... Part of your code where you initialize everything ... call innerprod ( v , X , y ) ! ... Rest of your code ... Similarly, computing the matrix of inner products between two bases can be done\nas shown below. type ( my_real_vector ), dimension ( 10 ) :: X type ( my_real_vector ), dimension ( 10 ) :: Y real ( dp ), dimension (:, :), allocatable :: M ! ... Part of your code where you initialize everything ... call innerprod ( M , X , Y ) ! ... Rest of your code ... private  subroutine innerprod_vector_rsp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_rsp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rsp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_rdp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_rdp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_rdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_csp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_csp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_csp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_csp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_vector_cdp(v, X, y) Computes the inner product vector between\na basis X of abstract_vector and v , a single abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: v (size(X)) Resulting inner-product vector. class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: y Bases of abstract_vector whose inner products need to be computed. private  subroutine innerprod_matrix_cdp(M, X, Y) Computes the inner product matrix between\ntwo bases of abstract_vector . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(out) :: M (size(X),size(Y)) Resulting inner-product matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Bases of abstract_vector whose inner products need to be computed. class( abstract_vector_cdp ), intent(in) :: Y (:) Bases of abstract_vector whose inner products need to be computed. public        interface linear_combination Given a set of extended abstract_vectors and coefficients, return the corresponding\nlinear combinations. Description This interface provides methods for computing linear combinations of a set of extended abstract_vectors . Depending on its input, it either computes i.e. a single vector, or i.e. a set of vectors of the same type as . Example type ( my_real_vector ), dimension ( 10 ) :: X real ( dp ), dimension ( m , n ) :: B type ( my_real_vector ) :: Y ! ... Whatever your code is doing ... call linear_combination ( Y , X , B ) ! ... Rest of your code ... private  subroutine linear_combination_vector_rsp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rsp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rsp ), intent(in) :: X (:) Krylov basis. real(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_rdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_rdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_rdp ), intent(in) :: X (:) Krylov basis. real(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_csp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_csp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_csp ), intent(in) :: X (:) Krylov basis. complex(kind=sp), intent(in) :: B (:,:) Coefficients of the linear combinations. private  subroutine linear_combination_vector_cdp(y, X, v) Given X and v , this function return where y is an abstract_vector , X an array of abstract_vector and v a\nFortran array containing the coefficients of the linear combination. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: y Ouput vector. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: v (:) Coordinates of y in the Krylov basis X . private  subroutine linear_combination_matrix_cdp(Y, X, B) Given X and B , this function computes where X and Y are arrays of abstract_vector , and B is a 2D Fortran array. Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(out), allocatable :: Y (:) Output matrix. class( abstract_vector_cdp ), intent(in) :: X (:) Krylov basis. complex(kind=dp), intent(in) :: B (:,:) Coefficients of the linear combinations. public        interface rand_basis This interface provides methods to create an array X of random abstract_vector .\nIt is a simple wrapper around X(i)%rand(ifnorm) . Example type ( my_real_vector ), dimension ( 10 ) :: X logical :: ifnorm = . true . ! ... Your code ... call rand_basis ( X , ifnorm ) ! ... Your code ... private  subroutine rand_basis_rsp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_rdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_csp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm private  subroutine rand_basis_cdp(X, ifnorm) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) logical, intent(in), optional :: ifnorm public        interface zero_basis This interface provides methods to zero-out a collection of abstract_vector X .\nIt is a simple wrapper around X(i)%zero() . Example type ( my_real_vector ), dimension ( 10 ) :: X ! ... Your code ... call zero_basis ( X ) ! ... Your code ... private  subroutine zero_basis_rsp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rsp ), intent(inout) :: X (:) private  subroutine zero_basis_rdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_rdp ), intent(inout) :: X (:) private  subroutine zero_basis_csp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_csp ), intent(inout) :: X (:) private  subroutine zero_basis_cdp(X) Arguments Type Intent Optional Attributes Name class( abstract_vector_cdp ), intent(inout) :: X (:) Derived Types type, public, abstract :: abstract_vector Base abstract type from which all other types of vectors used in LightKrylov are being derived from. Read more… type, public, abstract, extends( abstract_vector ) :: abstract_vector_cdp Abstract type to define complex(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_cdp ../../ Adds two abstract_vector . procedure(abstract_axpby_cdp), public, deferred, pass(self) :: axpby ../../ In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_cdp procedure(abstract_dot_cdp), public, deferred, pass(self) :: dot ../../ Computes the dot product between two abstract_vector_cdp . procedure(abstract_get_size_cdp), public, deferred, pass(self) :: get_size ../../ Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_cdp ../../ Computes the norm of the abstract_vector . procedure(abstract_rand_cdp), public, deferred, pass(self) :: rand ../../ Creates a random abstract_vector_cdp . procedure(abstract_scal_cdp), public, deferred, pass(self) :: scal ../../ Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_cdp ../../ Subtracts two abstract_vector . procedure(abstract_zero_cdp), public, deferred, pass(self) :: zero ../../ Sets an abstract_vector_cdp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_csp Abstract type to define complex(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_csp ../../ Adds two abstract_vector . procedure(abstract_axpby_csp), public, deferred, pass(self) :: axpby ../../ In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_csp procedure(abstract_dot_csp), public, deferred, pass(self) :: dot ../../ Computes the dot product between two abstract_vector_csp . procedure(abstract_get_size_csp), public, deferred, pass(self) :: get_size ../../ Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_csp ../../ Computes the norm of the abstract_vector . procedure(abstract_rand_csp), public, deferred, pass(self) :: rand ../../ Creates a random abstract_vector_csp . procedure(abstract_scal_csp), public, deferred, pass(self) :: scal ../../ Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_csp ../../ Subtracts two abstract_vector . procedure(abstract_zero_csp), public, deferred, pass(self) :: zero ../../ Sets an abstract_vector_csp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_rdp Abstract type to define real(dp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rdp ../../ Adds two abstract_vector . procedure(abstract_axpby_rdp), public, deferred, pass(self) :: axpby ../../ In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rdp procedure(abstract_dot_rdp), public, deferred, pass(self) :: dot ../../ Computes the dot product between two abstract_vector_rdp . procedure(abstract_get_size_rdp), public, deferred, pass(self) :: get_size ../../ Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rdp ../../ Computes the norm of the abstract_vector . procedure(abstract_rand_rdp), public, deferred, pass(self) :: rand ../../ Creates a random abstract_vector_rdp . procedure(abstract_scal_rdp), public, deferred, pass(self) :: scal ../../ Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rdp ../../ Subtracts two abstract_vector . procedure(abstract_zero_rdp), public, deferred, pass(self) :: zero ../../ Sets an abstract_vector_rdp to zero. type, public, abstract, extends( abstract_vector ) :: abstract_vector_rsp Abstract type to define real(sp)-valued vectors.\nDerived-types defined by the user should be extending one such class. Type-Bound Procedures procedure, public, pass(self) :: add => add_rsp ../../ Adds two abstract_vector . procedure(abstract_axpby_rsp), public, deferred, pass(self) :: axpby ../../ In-place computation of . procedure, public, pass(self) :: chsgn => chsgn_rsp procedure(abstract_dot_rsp), public, deferred, pass(self) :: dot ../../ Computes the dot product between two abstract_vector_rsp . procedure(abstract_get_size_rsp), public, deferred, pass(self) :: get_size ../../ Return size of specific abstract vector procedure, public, pass(self) :: norm => norm_rsp ../../ Computes the norm of the abstract_vector . procedure(abstract_rand_rsp), public, deferred, pass(self) :: rand ../../ Creates a random abstract_vector_rsp . procedure(abstract_scal_rsp), public, deferred, pass(self) :: scal ../../ Compute the scalar-vector product. procedure, public, pass(self) :: sub => sub_rsp ../../ Subtracts two abstract_vector . procedure(abstract_zero_rsp), public, deferred, pass(self) :: zero ../../ Sets an abstract_vector_rsp to zero.","tags":"","loc":"module/lightkrylov_abstractvectors.html"},{"title":"LightKrylov_utils – LightKrylov","text":"This module provides a set of utility functions used throughout LightKrylov .\nIt includes: assert_shape : Assert that the shape of the argument is the expected shape. eig : Compute the eigenvalue decomposition of a general matrix. sqrtm : Compute the non-negative square root of a symmetric positive definite matrix using its SVD. sqrtm_eig : Compute the non-negative square root of a symmetric positive definite matrix using its eigenvalue decomposition. schur : Compute the Schur factorization of a general square matrix. ordschur : Re-order the Schur factorization to have the selected eigenvalues in the upper left block. Note that as the development of stdlib progresses, some of these functions\nwill be deprecated in favor of the stdlib implementations. Uses stdlib_linalg LightKrylov_Constants iso_fortran_env LightKrylov_Logger stdlib_linalg_lapack Interfaces public        interface assert_shape This interface provides methods to assert that the shape of its input vector\nor matrix is the expected shape. It throws an error if not. private  subroutine assert_shape_vector_rsp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_rsp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_rdp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_rdp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_csp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_csp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_vector_cdp(v, size, vecname, module, procedure) Utility function to assert the shape of a vector. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Vector whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of v. character(len=*), intent(in) :: vecname Name of the asserted vector. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. private  subroutine assert_shape_matrix_cdp(A, size, matname, module, procedure) Utility function to assert the shape of a matrix. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix whose dimension need to be asserted. integer, intent(in) :: size (:) Expected dimensions of A. character(len=*), intent(in) :: matname Name of the asserted matrix. character(len=*), intent(in) :: module Name of the module where assertion is done. character(len=*), intent(in) :: procedure Name of the routine where assertion is done. public        interface eig Computes the eigenvalue decomposition of a general square matrix. Description This interface provides methods to compute the solution to the eigenproblem , where $\\mathbf{A}$ is a square real or complex matrix. Result array lambda returns the eigenvalues of , while vecs returns the corresponding eigenvectors. Note that it follows the LAPACK convention\nwhen is real . The solver is based on LAPACK's *GEEV backends. Syntax call eig(A, vecs, lambda) Arguments A : real or complex square array containing the coefficient matrix. It is an intent(in) argument. vecs : Square array of the same size, type, and kind as A containing the eigenvectors\n(following LAPACK's convention for real matrices). It is an intent(out) argument. lambda : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) argument. Note Due to the abstrct nature of the vector types defined in LightKrylov , it is unlikely\nthat this implementation will be superseeded in favor of the stdlib one as the latter\ndoes not follow the LAPACK's convention. private  subroutine eig_rsp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Matrix to be factorized. real(kind=sp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=sp), intent(out) :: vals (:) private  subroutine eig_rdp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Matrix to be factorized. real(kind=dp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=dp), intent(out) :: vals (:) private  subroutine eig_csp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Matrix to be factorized. complex(kind=sp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=sp), intent(out) :: vals (:) private  subroutine eig_cdp(A, vecs, vals) Eigenvalue decomposition of a dense matrix using LAPACK. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Matrix to be factorized. complex(kind=dp), intent(out) :: vecs (:,:) Eigenvectors. complex(kind=dp), intent(out) :: vals (:) public        interface log2 Utility function to compute the base-2 logarithm of a real number. private pure function log2_rsp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) private pure function log2_rdp(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public        interface norml This interface provides methods to compute the infinity norm of a matrix.\nNote that it'll eventually be superseeded by the stdlib implementation. private pure function norml_rsp(A) result(norm) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private pure function norml_rdp(A) result(norm) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private pure function norml_csp(A) result(norm) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private pure function norml_cdp(A) result(norm) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) public        interface ordschur Given the Schur factorization and basis of a matrix, reorders it to have the selected\neigenvalues in the upper left block. Description This interface provides methods to re-order the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Syntax call ordschur(T, Q, selected) Arguments T : real or complex square array containing the Schur factorization of a matrix. \nOn exit, it is overwritten with its re-ordered counterpart. It is an intent(inout) argument. Q : Two-dimensional square array of the same size, type and kind as A . It contains\nthe original Schur basis on entry and the re-ordered one on exit.\nIt is an intent(inout) argument. selected : logical rank-1 array selecting which eigenvalues need to be moved in the\nupper left block of the Schur factorization.\nIt is an intent(in) arguement. private  subroutine ordschur_rsp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. real(kind=sp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_rdp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. real(kind=dp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_csp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. complex(kind=sp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. private  subroutine ordschur_cdp(T, Q, selected) Re-order the Schur factorization from schur such that the selected eigenvalues\nare in the upper-left block. Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: T (:,:) Schur matrix to be re-ordered. complex(kind=dp), intent(inout) :: Q (:,:) Schur vectors to be re-ordered. logical, intent(in) :: selected (:) Boolean array defining the selected eigenvalues. public        interface schur Computes the Schur factorization of a general square matrix. Description This interface provides methods to compute the Schur factorization of a real or complex square matrix. Note that, if is real , it returns the\nreal Schur form. Result array eigvals returns the eigenvalues of while Z contains the Schur basis. Syntax call schur(A, Z, eigvals) Arguments A : real or complex square array containing the coefficient matrix. On exit, it\nis overwritten with its (real) Schur factorization. It is an intent(inout) argument. Z : Two-dimensional square array of the same size, type and kind as A . It contains\nthe Schur basis. It is an intent(out) argument. eigvals : complex rank-1 array of the same kind as A containing the eigenvalues.\nIt is an intent(out) arguement. private  subroutine schur_rsp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: A (:,:) Matrix to be factorized. real(kind=sp), intent(out) :: Z (:,:) Schur basis. complex(kind=sp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_rdp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (:,:) Matrix to be factorized. real(kind=dp), intent(out) :: Z (:,:) Schur basis. complex(kind=dp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_csp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: A (:,:) Matrix to be factorized. complex(kind=sp), intent(out) :: Z (:,:) Schur basis. complex(kind=sp), intent(out) :: eigvals (:) Eigenvalues. private  subroutine schur_cdp(A, Z, eigvals) Compute the Schur form (in-place) and Schur vectors of the matrix A . Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: A (:,:) Matrix to be factorized. complex(kind=dp), intent(out) :: Z (:,:) Schur basis. complex(kind=dp), intent(out) :: eigvals (:) Eigenvalues. public        interface sqrtm Computes the non-negative square root of a symmetric positive definite matrix\nusing its singular value decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. private  subroutine sqrtm_rsp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt real(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_rdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt real(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_csp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt complex(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_cdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: X (:,:) Matrix of which to compute the sqrt complex(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag public        interface sqrtm_eig Computes the non-negative square root of a symmetric positive definite matrix\nusing its eigenvalue decomposition. Description This interface provides methods to compute the non-negative square root of a symmetric\n(hermitian) positive definite matrix . Syntax call sqrtm_eig(A, sqrtmA, info) Arguments A : Symmetric (hermitian) positive definite matrix whose non-negative square root\nneeds to be computed. It is an intent(in) argument. sqrtmA : Non-negative square root of A . It has the same size, kind and type as A .\nIt is an intent(out) argument. info : Information flag. It is an intent(out) argument. private  subroutine sqrtm_eig_rsp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: X (:,:) Matrix of which to compute the sqrt real(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_rdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: X (:,:) Matrix of which to compute the sqrt real(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_csp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: X (:,:) Matrix of which to compute the sqrt complex(kind=sp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag private  subroutine sqrtm_eig_cdp(X, sqrtmX, info) Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: X (:,:) Matrix of which to compute the sqrt complex(kind=dp), intent(out) :: sqrtmX (size(X,1),size(X,1)) Return matrix integer, intent(out) :: info Information flag Derived Types type, public, abstract :: abstract_opts Abstract type container for options from which all others are being extended. type, public, extends( abstract_opts ) :: cg_dp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). type, public, extends( abstract_opts ) :: cg_sp_opts Conjugate gradient options. Components Type Visibility Attributes Name Initial integer, public :: maxiter = 100 Maximum number of cg iterations (default: 100). type, public, extends( abstract_opts ) :: gmres_dp_opts GMRES options. Components Type Visibility Attributes Name Initial integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). type, public, extends( abstract_opts ) :: gmres_sp_opts GMRES options. Components Type Visibility Attributes Name Initial integer, public :: kdim = 30 Dimension of the Krylov subspace (default: 30). integer, public :: maxiter = 10 Maximum number of gmres restarts (default: 10). type, public, extends( abstract_opts ) :: newton_dp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false. type, public, extends( abstract_opts ) :: newton_sp_opts Options for Newton-Krylov fixed-point iteration. Components Type Visibility Attributes Name Initial logical, public :: ifbisect = .false. Bisection toggle to enforce residual reduction (default = .false.) integer, public :: maxiter = 100 Maximum number of Newton iterations (default = 100) integer, public :: maxstep_bisection = 5 Maximum number of bisections (evaluations of F) for step selection (default = 5)\nIgnored if ifbisect = .false.","tags":"","loc":"module/lightkrylov_utils.html"},{"title":"LightKrylov_Constants – LightKrylov","text":"This module defines a list of simple constants used throughout LightKrylov .\nIt also provides some utility functions related to let LightKrylov be aware\nof any MPI-related information (e.g. rank of the current MPI process, dimension\nof the MPI communicator, etc). Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: atol_dp = 10.0_dp**-precision(1.0_dp) Absolute tolerance for double precision computations. real(kind=sp), public, parameter :: atol_sp = 10.0_sp**-precision(1.0_sp) Absolute tolerance for single precision computations. integer, public, parameter :: dp = selected_real_kind(15, 307) Double precision data type. complex(kind=dp), public, parameter :: one_cdp = cmplx(1.0_dp, 0.0_dp, kind=dp) Complex-valued double precision one. complex(kind=sp), public, parameter :: one_csp = cmplx(1.0_sp, 0.0_sp, kind=sp) Complex-valued single precision one. complex(kind=sp), public, parameter :: one_im_cdp = cmplx(0.0_dp, 1.0_dp, kind=dp) Complex-valued double precision imaginary unit. complex(kind=sp), public, parameter :: one_im_csp = cmplx(0.0_sp, 1.0_sp, kind=sp) Complex-valued single precision imaginary unit. real(kind=dp), public, parameter :: one_rdp = 1.0_dp Real-valued double precision one. real(kind=sp), public, parameter :: one_rsp = 1.0_sp Real-valued single precision one. real(kind=dp), public, parameter :: rtol_dp = sqrt(atol_dp) Relative tolerance for double precision computations. real(kind=sp), public, parameter :: rtol_sp = sqrt(atol_sp) Relative tolerance for single precision computations. integer, public, parameter :: sp = selected_real_kind(6, 37) Single precision data type. complex(kind=dp), public, parameter :: zero_cdp = cmplx(0.0_dp, 0.0_dp, kind=dp) Complex-valued double precision zero. complex(kind=sp), public, parameter :: zero_csp = cmplx(0.0_sp, 0.0_sp, kind=sp) Complex-value single precision zero. real(kind=dp), public, parameter :: zero_rdp = 0.0_dp Real-valued double precision zero. real(kind=sp), public, parameter :: zero_rsp = 0.0_sp Real-valued single precision zero. Functions public pure function get_comm_size () result(c_size) Utility function to get the dimension of the communicator known to LightKrylov . Arguments None Return Value integer public pure function get_rank () result(rank) Utility function to get the rank of the current MPI process. Arguments None Return Value integer public pure function io_rank () result(is_io) Utility function to determine whether the current MPI process can do I/O. Arguments None Return Value logical Subroutines public  subroutine set_comm_size (c_size) Utility function to inform LightKrylov of the MPI-communicator's dimension. Arguments Type Intent Optional Attributes Name integer :: c_size Dimension of the MPI communicator. public  subroutine set_io_rank (rk) Utility function to set the rank of the process doing I/O. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rk Desired rank for the IO process. public  subroutine set_rank (rank) Utility function to set the rank of an MPI process. Arguments Type Intent Optional Attributes Name integer :: rank Desired rank identification.","tags":"","loc":"module/lightkrylov_constants.html"},{"title":"LightKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov ! --> Definitions of various constants. use LightKrylov_Constants ! --> Set of utility functions. use LightKrylov_Utils ! --> Definitions of the abstract vector types. use LightKrylov_AbstractVectors ! --> Definitions of the abstract linear operators. use LightKrylov_AbstractLinops ! --> Definitions of the abstract dynamical systems. use LightKrylov_AbstractSystems ! --> Standard Krylov techniques. use LightKrylov_BaseKrylov ! --> Iterative solvers. use LightKrylov_NewtonKrylov ! --> Newton-Krylov fixed-point iteration. use LightKrylov_IterativeSolvers ! --> Expmlib use LightKrylov_Expmlib ! --> TestTypes implicit none private ! LightKrylov exports. public :: greetings ! Constants exports. public :: sp , atol_sp , rtol_sp public :: dp , atol_dp , rtol_dp ! Utils exports. public :: gmres_sp_opts public :: cg_sp_opts public :: newton_sp_opts public :: gmres_dp_opts public :: cg_dp_opts public :: newton_dp_opts ! AbstractVectors exports. public :: abstract_vector public :: abstract_vector_rsp public :: abstract_vector_rdp public :: abstract_vector_csp public :: abstract_vector_cdp public :: innerprod public :: linear_combination public :: axpby_basis public :: zero_basis public :: copy public :: rand_basis ! AbstractLinops exports. public :: abstract_linop public :: abstract_linop_rsp public :: adjoint_linop_rsp public :: Id_rsp public :: scaled_linop_rsp public :: axpby_linop_rsp public :: abstract_sym_linop_rsp public :: abstract_linop_rdp public :: adjoint_linop_rdp public :: Id_rdp public :: scaled_linop_rdp public :: axpby_linop_rdp public :: abstract_sym_linop_rdp public :: abstract_linop_csp public :: adjoint_linop_csp public :: Id_csp public :: scaled_linop_csp public :: axpby_linop_csp public :: abstract_hermitian_linop_csp public :: abstract_linop_cdp public :: adjoint_linop_cdp public :: Id_cdp public :: scaled_linop_cdp public :: axpby_linop_cdp public :: abstract_hermitian_linop_cdp ! AbstractSystems exports. public :: abstract_system_rsp public :: abstract_jacobian_linop_rsp public :: abstract_system_rdp public :: abstract_jacobian_linop_rdp public :: abstract_system_csp public :: abstract_jacobian_linop_csp public :: abstract_system_cdp public :: abstract_jacobian_linop_cdp ! BaseKrylov exports. public :: qr public :: apply_permutation_matrix , apply_inverse_permutation_matrix public :: arnoldi public :: initialize_krylov_subspace public :: orthogonalize_against_basis public :: orthonormalize_basis public :: bidiagonalization public :: lanczos public :: krylov_schur ! IterativeSolvers exports. public :: abstract_precond_rsp public :: abstract_precond_rdp public :: abstract_precond_csp public :: abstract_precond_cdp public :: abstract_linear_solver_rsp public :: abstract_linear_solver_rdp public :: abstract_linear_solver_csp public :: abstract_linear_solver_cdp public :: eigs , eighs , save_eigenspectrum public :: svds public :: gmres public :: gmres_rsp public :: gmres_rdp public :: gmres_csp public :: gmres_cdp public :: cg ! Newton-Krylov exports. public :: newton public :: constant_atol_sp , dynamic_tol_sp public :: constant_atol_dp , dynamic_tol_dp ! ExpmLib exports. public :: abstract_exptA_rsp public :: abstract_exptA_rdp public :: abstract_exptA_csp public :: abstract_exptA_cdp public :: expm public :: kexpm public :: k_exptA contains subroutine greetings () write ( * , * ) write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) \"      _     _       _     _   _  __           _            \" write ( * , * ) \"     | |   (_) __ _| |__ | |_| |/ /_ __ _   _| | _____   __\" write ( * , * ) \"     | |   | |/ _` | '_ \\| __| ' /| '__| | | | |/ _ \\ \\ / /\" write ( * , * ) \"     | |___| | (_| | | | | |_| . \\| |  | |_| | | (_) \\ V / \" write ( * , * ) \"     |_____|_|\\__, |_| |_|\\__|_|\\_\\_|   \\__, |_|\\___/ \\_/  \" write ( * , * ) \"              |___/                     |___/              \" write ( * , * ) write ( * , * ) \"Developed by: Jean-Christophe Loiseau\" write ( * , * ) \"              J. Simon Kern\" write ( * , * ) \"              Arts & Métiers Institute of Technology, 2023.\" write ( * , * ) \"              jean-christophe.loiseau@ensam.eu\" write ( * , * ) write ( * , * ) \"Version -- beta 0.1.0\" write ( * , * ) \"License -- BSD 3-Clause\" write ( * , * ) write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) \"-----------------------------------------------------------------\" write ( * , * ) write ( * , * ) end subroutine greetings end module LightKrylov","tags":"","loc":"sourcefile/lightkrylov.f90.html"},{"title":"BaseKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov_BaseKrylov !!  This module provides a collection of Krylov-based factorizations forming the !!  computational core of `LightKrylov`. It also provides a set of utility functions !!  to operate on arrays of `abstract_vector`. The most important ones are: !! !!  - `arnoldi(A, X, H, info)`: Arnoldi factorization for general square matrices. !!  - `lanczos(A, X, H, info)`: Lanczos factorization for general symmetric/hermitian matrices. !!  - `bidiagonalization(A, U, V, B)`: Lanczos bidiagonalization for arbitrary matrices. !!  - `qr(X, R, perm, info)`: QR factorization (with and without column pivoting) of an array of `abstract_vector`. !-------------------------------------------- !-----     Standard Fortran Library     ----- !-------------------------------------------- use iso_fortran_env use stdlib_optval , only : optval use stdlib_linalg , only : eye !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Constants use LightKrylov_Logger use LightKrylov_Utils use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops implicit none private character ( len = 128 ), parameter :: this_module = 'LightKrylov_BaseKrylov' public :: qr public :: apply_permutation_matrix public :: apply_inverse_permutation_matrix public :: arnoldi public :: initialize_krylov_subspace public :: is_orthonormal public :: orthonormalize_basis public :: orthogonalize_against_basis public :: bidiagonalization public :: lanczos public :: krylov_schur public :: double_gram_schmidt_step public :: eigvals_select_sp public :: eigvals_select_dp interface qr !!  ### Description !! !!  Given an array  X  of types derived from `abstract_vector`, it computes the !!  *in-place* QR factorization of  X , i.e. !! !!   !!      X = QR, !!   !! !!  where  Q  is an orthonormal arrays of vectors such that  Q&#94;H Q = I  and !!   R  is upper triangular. Note that it can also perform the QR factorization !!  with column pivoting !! !!   !!      XP = QR !!   !! !!  where  P  is a permutation matrix ensuring that the diagonal entries of  R  !!  have non-increasing absolute values. This amounts to using the pivoting QR as a !!  rank-revealing factorization. !! !!  **References** !! !!  - G. H. Golub & C. F. Van Loan. \"Matrix Computations\". 4th edition, The John Hopkins !!   University Press, 2013. !!   See Chapter 5.2.8: Modified Gram-Schmidt algorithm. !! !!  ### Syntax !! !!  ```fortran !!      call qr(Q [, R] [, perm], info [, tol]) !!  ``` !! !!  ### Arguments !! !!  `Q`: Array of types derived from one of the base types provided in the !!       `AbstractVectors` module. On entry, it contains the original array. !!       On exit, it is overwritten by the orthogonal basis for its span. !!       It is an `intent(inout)` argument. !! !!  `R`: `real` or `complex` rank-2 array. On exit, its contains the upper triangular !!        matrix resulting from the QR factorization. It is an `intent(out)` argument. !! !!  `perm` (*optional*): Rank-1 array of `integer` corresponding to the indices of !!                       permuted columns. If `perm` is absent, the naive QR factorization !!                       is being computed. !! !!  `info`: `integer` information flag. !! !!  `tol` (*optional*): Numerical tolerance to determine whether two vectors are colinear !!                      or not. Default `tol = atol_sp` or `tol = atol_dp`. module procedure qr_no_pivoting_rsp module procedure qr_with_pivoting_rsp module procedure qr_no_pivoting_rdp module procedure qr_with_pivoting_rdp module procedure qr_no_pivoting_csp module procedure qr_with_pivoting_csp module procedure qr_no_pivoting_cdp module procedure qr_with_pivoting_cdp end interface interface swap_columns module procedure swap_columns_rsp module procedure swap_columns_rdp module procedure swap_columns_csp module procedure swap_columns_cdp end interface interface apply_permutation_matrix !!  ### Description !! !!  Given an array  X  and a permutation vector  p , this function computes !!  *in-place* the column-permuted matrix !! !!   !!      X = X P !!   !! !!  where  P  is the column-permutation matrix constructed from the permutation !!  vector  p . !! !!  ### Syntax !! !!  ```fortran !!      call apply_permutation_matrix(X, perm) !!  ``` !! !!  ### Arguments !! !!  `Q` : Array of vectors derived from the base types defined in the `AbstractVectors` !!       module. On entry, it is the original array. On exit, it contains the !!       column-permuted version computed in-place. It is an `intent(inout)` argument. !! !!  `perm` : Rank-1 array of `integer` corresponding to the desired permutation vector. !!          It is an `intent(in)` argument. module procedure apply_permutation_matrix_rsp module procedure apply_permutation_matrix_array_rsp module procedure apply_permutation_matrix_rdp module procedure apply_permutation_matrix_array_rdp module procedure apply_permutation_matrix_csp module procedure apply_permutation_matrix_array_csp module procedure apply_permutation_matrix_cdp module procedure apply_permutation_matrix_array_cdp end interface interface apply_inverse_permutation_matrix !!  ### Description !! !!  Given an array  X  and a permutation vector  p , this function computes !!  *in-place* the column-permuted matrix !! !!   !!      X = X P&#94;{-1} !!   !! !!  where  P  is the column-permutation matrix constructed from the permutation !!  vector  p  and  P&#94;{-1}  its inverse. !! !!  ### Syntax !! !!  ```fortran !!      call apply_inverse_permutation_matrix(X, perm) !!  ``` !! !!  ### Arguments !! !!  `Q` : Array of vectors derived from the base types defined in the `AbstractVectors` !!       module. On entry, it is the original array. On exit, it contains the !!       column-permuted version computed in-place. It is an `intent(inout)` argument. !! !!  `perm` : Rank-1 array of `integer` corresponding to the desired permutation vector. !!          It is an `intent(in)` argument. module procedure apply_inverse_permutation_matrix_rsp module procedure apply_inverse_permutation_matrix_array_rsp module procedure apply_inverse_permutation_matrix_rdp module procedure apply_inverse_permutation_matrix_array_rdp module procedure apply_inverse_permutation_matrix_csp module procedure apply_inverse_permutation_matrix_array_csp module procedure apply_inverse_permutation_matrix_cdp module procedure apply_inverse_permutation_matrix_array_cdp end interface interface arnoldi !!  ### Description !! !!  Given a square linear operator  A , find matrices  X  and  H  such that !! !!   !!      AX_k = X_k H_k + h_{k+1, k} x_{k+1} e_k&#94;T, !!   !! !!  where  X  is an orthogonal basis and  H  is upper Hessenberg. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  X  via the Gram-Schmidt process. !!  - Constructs an upper Hessenberg matrix  H  whose eigenvalues approximates those of  A . !!  - Checks for convergence and invariant subspaces. !   - Block version available (experimental). !! !!  **References** !! !!  - Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003. !!    see Chapter 6.3: Arnoldi's method. !! !!  ### Syntax !! !!  ```fortran !!      call arnoldi(A, X, H, info [, kstart] [, kend] [, tol] [, transpose] [, blksize]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from one the base types provided by the `AbstractLinops` !!        module. The operator needs to be square, i.e. the dimension of its domain and !!        co-domain is the same. It is an `intent(in)` argument. !! !!  `X` : Array of types derived from one the base types provided by the `AbstractVectors` !!        module. It needs to be consistent with the type of `A`. On exit, it contains the !!        the computed Krylov vectors. The first entry `X(1)` is the starting vector for !!        the Arnoldi factorization. Additionally, the maximum number of Arnoldi steps !!        is equal to `size(X) - 1`. It is an `intent(inout)` argument. !! !!  `H` : `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!         upper Hessenberg matrix computed from the Arnoldi factorization. It is an !!         `intent(inout)` argument. !! !!  `info` : `integer` variable. It is the `LightKrylov` information flag. On exit, if !!           `info` > 0, the Arnoldi factorization experienced a lucky breakdown. !!            The array of Krylov vectors `X` spans an A-invariant subpsace of !!            dimension `info`. !! !!  `kstart` (*optional*): `integer` value determining the index of the first Arnoldi !!                          step to be computed. By default, `kstart = 1`. !! !!  `kend` (*optional*): `integer` value determining the index of the last Arnoldi step !!                        to be computed. By default, `kend = size(X) - 1`. !! !!  `tol` (*optional*): Numerical tolerance below which a subspace is considered !!                      to be  A -invariant. By default `tol = atol_sp` or !!                      `tol = atol_rp` depending on the kind of `A`. !! !!  `transpose` (*optional*): `logical` flag determining whether the Arnoldi factorization !!                             is applied to  A  or  A&#94;H . Default `transpose = .false.` !! !!  `blksize` (*optional*): `integer` value determining the dimension of a block for the !!                          block Arnoldi factorization. Default is `blksize=1`. module procedure arnoldi_rsp module procedure arnoldi_rdp module procedure arnoldi_csp module procedure arnoldi_cdp end interface interface initialize_krylov_subspace !!  ### Description !! !!  Utility function to initialize a basis for a Krylov subspace. !! !!  ### Syntax !! !!  ```fortran !!      call initialize_krylov_subspace(X [, X0]) !!  ``` !! !!  ### Arguments !! !!  `X` : Array of vectors that needs to be initialized. It is an `intent(inout)` !!        argument. Note that the first action in the subroutine is !!        `call zero_basis(X)`, effectively zeroing-out any data stored. !! !!  `X0` (*optional*) : Collection of vectors which will form the first few !!                      Krylov vectors. Note that `X0` need not be an orthonormal !!                      basis as this subroutine includes a `call qr(X0)`. module procedure initialize_krylov_subspace_rsp module procedure initialize_krylov_subspace_rdp module procedure initialize_krylov_subspace_csp module procedure initialize_krylov_subspace_cdp end interface interface is_orthonormal !!  ### Description !! !!  Utility function returning a logical `.true.` if the set of vectors stored in  X  form !!  an orthonormal set of vectors and `.false.` otherwise. !! !!  ### Syntax !! !!  ```fortran !!      out = is_orthonormal(X) !!  ``` !! !!  ### Arguments !! !!  `X` : Array of derived types extended from the base types provided in the !!        `AbstractVectors` module. module procedure is_orthonormal_rsp module procedure is_orthonormal_rdp module procedure is_orthonormal_csp module procedure is_orthonormal_cdp end interface interface orthonormalize_basis !!  ### Description !! !!  Given an array  X  of vectors, it computes an orthonormal basis for its !!  column-span using the `double_gram_schmidt` process. All computations are done !!  in-place. !! !!  ### Syntax !! !!  ```fortran !!      call orthonormalize_basis(X) !!  ``` !! !!  ### Arguments !! !!  `X` : Array of `abstract_vector` to orthonormalize. Note that this process is done !!        in-place. It is an `intent(inout)` argument. module procedure orthonormalize_basis_rsp module procedure orthonormalize_basis_rdp module procedure orthonormalize_basis_csp module procedure orthonormalize_basis_cdp end interface interface orthogonalize_against_basis module procedure orthogonalize_vector_against_basis_rsp module procedure orthogonalize_basis_against_basis_rsp module procedure orthogonalize_vector_against_basis_rdp module procedure orthogonalize_basis_against_basis_rdp module procedure orthogonalize_vector_against_basis_csp module procedure orthogonalize_basis_against_basis_csp module procedure orthogonalize_vector_against_basis_cdp module procedure orthogonalize_basis_against_basis_cdp end interface interface double_gram_schmidt_step !!  ### Description !! !!  Given an array  X  of `abstract_vector` and an `abstract_vector` !!  (or array of `abstract_vectors`)  y , this subroutine returns a modified !!  vector  y  orthogonal to all columns of  X , i.e. !! !!   !!      y \\leftarrow \\left( I - XX&#94;H \\right) y, !!   !! !!  using a double Gram-Schmidt process. On exit,  y  is orthogonal to  X  albeit !!  does not have unit-norm. Note moreover that  X  is assumed to be an orthonormal !!  set of vectors. The function can also return the projection coefficients !!   \\beta = X&#94;H y . !! !!  ### Syntax !! !!  ```fortran !!      call double_gram_schmidt_step(y, X, info [, if_chk_orthonormal] [, beta]) !!  ``` !! !!  ### Arguments !! !!  `y` : `abstract_vector` (or array of `abstract_vector`) that needs to be !!        orthogonalize **in-place** against  X . !! !!  `X` : Array of `abstract_vector` against which  y  needs to be orthogonalized. !!        Note the function assumes that  X  is an orthonormal set of vectors, i.e. !!         X&#94;H X = I . If it this is not the case, the result are meaningless. !! !!  `info` : `integer` Information flag. !! !!  `if_chk_orthonormal` (*optional*) : `logical` flag (default `.true.`) to check !!      whether  X  is an orthonormal set of vectors or not. If the orthonormality !!      returns `.false.`, the function throws an error. Note that this check is however !!      computationally expensive and can be disable for the sake of performances. !! !!  `beta` (*optional*) : `real` or `complex` array containing the coefficients !!       \\beta = X&#94;H y . module procedure DGS_vector_against_basis_rsp module procedure DGS_basis_against_basis_rsp module procedure DGS_vector_against_basis_rdp module procedure DGS_basis_against_basis_rdp module procedure DGS_vector_against_basis_csp module procedure DGS_basis_against_basis_csp module procedure DGS_vector_against_basis_cdp module procedure DGS_basis_against_basis_cdp end interface interface lanczos !!  ### Description !! !!  Given a symmetric or Hermitian linear operator  A , find matrices  X  and !!   T  such that !! !!   !!      AX_k = X_k T_k + t_{k+1, k} x_{k+1} e_k&#94;T, !!   !! !!  where  X  is an orthogonal basis and  T  is symmetric tridiagonal. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  X  via the Lanczos process with full !!    reorthogonalization. !!  - Constructs a symmetric tridiagonal matrix  T  whose eigenvalues approximates those of  A . !!  - Checks for convergence and invariant subspaces. !! !!  **References** !! !!  - Y. Saad. \"Iterative methods for sparse linear systems\", SIAM 2nd edition, 2003. !!    see Chapter 6.6: The symmetric Lanczos algorithm. !! !!  ### Syntax !! !!  ```fortran !!      call lanczos(A, X, T, info [, kstart] [, kend] [, tol]) !!  ``` !! !!  ### Arguments !! !!  `A` : Symmetric or Hermitian linear operator derived from one the base types !!        provided by the `AbstractLinops` module. It is an `intent(in)` argument. !! !!  `X` : Array of types derived from one the base types provided by the `AbstractVectors` !!        module. It needs to be consistent with the type of `A`. On exit, it contains the !!        the computed Krylov vectors. The first entry `X(1)` is the starting vector for !!        the Lanczos factorization. Additionally, the maximum number of Lanczos steps !!        is equal to `size(X) - 1`. It is an `intent(inout)` argument. !! !!  `T` : `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!         symmetric tridiagonal matrix computed from the Arnoldi factorization. It is an !!         `intent(inout)` argument. !! !!  `info` : `integer` variable. It is the `LightKrylov` information flag. On exit, if !!           `info` > 0, the Lanczos factorization experienced a lucky breakdown. !!            The array of Krylov vectors `X` spans an A-invariant subpsace of !!            dimension `info`. !! !!  `kstart` (*optional*): `integer` value determining the index of the first Lanczos !!                          step to be computed. By default, `kstart = 1`. !! !!  `kend` (*optional*): `integer` value determining the index of the last Lanczos step !!                        to be computed. By default, `kend = size(X) - 1`. !! !!  `tol` (*optional*): Numerical tolerance below which a subspace is considered !!                      to be  A -invariant. By default `tol = atol_sp` or !!                      `tol = atol_rp` depending on the kind of `A`. module procedure lanczos_tridiagonalization_rsp module procedure lanczos_tridiagonalization_rdp module procedure lanczos_tridiagonalization_csp module procedure lanczos_tridiagonalization_cdp end interface interface bidiagonalization !!  ### Description !! !!  Given a general linear operator  A , find matrices  U ,  V  and !!   B  such that !! !!   !!      \\begin{aligned} !!          AV_k & = U_{k+1} B_k, \\\\ !!          A&#94;H U_{k+1} & = V_k B_k&#94;T + b_{k+1} v_{k+1} e_{k+1}&#94;T !!      \\end{aligned} !!   !! !!  where  U  and  V  are orthogonal bases for the column span and row span !!  of  A , respectively, and  B  is a bidiagonal matrix. !! !!  **Algorithmic Features** !! !!  - The operator  A  only needs to be accessed through matrix-vector products. !!  - Constructs an orthonormal Krylov basis  U  for the column span of  A . !!  - Constructs an orthonormal Krylov basis  V  for the row span of  A . !!  - Constructs a bidiagonal matrix  B  whose singular values approximates !!    those of  A . !!  - Checks for convergence and invariant subspaces. !! !!  **References** !! !!  - R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" !!    Technical Report, 1998. [(PDF)](http://sun.stanford.edu/~rmunk/PROPACK/paper.pdf) !! !!  ### Syntax !! !!  ```fortran !!      call bidiagonalization(A, U, V, B, info [, kstart] [, kend] [, tol]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from one the base types provided by the !!        `AbstractLinops` module. It is an `intent(in)` argument. !! !!  `U` : Array of types derived from one the base types provided by the `AbstractVectors` !!        module. It needs to be consistent with the type of `A`. On exit, it contains the !!        the computed Krylov vectors for the column span of `A`. The first entry `U(1)` !!        is the starting vector for the Lanczos factorization. Additionally, the !!        maximum number of Lanczos steps is equal to `size(X) - 1`. !!        It is an `intent(inout)` argument. !! !!  `V` : Array of types derived from one the base types provided by the `AbstractVectors` !!        module. It needs to be consistent with the type of `A`. On exit, it contains the !!        the computed Krylov vectors for the row span of `A`. It is an `intent(inout)` !!        argument. !! !!  `B` : `real` or `complex` rank-2 array. On exit, it contains the  (k+1) \\times k !!         bidiagonal matrix computed from the Lanczos factorization. It is an !!         `intent(inout)` argument. !! !!  `info` : `integer` variable. It is the `LightKrylov` information flag. On exit, if !!           `info` > 0, the Lanczos factorization experienced a lucky breakdown. !! !!  `kstart` (*optional*): `integer` value determining the index of the first Lanczos !!                          step to be computed. By default, `kstart = 1`. !! !!  `kend` (*optional*): `integer` value determining the index of the last Lanczos step !!                        to be computed. By default, `kend = size(X) - 1`. !! !!  `tol` (*optional*): Numerical tolerance below which a subspace is considered !!                      to be  A -invariant. By default `tol = atol_sp` or !!                      `tol = atol_rp` depending on the kind of `A`. module procedure lanczos_bidiagonalization_rsp module procedure lanczos_bidiagonalization_rdp module procedure lanczos_bidiagonalization_csp module procedure lanczos_bidiagonalization_cdp end interface interface krylov_schur !!  ### Description !! !!  Given a partial Krylov decomposition !! !!   !!      AX_k = X_k H_k + h_{k+1, k} x_{k+1} e_k&#94;H, !!   !! !!  this subroutine implements the Krylov-Schur restarting strategy proposed by !!  Stewart [1]. !! !!  **References** !! !!  - G. W. Stewart. \"A Krylov-Schur algorithm for large eigenproblems\". !!    SIAM Journal on Matrix Analysis and Applications, vol 23 (3), 2002. !! !!  ### Syntax !! !!  ```fortran !!      call krylov_schur(n, X, H, select_eigs) !!  ``` !! !!  ### Arguments !! !!  `n` : Number of selected eigenvalues moved to the upper left-block of the !!        Schur matrix. It is an `intent(out)` argument. !! !!  `X` : On entry, array of `abstract_vector` computed using the Arnoldi process. !!        On exit, the first `n` columns form an orthonormal basis for the eigenspace !!        associated with eigenvalues moved to the upper left-block of the Schur matrix. !!        It is an `intent(inout)` argument. !! !!  `H` : On entry, `real` of `complex` upper Hessenberg matrix computed using the !!        Arnoldi process. On exit, the leading  n \\times n block contains the !!         S_{11}  block of the re-ordered Schur matrix containing the selected !!        eigenvalues. It is an `intent(inout)` argument. !! !!  `select_eigs` : Procedure to select which eigenvalues to move in the upper-left !!                  block. It is an `intent(inout)` argument. module procedure krylov_schur_rsp module procedure krylov_schur_rdp module procedure krylov_schur_csp module procedure krylov_schur_cdp end interface !---------------------------------------------------------- !-----     ABSTRACT EIGENVALUE SELECTOR INTERFACE     ----- !---------------------------------------------------------- abstract interface function eigvals_select_sp ( lambda ) result ( selected ) import sp complex ( sp ), intent ( in ) :: lambda (:) logical :: selected ( size ( lambda )) end function eigvals_select_sp function eigvals_select_dp ( lambda ) result ( selected ) import dp complex ( dp ), intent ( in ) :: lambda (:) logical :: selected ( size ( lambda )) end function eigvals_select_dp end interface contains !------------------------------------- !-----     UTILITY FUNCTIONS     ----- !------------------------------------- logical function is_orthonormal_rsp ( X ) result ( ortho ) class ( abstract_vector_rsp ), intent ( in ) :: X (:) real ( sp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . call innerprod ( G , X , X ) if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. ortho = . false . end if end function logical function is_orthonormal_rdp ( X ) result ( ortho ) class ( abstract_vector_rdp ), intent ( in ) :: X (:) real ( dp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . call innerprod ( G , X , X ) if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. ortho = . false . end if end function logical function is_orthonormal_csp ( X ) result ( ortho ) class ( abstract_vector_csp ), intent ( in ) :: X (:) complex ( sp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . call innerprod ( G , X , X ) if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. ortho = . false . end if end function logical function is_orthonormal_cdp ( X ) result ( ortho ) class ( abstract_vector_cdp ), intent ( in ) :: X (:) complex ( dp ), dimension ( size ( X ), size ( X )) :: G ortho = . true . call innerprod ( G , X , X ) if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. ortho = . false . end if end function subroutine initialize_krylov_subspace_rsp ( X , X0 ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) class ( abstract_vector_rsp ), optional , intent ( in ) :: X0 (:) ! Internal variables. integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif return end subroutine initialize_krylov_subspace_rsp subroutine orthonormalize_basis_rsp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against ! internals real ( sp ) :: R ( size ( X ), size ( X )) integer :: info ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , module = this_module , procedure = 'orthonormalize_basis_rsp' ) return end subroutine orthonormalize_basis_rsp subroutine orthogonalize_vector_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. class ( abstract_vector_rsp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals real ( sp ) :: proj_coefficients ( size ( X )) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_sp ) info = 1 if ( chk_X_orthonormality ) then block real ( sp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_sp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , y ) block class ( abstract_vector_rsp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_vector_against_basis_rsp' ) beta = proj_coefficients end if return end subroutine orthogonalize_vector_against_basis_rsp subroutine orthogonalize_basis_against_basis_rsp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. class ( abstract_vector_rsp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals real ( sp ) :: proj_coefficients ( size ( X ), size ( Y )) integer :: i info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_sp ) info = i end do if ( chk_X_orthonormality ) then block real ( sp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_sp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , Y ) block class ( abstract_vector_rsp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( Y , one_rsp , proj , - one_rsp ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_basis_against_basis_rsp' ) beta = proj_coefficients end if return end subroutine orthogonalize_basis_against_basis_rsp subroutine DGS_vector_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rsp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals real ( sp ), dimension ( size ( X )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_rsp ; wrk = zero_rsp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , & & procedure = 'DGS_vector_against_basis_rsp, pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , & & procedure = 'DGS_vector_against_basis_rsp, pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_vector_against_basis_rsp' ) beta = proj_coefficients end if end subroutine DGS_vector_against_basis_rsp subroutine DGS_basis_against_basis_rsp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rsp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals real ( sp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_rsp ; wrk = zero_rsp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'DGS_basis_against_basis_rsp, first& & pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , procedure = 'DGS_basis_against_basis_rsp, second& & pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_basis_against_basis_rsp' ) beta = proj_coefficients end if end subroutine DGS_basis_against_basis_rsp subroutine initialize_krylov_subspace_rdp ( X , X0 ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) class ( abstract_vector_rdp ), optional , intent ( in ) :: X0 (:) ! Internal variables. integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif return end subroutine initialize_krylov_subspace_rdp subroutine orthonormalize_basis_rdp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against ! internals real ( dp ) :: R ( size ( X ), size ( X )) integer :: info ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , module = this_module , procedure = 'orthonormalize_basis_rdp' ) return end subroutine orthonormalize_basis_rdp subroutine orthogonalize_vector_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. class ( abstract_vector_rdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals real ( dp ) :: proj_coefficients ( size ( X )) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_dp ) info = 1 if ( chk_X_orthonormality ) then block real ( dp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_dp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_dp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , y ) block class ( abstract_vector_rdp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_vector_against_basis_rdp' ) beta = proj_coefficients end if return end subroutine orthogonalize_vector_against_basis_rdp subroutine orthogonalize_basis_against_basis_rdp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. class ( abstract_vector_rdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals real ( dp ) :: proj_coefficients ( size ( X ), size ( Y )) integer :: i info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_dp ) info = i end do if ( chk_X_orthonormality ) then block real ( dp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_dp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_dp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , Y ) block class ( abstract_vector_rdp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( Y , one_rdp , proj , - one_rdp ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_basis_against_basis_rdp' ) beta = proj_coefficients end if return end subroutine orthogonalize_basis_against_basis_rdp subroutine DGS_vector_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals real ( dp ), dimension ( size ( X )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_rdp ; wrk = zero_rdp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , & & procedure = 'DGS_vector_against_basis_rdp, pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , & & procedure = 'DGS_vector_against_basis_rdp, pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_vector_against_basis_rdp' ) beta = proj_coefficients end if end subroutine DGS_vector_against_basis_rdp subroutine DGS_basis_against_basis_rdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_rdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) real ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals real ( dp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_rdp ; wrk = zero_rdp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'DGS_basis_against_basis_rdp, first& & pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , procedure = 'DGS_basis_against_basis_rdp, second& & pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_basis_against_basis_rdp' ) beta = proj_coefficients end if end subroutine DGS_basis_against_basis_rdp subroutine initialize_krylov_subspace_csp ( X , X0 ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) class ( abstract_vector_csp ), optional , intent ( in ) :: X0 (:) ! Internal variables. integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif return end subroutine initialize_krylov_subspace_csp subroutine orthonormalize_basis_csp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against ! internals complex ( sp ) :: R ( size ( X ), size ( X )) integer :: info ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , module = this_module , procedure = 'orthonormalize_basis_csp' ) return end subroutine orthonormalize_basis_csp subroutine orthogonalize_vector_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. class ( abstract_vector_csp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals complex ( sp ) :: proj_coefficients ( size ( X )) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_sp ) info = 1 if ( chk_X_orthonormality ) then block complex ( sp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_sp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , y ) block class ( abstract_vector_csp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_vector_against_basis_csp' ) beta = proj_coefficients end if return end subroutine orthogonalize_vector_against_basis_csp subroutine orthogonalize_basis_against_basis_csp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. class ( abstract_vector_csp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals complex ( sp ) :: proj_coefficients ( size ( X ), size ( Y )) integer :: i info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_sp ) info = i end do if ( chk_X_orthonormality ) then block complex ( sp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_sp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_sp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , Y ) block class ( abstract_vector_csp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( Y , one_csp , proj , - one_csp ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_basis_against_basis_csp' ) beta = proj_coefficients end if return end subroutine orthogonalize_basis_against_basis_csp subroutine DGS_vector_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_csp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( sp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals complex ( sp ), dimension ( size ( X )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_csp ; wrk = zero_csp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , & & procedure = 'DGS_vector_against_basis_csp, pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , & & procedure = 'DGS_vector_against_basis_csp, pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_vector_against_basis_csp' ) beta = proj_coefficients end if end subroutine DGS_vector_against_basis_csp subroutine DGS_basis_against_basis_csp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_csp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( sp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals complex ( sp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_csp ; wrk = zero_csp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'DGS_basis_against_basis_csp, first& & pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , procedure = 'DGS_basis_against_basis_csp, second& & pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_basis_against_basis_csp' ) beta = proj_coefficients end if end subroutine DGS_basis_against_basis_csp subroutine initialize_krylov_subspace_cdp ( X , X0 ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) class ( abstract_vector_cdp ), optional , intent ( in ) :: X0 (:) ! Internal variables. integer :: p ! Zero-out X. call zero_basis ( X ) ! Deals with optional args. if ( present ( X0 )) then p = size ( X0 ) ! Initialize. call copy ( X (: p ), X0 ) ! Orthonormalize. call orthonormalize_basis ( X (: p )) endif return end subroutine initialize_krylov_subspace_cdp subroutine orthonormalize_basis_cdp ( X ) !! Orthonormalizes the `abstract_vector` basis `X` class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against ! internals complex ( dp ) :: R ( size ( X ), size ( X )) integer :: info ! internals call qr ( X , R , info ) call check_info ( info , 'qr' , module = this_module , procedure = 'orthonormalize_basis_cdp' ) return end subroutine orthonormalize_basis_cdp subroutine orthogonalize_vector_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` `y` against a basis `X` of `abstract_vector`. class ( abstract_vector_cdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals complex ( dp ) :: proj_coefficients ( size ( X )) info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector if ( y % norm () < atol_dp ) info = 1 if ( chk_X_orthonormality ) then block complex ( dp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_dp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_dp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , y ) block class ( abstract_vector_cdp ), allocatable :: proj call linear_combination ( proj , X , proj_coefficients ) call y % sub ( proj ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_vector_against_basis_cdp' ) beta = proj_coefficients end if return end subroutine orthogonalize_vector_against_basis_cdp subroutine orthogonalize_basis_against_basis_cdp ( Y , X , info , if_chk_orthonormal , beta ) !! Orthogonalizes the `abstract_vector` basis `Y` against a basis `X` of `abstract_vector`. class ( abstract_vector_cdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals complex ( dp ) :: proj_coefficients ( size ( X ), size ( Y )) integer :: i info = 0 ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! ! check for zero vector do i = 1 , size ( Y ) if ( Y ( i )% norm () < atol_dp ) info = i end do if ( chk_X_orthonormality ) then block complex ( dp ), dimension ( size ( X ), size ( X )) :: G call innerprod ( G , X , X ) if ( abs ( G ( size ( X ), size ( X ))) < rtol_dp ) then ! The last vector in X is zero, it does not impact orthogonalisation info = - 2 else if ( norm2 ( abs ( G - eye ( size ( X )))) > rtol_dp ) then ! The basis is not orthonormal. Cannot orthonormalize. info = - 1 return end if end block end if ! orthogonalize call innerprod ( proj_coefficients , X , Y ) block class ( abstract_vector_cdp ), allocatable :: proj (:) call linear_combination ( proj , X , proj_coefficients ) call axpby_basis ( Y , one_cdp , proj , - one_cdp ) end block if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'orthogonalize_basis_against_basis_cdp' ) beta = proj_coefficients end if return end subroutine orthogonalize_basis_against_basis_cdp subroutine DGS_vector_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_cdp ), intent ( inout ) :: y !! Input `abstract_vector` to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( dp ), optional , intent ( out ) :: beta (:) !! Projection coefficients if requested ! internals complex ( dp ), dimension ( size ( X )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_cdp ; wrk = zero_cdp ! Orthogonalize vector y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , & & procedure = 'DGS_vector_against_basis_cdp, pass 1' ) ! second pass call orthogonalize_against_basis ( y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , & & procedure = 'DGS_vector_against_basis_cdp, pass 2' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_vector_against_basis_cdp' ) beta = proj_coefficients end if end subroutine DGS_vector_against_basis_cdp subroutine DGS_basis_against_basis_cdp ( y , X , info , if_chk_orthonormal , beta ) !! Computes one step of the double Gram-Schmidt orthogonalization process of the !! `abstract_vector` `y` against the `abstract_vector` basis `X` class ( abstract_vector_cdp ), intent ( inout ) :: Y (:) !! Input `abstract_vector` basis to orthogonalize class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Input `abstract_vector` basis to orthogonalize against integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: if_chk_orthonormal logical :: chk_X_orthonormality !! Check that input Krylov vectors `X` form an orthonormal basis (expensive!) complex ( dp ), optional , intent ( out ) :: beta (:,:) !! Projection coefficients if requested ! internals complex ( dp ), dimension ( size ( X ), size ( Y )) :: proj_coefficients , wrk ! optional input argument chk_X_orthonormality = optval ( if_chk_orthonormal , . true .) ! default to true! info = 0 proj_coefficients = zero_cdp ; wrk = zero_cdp ! Orthogonalize Krylov basis Y w.r.t. to Krylov basis X in two passes of GS. ! first pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = proj_coefficients ) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'DGS_basis_against_basis_cdp, first& & pass' ) ! second pass call orthogonalize_against_basis ( Y , X , info , if_chk_orthonormal = . false ., beta = wrk ) call check_info ( info , 'orthogonalize_against_basis_p2' , module = this_module , procedure = 'DGS_basis_against_basis_cdp, second& & pass' ) ! combine passes proj_coefficients = proj_coefficients + wrk if ( present ( beta )) then ! check size call assert_shape ( beta , shape ( proj_coefficients ), 'beta' , this_module , 'DGS_basis_against_basis_cdp' ) beta = proj_coefficients end if end subroutine DGS_basis_against_basis_cdp !------------------------------------ !-----     QR FACTORIZATION     ----- !------------------------------------ subroutine qr_no_pivoting_rsp ( Q , R , info , tol ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine colinearity. real ( sp ) :: tolerance ! Internal variables. real ( sp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_sp ) info = 0 ; flag = . false .; R = zero_rsp ; beta = zero_rsp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_no_pivoting_rsp' ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call logger % log_information ( msg , module = this_module , procedure = 'qr_no_pivoting_rsp' ) end if R ( j , j ) = zero_rsp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rsp' ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) enddo return end subroutine qr_no_pivoting_rsp subroutine qr_with_pivoting_rsp ( Q , R , perm , info , tol ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol !! Tolerance to detect colinearity. real ( sp ) :: tolerance ! Internal variables real ( sp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) real ( sp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg info = 0 ; kdim = size ( Q ) R = zero_rsp ; Rii = zero_rsp ! Deals with the optional arguments. tolerance = optval ( tol , atol_sp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rsp' ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_rsp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call logger % log_information ( msg , module = this_module , procedure = 'qr_with_pivoting_rsp' ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rsp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rsp' ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( one_rsp , Q ( j ), - beta ) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rsp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step return end subroutine qr_with_pivoting_rsp subroutine swap_columns_rsp ( Q , R , Rii , perm , i , j ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. real ( sp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. real ( sp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. ! Internal variables. class ( abstract_vector_rsp ), allocatable :: Qwrk real ( sp ), allocatable :: Rwrk (:) integer :: iwrk , m , n ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , source = Q ( 1 )) ; call Qwrk % zero () allocate ( Rwrk ( max ( 1 , n ))) ; Rwrk = zero_rsp ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif return end subroutine swap_columns_rsp subroutine apply_permutation_matrix_rsp ( Q , perm ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i class ( abstract_vector_rsp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( perm ( i ))) enddo return end subroutine apply_permutation_matrix_rsp subroutine apply_inverse_permutation_matrix_rsp ( Q , perm ) class ( abstract_vector_rsp ), intent ( inout ) :: Q (:) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) class ( abstract_vector_rsp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( inv_perm ( i ))) enddo return end subroutine apply_inverse_permutation_matrix_rsp subroutine apply_permutation_matrix_array_rsp ( Q , perm ) real ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i real ( sp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, perm ( i )) enddo return end subroutine apply_permutation_matrix_array_rsp subroutine apply_inverse_permutation_matrix_array_rsp ( Q , perm ) real ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) real ( sp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, inv_perm ( i )) enddo return end subroutine apply_inverse_permutation_matrix_array_rsp subroutine qr_no_pivoting_rdp ( Q , R , info , tol ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine colinearity. real ( dp ) :: tolerance ! Internal variables. real ( dp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_dp ) info = 0 ; flag = . false .; R = zero_rdp ; beta = zero_rdp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_no_pivoting_rdp' ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call logger % log_information ( msg , module = this_module , procedure = 'qr_no_pivoting_rdp' ) end if R ( j , j ) = zero_rdp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rdp' ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) enddo return end subroutine qr_no_pivoting_rdp subroutine qr_with_pivoting_rdp ( Q , R , perm , info , tol ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. real ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol !! Tolerance to detect colinearity. real ( dp ) :: tolerance ! Internal variables real ( dp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) real ( dp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg info = 0 ; kdim = size ( Q ) R = zero_rdp ; Rii = zero_rdp ! Deals with the optional arguments. tolerance = optval ( tol , atol_dp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rdp' ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_rdp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call logger % log_information ( msg , module = this_module , procedure = 'qr_with_pivoting_rdp' ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rdp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_rdp' ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( one_rdp , Q ( j ), - beta ) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rdp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step return end subroutine qr_with_pivoting_rdp subroutine swap_columns_rdp ( Q , R , Rii , perm , i , j ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. real ( dp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. real ( dp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. ! Internal variables. class ( abstract_vector_rdp ), allocatable :: Qwrk real ( dp ), allocatable :: Rwrk (:) integer :: iwrk , m , n ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , source = Q ( 1 )) ; call Qwrk % zero () allocate ( Rwrk ( max ( 1 , n ))) ; Rwrk = zero_rdp ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif return end subroutine swap_columns_rdp subroutine apply_permutation_matrix_rdp ( Q , perm ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i class ( abstract_vector_rdp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( perm ( i ))) enddo return end subroutine apply_permutation_matrix_rdp subroutine apply_inverse_permutation_matrix_rdp ( Q , perm ) class ( abstract_vector_rdp ), intent ( inout ) :: Q (:) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) class ( abstract_vector_rdp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( inv_perm ( i ))) enddo return end subroutine apply_inverse_permutation_matrix_rdp subroutine apply_permutation_matrix_array_rdp ( Q , perm ) real ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i real ( dp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, perm ( i )) enddo return end subroutine apply_permutation_matrix_array_rdp subroutine apply_inverse_permutation_matrix_array_rdp ( Q , perm ) real ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) real ( dp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, inv_perm ( i )) enddo return end subroutine apply_inverse_permutation_matrix_array_rdp subroutine qr_no_pivoting_csp ( Q , R , info , tol ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine colinearity. real ( sp ) :: tolerance ! Internal variables. complex ( sp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_sp ) info = 0 ; flag = . false .; R = zero_rsp ; beta = zero_rsp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_no_pivoting_csp' ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call logger % log_information ( msg , module = this_module , procedure = 'qr_no_pivoting_csp' ) end if R ( j , j ) = zero_rsp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_csp' ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) enddo return end subroutine qr_no_pivoting_csp subroutine qr_with_pivoting_csp ( Q , R , perm , info , tol ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( sp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: tol !! Tolerance to detect colinearity. real ( sp ) :: tolerance ! Internal variables complex ( sp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) complex ( sp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg info = 0 ; kdim = size ( Q ) R = zero_rsp ; Rii = zero_rsp ! Deals with the optional arguments. tolerance = optval ( tol , atol_sp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_csp' ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_csp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call logger % log_information ( msg , module = this_module , procedure = 'qr_with_pivoting_csp' ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rsp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_csp' ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rsp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( one_csp , Q ( j ), - beta ) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rsp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step return end subroutine qr_with_pivoting_csp subroutine swap_columns_csp ( Q , R , Rii , perm , i , j ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. complex ( sp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. complex ( sp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. ! Internal variables. class ( abstract_vector_csp ), allocatable :: Qwrk complex ( sp ), allocatable :: Rwrk (:) integer :: iwrk , m , n ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , source = Q ( 1 )) ; call Qwrk % zero () allocate ( Rwrk ( max ( 1 , n ))) ; Rwrk = zero_rsp ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif return end subroutine swap_columns_csp subroutine apply_permutation_matrix_csp ( Q , perm ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i class ( abstract_vector_csp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( perm ( i ))) enddo return end subroutine apply_permutation_matrix_csp subroutine apply_inverse_permutation_matrix_csp ( Q , perm ) class ( abstract_vector_csp ), intent ( inout ) :: Q (:) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) class ( abstract_vector_csp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( inv_perm ( i ))) enddo return end subroutine apply_inverse_permutation_matrix_csp subroutine apply_permutation_matrix_array_csp ( Q , perm ) complex ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i complex ( sp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, perm ( i )) enddo return end subroutine apply_permutation_matrix_array_csp subroutine apply_inverse_permutation_matrix_array_csp ( Q , perm ) complex ( sp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) complex ( sp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, inv_perm ( i )) enddo return end subroutine apply_inverse_permutation_matrix_array_csp subroutine qr_no_pivoting_cdp ( Q , R , info , tol ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix \\mathbf{R} resulting from the QR factorization. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine colinearity. real ( dp ) :: tolerance ! Internal variables. complex ( dp ) :: beta integer :: j logical :: flag character ( len = 128 ) :: msg ! Deals with the optional args. tolerance = optval ( tol , atol_dp ) info = 0 ; flag = . false .; R = zero_rdp ; beta = zero_rdp do j = 1 , size ( Q ) if ( j > 1 ) then ! Double Gram-Schmidt orthogonalization call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false ., beta = R (: j - 1 , j )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_no_pivoting_cdp' ) end if ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then if (. not . flag ) then flag = . true . info = j write ( msg , '(A,I0,A,E15.8)' ) 'Colinear column detected after ' , j , ' steps. beta= ' , abs ( beta ) call logger % log_information ( msg , module = this_module , procedure = 'qr_no_pivoting_cdp' ) end if R ( j , j ) = zero_rdp call Q ( j )% rand () if ( j > 1 ) then call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_cdp' ) end if beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) enddo return end subroutine qr_no_pivoting_cdp subroutine qr_with_pivoting_cdp ( Q , R , perm , info , tol ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Array of `abstract_vector` to be orthogonalized. complex ( dp ), intent ( out ) :: R (:, :) !! Upper triangular matrix resulting from the QR factorization. integer , intent ( out ) :: perm ( size ( Q )) !! Permutation matrix. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: tol !! Tolerance to detect colinearity. real ( dp ) :: tolerance ! Internal variables complex ( dp ) :: beta integer :: idx , i , j , kdim integer :: idxv ( 1 ) complex ( dp ) :: Rii ( size ( Q )) character ( len = 128 ) :: msg info = 0 ; kdim = size ( Q ) R = zero_rdp ; Rii = zero_rdp ! Deals with the optional arguments. tolerance = optval ( tol , atol_dp ) ! Initialize diagonal entries. do i = 1 , kdim perm ( i ) = i Rii ( i ) = Q ( i )% dot ( Q ( i )) enddo qr_step : do j = 1 , kdim idxv = maxloc ( abs ( Rii )) ; idx = idxv ( 1 ) if ( abs ( Rii ( idx )) < tolerance ) then do i = j , kdim call Q ( i )% rand () call double_gram_schmidt_step ( Q ( i ), Q (: i - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_cdp' ) beta = Q ( i )% norm (); call Q ( i )% scal ( one_cdp / beta ) enddo info = j write ( msg , '(A,I0,A,E15.8)' ) 'Breakdown after ' , j , ' steps. R_ii= ' , abs ( Rii ( idx )) call logger % log_information ( msg , module = this_module , procedure = 'qr_with_pivoting_cdp' ) exit qr_step endif call swap_columns ( Q , R , Rii , perm , j , idx ) ! Check for breakdown. beta = Q ( j )% norm () if ( abs ( beta ) < tolerance ) then info = j R ( j , j ) = zero_rdp call Q ( j )% rand () call double_gram_schmidt_step ( Q ( j ), Q (: j - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'qr_with_pivoting_cdp' ) beta = Q ( j )% norm () else R ( j , j ) = beta endif ! Normalize column. call Q ( j )% scal ( one_rdp / beta ) ! Orthogonalize all columns against new vector. do i = j + 1 , kdim beta = Q ( j )% dot ( Q ( i )) call Q ( i )% axpby ( one_cdp , Q ( j ), - beta ) R ( j , i ) = beta enddo ! Update Rii. Rii ( j ) = zero_rdp do i = j + 1 , kdim Rii ( i ) = Rii ( i ) - R ( j , i ) ** 2 enddo enddo qr_step return end subroutine qr_with_pivoting_cdp subroutine swap_columns_cdp ( Q , R , Rii , perm , i , j ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Vector basis whose i-th and j-th columns need swapping. complex ( dp ), intent ( inout ) :: R (:, :) !! Upper triangular matrix resulting from QR. complex ( dp ), intent ( inout ) :: Rii (:) !! Diagonal entries of R. integer , intent ( inout ) :: perm (:) !! Column ordering. integer , intent ( in ) :: i , j !! Index of the columns to be swapped. ! Internal variables. class ( abstract_vector_cdp ), allocatable :: Qwrk complex ( dp ), allocatable :: Rwrk (:) integer :: iwrk , m , n ! Sanity checks. m = size ( Q ) ; n = min ( i , j ) - 1 ! Allocations. allocate ( Qwrk , source = Q ( 1 )) ; call Qwrk % zero () allocate ( Rwrk ( max ( 1 , n ))) ; Rwrk = zero_rdp ! Swap columns. call copy ( Qwrk , Q ( j )) call copy ( Q ( j ), Q ( i )) call copy ( Q ( i ), Qwrk ) Rwrk ( 1 ) = Rii ( j ); Rii ( j ) = Rii ( i ); Rii ( i ) = Rwrk ( 1 ) iwrk = perm ( j ); perm ( j ) = perm ( i ) ; perm ( i ) = iwrk if ( n > 0 ) then Rwrk = R (: n , j ) ; R (: n , j ) = R (: n , i ) ; R (: n , i ) = Rwrk endif return end subroutine swap_columns_cdp subroutine apply_permutation_matrix_cdp ( Q , perm ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i class ( abstract_vector_cdp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( perm ( i ))) enddo return end subroutine apply_permutation_matrix_cdp subroutine apply_inverse_permutation_matrix_cdp ( Q , perm ) class ( abstract_vector_cdp ), intent ( inout ) :: Q (:) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) class ( abstract_vector_cdp ), allocatable :: Qwrk (:) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) call copy ( Q ( i ), Qwrk ( inv_perm ( i ))) enddo return end subroutine apply_inverse_permutation_matrix_cdp subroutine apply_permutation_matrix_array_cdp ( Q , perm ) complex ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i complex ( dp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, perm ( i )) enddo return end subroutine apply_permutation_matrix_array_cdp subroutine apply_inverse_permutation_matrix_array_cdp ( Q , perm ) complex ( dp ), intent ( inout ) :: Q (:, :) !! Basis vectors to be (un-) permuted. integer , intent ( in ) :: perm (:) !! Permutation matrix (vector representation). ! Internal variables. integer :: i integer :: inv_perm ( size ( perm )) complex ( dp ), allocatable :: Qwrk (:, :) allocate ( Qwrk , source = Q ) ; inv_perm = 0 ! Inverse permutation vector. do i = 1 , size ( perm ) inv_perm ( perm ( i )) = i enddo ! Undo permutation. do i = 1 , size ( perm ) Q (:, i ) = Qwrk (:, inv_perm ( i )) enddo return end subroutine apply_inverse_permutation_matrix_array_cdp !----------------------------------------- !-----     ARNOLDI FACTORIZATION     ----- !----------------------------------------- subroutine arnoldi_rsp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. real ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). ! Internal variables. integer :: k_start , k_end , p logical :: trans real ( sp ) :: tolerance real ( sp ) :: beta real ( sp ), allocatable :: res (:) integer , allocatable :: perm (:) integer :: k , i , kdim , kpm , kp , kpp ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; allocate ( res ( p )) ; res = zero_rsp allocate ( perm ( size ( H , 2 ))) ; perm = 0 ; info = 0 ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'arnoldi_rsp' ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , module = this_module , procedure = 'arnoldi_rsp' ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rsp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi return end subroutine arnoldi_rsp subroutine arnoldi_rdp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. real ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). ! Internal variables. integer :: k_start , k_end , p logical :: trans real ( dp ) :: tolerance real ( dp ) :: beta real ( dp ), allocatable :: res (:) integer , allocatable :: perm (:) integer :: k , i , kdim , kpm , kp , kpp ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; allocate ( res ( p )) ; res = zero_rdp allocate ( perm ( size ( H , 2 ))) ; perm = 0 ; info = 0 ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'arnoldi_rdp' ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , module = this_module , procedure = 'arnoldi_rdp' ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rdp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi return end subroutine arnoldi_rdp subroutine arnoldi_csp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. complex ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). ! Internal variables. integer :: k_start , k_end , p logical :: trans real ( sp ) :: tolerance real ( sp ) :: beta complex ( sp ), allocatable :: res (:) integer , allocatable :: perm (:) integer :: k , i , kdim , kpm , kp , kpp ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; allocate ( res ( p )) ; res = zero_rsp allocate ( perm ( size ( H , 2 ))) ; perm = 0 ; info = 0 ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'arnoldi_csp' ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , module = this_module , procedure = 'arnoldi_csp' ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rsp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi return end subroutine arnoldi_csp subroutine arnoldi_cdp ( A , X , H , info , kstart , kend , tol , transpose , blksize ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Orthogonal basis for the generated Krylov subspace. complex ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Arnoldi factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Arnoldi factorization (default `size(X)-1`) logical , optional , intent ( in ) :: transpose !! Whether  \\mathbf{A}  is being transposed or not (default `.false.`) real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether an invariant subspace has been computed or not. integer , optional , intent ( in ) :: blksize !! Block size for block Arnoldi (default 1). ! Internal variables. integer :: k_start , k_end , p logical :: trans real ( dp ) :: tolerance real ( dp ) :: beta complex ( dp ), allocatable :: res (:) integer , allocatable :: perm (:) integer :: k , i , kdim , kpm , kp , kpp ! Deals with optional non-unity blksize and allocations. p = optval ( blksize , 1 ) ; allocate ( res ( p )) ; res = zero_rdp allocate ( perm ( size ( H , 2 ))) ; perm = 0 ; info = 0 ! Check dimensions. kdim = ( size ( X ) - p ) / p ! Deal with the other optional args. k_start = optval ( kstart , 1 ) ; k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) trans = optval ( transpose , . false .) ! Arnoldi factorization. blk_arnoldi : do k = k_start , k_end ! Counters kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Matrix-vector product. if ( trans ) then do i = 1 , p call A % rmatvec ( X ( kpm + i ), X ( kp + i )) enddo else do i = 1 , p call A % matvec ( X ( kpm + i ), X ( kp + i )) enddo endif ! Update Hessenberg matrix via batch double Gram-Schmidt step. call double_gram_schmidt_step ( X ( kp + 1 : kpp ), X (: kp ), info , if_chk_orthonormal = . false ., beta = H (: kp , kpm + 1 : kp )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'arnoldi_cdp' ) ! Orthogonalize current blk vectors. call qr ( X ( kp + 1 : kpp ), H ( kp + 1 : kpp , kpm + 1 : kp ), info ) call check_info ( info , 'qr' , module = this_module , procedure = 'arnoldi_cdp' ) ! Extract residual norm (smallest diagonal element of H matrix). res = zero_rdp do i = 1 , p res ( i ) = H ( kp + i , kpm + i ) enddo beta = minval ( abs ( res )) ! Exit Arnoldi loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = kp ! Exit the Arnoldi iteration. exit blk_arnoldi endif enddo blk_arnoldi return end subroutine arnoldi_cdp !--------------------------------------------- !-----     LANCZOS BIDIAGONALIZATION     ----- !--------------------------------------------- subroutine lanczos_bidiagonalization_rsp ( A , U , V , B , info , kstart , kend , tol ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_rsp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_rsp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. real ( sp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. ! Internal variables. integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: alpha , beta integer :: k , kdim info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_rsp, right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_rsp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_rsp, left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_rsp / beta ) else info = k exit lanczos endif enddo lanczos return end subroutine lanczos_bidiagonalization_rsp subroutine lanczos_bidiagonalization_rdp ( A , U , V , B , info , kstart , kend , tol ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_rdp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_rdp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. real ( dp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. ! Internal variables. integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: alpha , beta integer :: k , kdim info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_rdp, right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_rdp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_rdp, left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_rdp / beta ) else info = k exit lanczos endif enddo lanczos return end subroutine lanczos_bidiagonalization_rdp subroutine lanczos_bidiagonalization_csp ( A , U , V , B , info , kstart , kend , tol ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_csp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_csp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. complex ( sp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( sp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. ! Internal variables. integer :: k_start , k_end real ( sp ) :: tolerance complex ( sp ) :: alpha , beta integer :: k , kdim info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_csp, right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_csp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_csp, left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_csp / beta ) else info = k exit lanczos endif enddo lanczos return end subroutine lanczos_bidiagonalization_csp subroutine lanczos_bidiagonalization_cdp ( A , U , V , B , info , kstart , kend , tol ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be factorized. class ( abstract_vector_cdp ), intent ( inout ) :: U (:) !! Orthonormal basis for the column span of \\mathbf{A}. On entry, `U(1)` needs to be set to !! the starting Krylov vector. class ( abstract_vector_cdp ), intent ( inout ) :: V (:) !! Orthonormal basis for the row span of \\mathbf{A}. complex ( dp ), intent ( inout ) :: B (:, :) !! Bidiagonal matrix. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kstart !! Starting index for the Lanczos factorization (default 1). integer , optional , intent ( in ) :: kend !! Final index for the Lanczos factorization (default 1). real ( dp ), optional , intent ( in ) :: tol !! Tolerance to determine whether invariant subspaces have been computed or not. ! Internal variables. integer :: k_start , k_end real ( dp ) :: tolerance complex ( dp ) :: alpha , beta integer :: k , kdim info = 0 ! Krylov subspace dimension. kdim = size ( U ) - 1 ! Deals with the optional args. k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) ! Lanczos bidiagonalization. lanczos : do k = k_start , k_end ! Transpose matrix-vector product. call A % rmatvec ( U ( k ), V ( k )) ! Full re-orthogonalization of the right Krylov subspace. if ( k > 1 ) then call double_gram_schmidt_step ( V ( k ), V (: k - 1 ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_cdp, right basis' ) end if ! Normalization step. alpha = V ( k )% norm () ; B ( k , k ) = alpha if ( abs ( alpha ) > tolerance ) then call V ( k )% scal ( one_cdp / alpha ) else info = k exit lanczos endif ! Matrix-vector product. call A % matvec ( V ( k ), U ( k + 1 )) ! Full re-orthogonalization of the left Krylov subspace. call double_gram_schmidt_step ( U ( k + 1 ), U (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , & & procedure = 'lanczos_bidiagonalization_cdp, left basis' ) ! Normalization step beta = U ( k + 1 )% norm () ; B ( k + 1 , k ) = beta if ( abs ( beta ) > tolerance ) then call U ( k + 1 )% scal ( one_cdp / beta ) else info = k exit lanczos endif enddo lanczos return end subroutine lanczos_bidiagonalization_cdp !---------------------------------------------- !-----     LANCZOS TRIDIAGONALIZATION     ----- !---------------------------------------------- subroutine lanczos_tridiagonalization_rsp ( A , X , T , info , kstart , kend , tol ) class ( abstract_sym_linop_rsp ), intent ( in ) :: A class ( abstract_vector_rsp ), intent ( inout ) :: X (:) real ( sp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( sp ), optional , intent ( in ) :: tol ! Internal variables. integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: beta integer :: k , kdim ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_rsp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_rsp / beta ) endif enddo lanczos return end subroutine lanczos_tridiagonalization_rsp subroutine update_tridiag_matrix_rsp ( T , X , k ) integer , intent ( in ) :: k real ( sp ), intent ( inout ) :: T (:, :) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( one_rsp , X ( i ), - T ( i , k )) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'update_tridiag_matrix_rsp' ) return end subroutine update_tridiag_matrix_rsp subroutine lanczos_tridiagonalization_rdp ( A , X , T , info , kstart , kend , tol ) class ( abstract_sym_linop_rdp ), intent ( in ) :: A class ( abstract_vector_rdp ), intent ( inout ) :: X (:) real ( dp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( dp ), optional , intent ( in ) :: tol ! Internal variables. integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: beta integer :: k , kdim ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_rdp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_rdp / beta ) endif enddo lanczos return end subroutine lanczos_tridiagonalization_rdp subroutine update_tridiag_matrix_rdp ( T , X , k ) integer , intent ( in ) :: k real ( dp ), intent ( inout ) :: T (:, :) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( one_rdp , X ( i ), - T ( i , k )) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'update_tridiag_matrix_rdp' ) return end subroutine update_tridiag_matrix_rdp subroutine lanczos_tridiagonalization_csp ( A , X , T , info , kstart , kend , tol ) class ( abstract_hermitian_linop_csp ), intent ( in ) :: A class ( abstract_vector_csp ), intent ( inout ) :: X (:) complex ( sp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( sp ), optional , intent ( in ) :: tol ! Internal variables. integer :: k_start , k_end real ( sp ) :: tolerance real ( sp ) :: beta integer :: k , kdim ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_sp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_csp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_csp / beta ) endif enddo lanczos return end subroutine lanczos_tridiagonalization_csp subroutine update_tridiag_matrix_csp ( T , X , k ) integer , intent ( in ) :: k complex ( sp ), intent ( inout ) :: T (:, :) class ( abstract_vector_csp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( one_csp , X ( i ), - T ( i , k )) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'update_tridiag_matrix_csp' ) return end subroutine update_tridiag_matrix_csp subroutine lanczos_tridiagonalization_cdp ( A , X , T , info , kstart , kend , tol ) class ( abstract_hermitian_linop_cdp ), intent ( in ) :: A class ( abstract_vector_cdp ), intent ( inout ) :: X (:) complex ( dp ), intent ( inout ) :: T (:, :) integer , intent ( out ) :: info integer , optional , intent ( in ) :: kstart integer , optional , intent ( in ) :: kend real ( dp ), optional , intent ( in ) :: tol ! Internal variables. integer :: k_start , k_end real ( dp ) :: tolerance real ( dp ) :: beta integer :: k , kdim ! Deal with optional args. kdim = size ( X ) - 1 k_start = optval ( kstart , 1 ) k_end = optval ( kend , kdim ) tolerance = optval ( tol , atol_dp ) info = 0 ! Lanczos tridiagonalization. lanczos : do k = k_start , k_end ! Matrix-vector product. call A % matvec ( X ( k ), X ( k + 1 )) ! Update tridiagonal matrix. call update_tridiag_matrix_cdp ( T , X , k ) beta = X ( k + 1 )% norm () ; T ( k + 1 , k ) = beta ! Exit Lanczos loop if needed. if ( beta < tolerance ) then ! Dimension of the computed invariant subspace. info = k ! Exit the Lanczos iteration. exit lanczos else ! Normalize the new Krylov vector. call X ( k + 1 )% scal ( one_cdp / beta ) endif enddo lanczos return end subroutine lanczos_tridiagonalization_cdp subroutine update_tridiag_matrix_cdp ( T , X , k ) integer , intent ( in ) :: k complex ( dp ), intent ( inout ) :: T (:, :) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) ! Internal variables. integer :: i , info info = 0 ! Orthogonalize residual w.r.t. previously computed Krylov vectors to obtain coefficients in tridiag. matrix do i = max ( 1 , k - 1 ), k T ( i , k ) = X ( i )% dot ( X ( k + 1 )) ; call X ( k + 1 )% axpby ( one_cdp , X ( i ), - T ( i , k )) enddo ! Full re-orthogonalization against existing basis call double_gram_schmidt_step ( X ( k + 1 ), X (: k ), info , if_chk_orthonormal = . false .) call check_info ( info , 'orthogonalize_against_basis_p1' , module = this_module , procedure = 'update_tridiag_matrix_cdp' ) return end subroutine update_tridiag_matrix_cdp !---------------------------------------- !-----     KRYLOV-SCHUR RESTART     ----- !---------------------------------------- subroutine krylov_schur_rsp ( n , X , H , select_eigs ) integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Krylov basis. real ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_sp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- integer :: i , kdim ! Schur-related. real ( sp ) :: Z ( size ( H , 2 ), size ( H , 2 )) complex ( sp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Allocate and initializes variables. eigvals = zero_rsp ; Z = zero_rsp selected = . false . ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), Z , eigvals ) ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block real ( sp ) :: b ( size ( H , 2 )) class ( abstract_vector_rsp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_rsp H (:, n + 1 :) = zero_rsp end block return end subroutine krylov_schur_rsp subroutine krylov_schur_rdp ( n , X , H , select_eigs ) integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Krylov basis. real ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_dp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- integer :: i , kdim ! Schur-related. real ( dp ) :: Z ( size ( H , 2 ), size ( H , 2 )) complex ( dp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Allocate and initializes variables. eigvals = zero_rdp ; Z = zero_rdp selected = . false . ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), Z , eigvals ) ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block real ( dp ) :: b ( size ( H , 2 )) class ( abstract_vector_rdp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_rdp H (:, n + 1 :) = zero_rdp end block return end subroutine krylov_schur_rdp subroutine krylov_schur_csp ( n , X , H , select_eigs ) integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Krylov basis. complex ( sp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_sp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- integer :: i , kdim ! Schur-related. complex ( sp ) :: Z ( size ( H , 2 ), size ( H , 2 )) complex ( sp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Allocate and initializes variables. eigvals = zero_csp ; Z = zero_csp selected = . false . ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), Z , eigvals ) ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block complex ( sp ) :: b ( size ( H , 2 )) class ( abstract_vector_csp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_csp H (:, n + 1 :) = zero_csp end block return end subroutine krylov_schur_csp subroutine krylov_schur_cdp ( n , X , H , select_eigs ) integer , intent ( out ) :: n !! Number eigenvalues that have been moved to the upper !! left block of the Schur factorization of `H`. class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Krylov basis. complex ( dp ), intent ( inout ) :: H (:, :) !! Upper Hessenberg matrix. procedure ( eigvals_select_dp ) :: select_eigs !! Procedure to select the eigenvalues to move in the upper left-block. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- integer :: i , kdim ! Schur-related. complex ( dp ) :: Z ( size ( H , 2 ), size ( H , 2 )) complex ( dp ) :: eigvals ( size ( H , 2 )) logical :: selected ( size ( H , 2 )) ! Krylov subspace dimension. kdim = size ( X ) - 1 ! Allocate and initializes variables. eigvals = zero_cdp ; Z = zero_cdp selected = . false . ! Schur decomposition of the Hessenberg matrix. call schur ( H (: size ( H , 2 ), :), Z , eigvals ) ! Eigenvalue selection of the upper left block. selected = select_eigs ( eigvals ) ; n = count ( selected ) ! Re-order the Schur decomposition and Schur basis. call ordschur ( H (: kdim , :), Z , selected ) ! Update the Hessenberg matrix and Krylov basis. block complex ( dp ) :: b ( size ( H , 2 )) class ( abstract_vector_cdp ), allocatable :: Xwrk (:) ! Update the Krylov basis. call linear_combination ( Xwrk , X (: size ( H , 2 )), Z (:, : n )) call copy ( X (: n ), Xwrk (: n )) call copy ( X ( n + 1 ), X ( kdim + 1 )) call zero_basis ( X ( n + 2 :)) ! Update the Hessenberg matrix. b = matmul ( H ( kdim + 1 , :), Z ) H ( n + 1 , :) = b H ( n + 2 :, :) = zero_cdp H (:, n + 1 :) = zero_cdp end block return end subroutine krylov_schur_cdp end module LightKrylov_BaseKrylov","tags":"","loc":"sourcefile/basekrylov.f90.html"},{"title":"AbstractSystems.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractSystems !!  This module provides the abstract types necessary to define an algebraic system of !!  nonlinear equations to be solved using the Newton method. use LightKrylov_Constants use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops implicit none private character ( len = 128 ), parameter :: this_module = 'LightKrylov_AbstractSystems' ! Base type for abstract systems. type , abstract , public :: abstract_system end type abstract_system !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL real(sp) SYSTEM DEFINITION WITH kind=sp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=sp type , abstract , extends ( abstract_linop_rsp ), public :: abstract_jacobian_linop_rsp !! Abstract type for the local linearization of the system around the state X class ( abstract_vector_rsp ), allocatable :: X !! System state around which the equatons are linearized. contains end type ! Abstract system for kind=sp. type , abstract , extends ( abstract_system ), public :: abstract_system_rsp !! System for Newton fixed-point iteration via the Jacobian class ( abstract_jacobian_linop_rsp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rsp ), pass ( self ), deferred , public :: eval !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . end type abstract interface subroutine abstract_eval_rsp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_rsp , sp class ( abstract_system_rsp ), intent ( in ) :: self !! System class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! State class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Response real ( sp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_rsp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL real(dp) SYSTEM DEFINITION WITH kind=dp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=dp type , abstract , extends ( abstract_linop_rdp ), public :: abstract_jacobian_linop_rdp !! Abstract type for the local linearization of the system around the state X class ( abstract_vector_rdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type ! Abstract system for kind=dp. type , abstract , extends ( abstract_system ), public :: abstract_system_rdp !! System for Newton fixed-point iteration via the Jacobian class ( abstract_jacobian_linop_rdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_rdp ), pass ( self ), deferred , public :: eval !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . end type abstract interface subroutine abstract_eval_rdp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_rdp , dp class ( abstract_system_rdp ), intent ( in ) :: self !! System class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! State class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Response real ( dp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_rdp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL complex(sp) SYSTEM DEFINITION WITH kind=sp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=sp type , abstract , extends ( abstract_linop_csp ), public :: abstract_jacobian_linop_csp !! Abstract type for the local linearization of the system around the state X class ( abstract_vector_csp ), allocatable :: X !! System state around which the equatons are linearized. contains end type ! Abstract system for kind=sp. type , abstract , extends ( abstract_system ), public :: abstract_system_csp !! System for Newton fixed-point iteration via the Jacobian class ( abstract_jacobian_linop_csp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_csp ), pass ( self ), deferred , public :: eval !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . end type abstract interface subroutine abstract_eval_csp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_csp , sp class ( abstract_system_csp ), intent ( in ) :: self !! System class ( abstract_vector_csp ), intent ( in ) :: vec_in !! State class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Response real ( sp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_csp end interface !---------------------------------------------------------------------------- !-----     ABSTRACT GENERAL complex(dp) SYSTEM DEFINITION WITH kind=dp     ----- !---------------------------------------------------------------------------- ! Abstract Jacobian linop for kind=dp type , abstract , extends ( abstract_linop_cdp ), public :: abstract_jacobian_linop_cdp !! Abstract type for the local linearization of the system around the state X class ( abstract_vector_cdp ), allocatable :: X !! System state around which the equatons are linearized. contains end type ! Abstract system for kind=dp. type , abstract , extends ( abstract_system ), public :: abstract_system_cdp !! System for Newton fixed-point iteration via the Jacobian class ( abstract_jacobian_linop_cdp ), allocatable :: jacobian !! System Jacobian  \\left. \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{X}} \\right|_{X&#94;*} . contains private procedure ( abstract_eval_cdp ), pass ( self ), deferred , public :: eval !! Procedure to evaluate the system response  \\mathbf{Y} = \\mathbf{F}(\\mathbf{X}) . end type abstract interface subroutine abstract_eval_cdp ( self , vec_in , vec_out , atol ) !! Interface for the evaluation of the system response. use LightKrylov_AbstractVectors import abstract_system_cdp , dp class ( abstract_system_cdp ), intent ( in ) :: self !! System class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! State class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Response real ( dp ), intent ( in ) :: atol !! Solver tolerance end subroutine abstract_eval_cdp end interface end module LightKrylov_AbstractSystems","tags":"","loc":"sourcefile/abstractsystems.f90.html"},{"title":"ExpmLib.f90 – LightKrylov","text":"Source Code module LightKrylov_ExpmLib !!  This module implements the evaluation of the \"matrix-exponential times vector\" procedure !!  using Krylov methods. ! Iso Fortran. use iso_fortran_env , only : output_unit ! Fortran standard library. use stdlib_optval , only : optval use stdlib_linalg , only : eye , inv ! LightKrylov. use LightKrylov_Constants use LightKrylov_Logger use LightKrylov_Utils use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_BaseKrylov implicit none private character ( len = 128 ), parameter , private :: this_module = 'LightKrylov_ExpmLib' public :: abstract_exptA_rsp public :: abstract_exptA_rdp public :: abstract_exptA_csp public :: abstract_exptA_cdp public :: expm public :: kexpm public :: k_exptA abstract interface subroutine abstract_exptA_rsp ( vec_out , A , vec_in , tau , info , trans ) import sp import abstract_vector_rsp import abstract_linop_rsp !! Abstract interface to define the matrix exponential-vector product. class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Input vector. real ( sp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_rsp subroutine abstract_exptA_rdp ( vec_out , A , vec_in , tau , info , trans ) import dp import abstract_vector_rdp import abstract_linop_rdp !! Abstract interface to define the matrix exponential-vector product. class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Input vector. real ( dp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_rdp subroutine abstract_exptA_csp ( vec_out , A , vec_in , tau , info , trans ) import sp import abstract_vector_csp import abstract_linop_csp !! Abstract interface to define the matrix exponential-vector product. class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Input vector. real ( sp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_csp subroutine abstract_exptA_cdp ( vec_out , A , vec_in , tau , info , trans ) import dp import abstract_vector_cdp import abstract_linop_cdp !! Abstract interface to define the matrix exponential-vector product. class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Input vector. real ( dp ), intent ( in ) :: tau !! Time horizon for integration. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? end subroutine abstract_exptA_cdp end interface interface expm !!  ### Description !! !!  Evaluate the exponential of a dense matrix using Pade approximations. !! !!  ### Syntax !! !!  ```fortran !!      E = expm(A, order) !!  ``` !! !!  ### Arguments !! !!  `E` : `real` or `complex` rank-2 array with  E = \\exp(A) . !! !!  `A` : `real` or `complex` matrix that needs to be exponentiated. !! !!  `order` (optional) : Order of the Pade approximation. By default `order = 10`. module procedure expm_rsp module procedure expm_rdp module procedure expm_csp module procedure expm_cdp end interface interface kexpm !!  ### Description !! !!  This interface provides methods to evaluate the matrix-vector product !!   c = \\exp(\\tau A) b  based on the Arnoldi method. !! !!  ### Syntax !! !!  ```fortran !!      call kexpm(c, A, b, tau, tol, info [, trans] [, kdim]) !!  ``` !! !!  ### Arguments !! !!  `c` : Output vector (or vectors). It is an `intent(out)` argument. !! !!  `A` : Linear operator to be exponentiated. It is an `intent(in)` argument. !! !!  `b` : Vector to be multiplied by  \\exp(\\tau A) . It is an `intent(in)` argument. !! !!  `tau` : `real` (singe or double) time over which the matrix exponential needs to !!          be computed. It is an `intent(in)` argument. !! !!  `info` : `integer` Information flag. !! !!  `trans` (optional) : Whether  A  or  A&#94;H  is being used. !!                      (default `trans=.false.`) !! !!  `kdim` (optional) : Dimension of the Krylov subspace used in the Arnoldi method. module procedure kexpm_vec_rsp module procedure kexpm_mat_rsp module procedure kexpm_vec_rdp module procedure kexpm_mat_rdp module procedure kexpm_vec_csp module procedure kexpm_mat_csp module procedure kexpm_vec_cdp module procedure kexpm_mat_cdp end interface interface k_exptA !!  ### Description !! !!  Utility function to evaluate the matrix-exponential times vector. !! !!  ### Syntax !! !!  ```fortran !!      call k_exptA(vec_out, A, vec_in, tau, info, trans) !!  ``` !! !!  ### Arguments !! !!  `vec_out` : Output vector. !! !!  `A` : Matrix to be exponentiated. !! !!  `vec_in` : Input vector. !! !!  `tau` : Integration time. !! !!  `info` : Information flag. !! !!  `trans` : Whether  A  or  A&#94;H  is being used. module procedure k_exptA_rsp module procedure k_exptA_rdp module procedure k_exptA_csp module procedure k_exptA_cdp end interface contains !-------------------------------------------- !-----     DENSE MATRIX EXPONENTIAL     ----- !-------------------------------------------- function expm_rsp ( A , order ) result ( E ) real ( sp ), intent ( in ) :: A (:, :) !! Matrix to be exponentiated. real ( sp ) :: E ( size ( A , 1 ), size ( A , 1 )) !! Output matrix E = exp(tA). integer , intent ( in ), optional :: order !! Order of the Pade approximation. !----- Internal variables ----- real ( sp ), allocatable :: A2 (:, :), Q (:, :), X (:, :) real ( sp ) :: a_norm , c integer :: n , ee , k , s logical :: p integer :: p_order ! Deal with optional args. p_order = optval ( order , 10 ) n = size ( A , 1 ) ! Allocate arrays. allocate ( A2 ( n , n )) ; allocate ( X ( n , n )) ; allocate ( Q ( n , n )) ! Compute the L-infinity norm. a_norm = norml ( A ) ! Determine scaling factor for the matrix. ee = int ( log2 ( a_norm )) + 1 s = max ( 0 , ee + 1 ) ! Scale the input matrix & initialize polynomial. A2 = A / 2.0_sp ** s X = A2 ! Initialize P & Q and add first step. c = 0.5_sp E = eye ( n ) ; E = E + c * A2 Q = eye ( n ) ; Q = Q - c * A2 ! Iteratively compute the Pade approximation. p = . true . do k = 2 , p_order c = c * ( p_order - k + 1 ) / ( k * ( 2 * p_order - k + 1 )) X = matmul ( A2 , X ) E = E + c * X if ( p ) then Q = Q + c * X else Q = Q - c * X endif p = . not . p enddo E = matmul ( inv ( Q ), E ) do k = 1 , s E = matmul ( E , E ) enddo return end function expm_rsp subroutine kexpm_vec_rsp ( c , A , b , tau , tol , info , trans , kdim ) class ( abstract_vector_rsp ), intent ( out ) :: c !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_rsp ), allocatable :: X (:) real ( sp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. real ( sp ), allocatable :: E (:, :) class ( abstract_vector_rsp ), allocatable :: Xwrk real ( sp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), source = b ) ; allocate ( H ( nk + 1 , nk + 1 )) allocate ( E ( nk + 1 , nk + 1 )) ; allocate ( Xwrk , source = b ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_sp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_sp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_rsp / beta ) H = 0.0_sp expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_sp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_vec_rsp' ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( zero_rsp , Xwrk , one_rsp * beta ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). if ( info == k ) then ! Approximation is exact. err_est = 0.0_sp else err_est = abs ( E ( kp , 1 ) * beta ) endif ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_rsp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_rsp' ) info = - 1 endif return end subroutine kexpm_vec_rsp subroutine kexpm_mat_rsp ( C , A , B , tau , tol , info , trans , kdim ) class ( abstract_vector_rsp ), intent ( out ) :: C (:) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B} . class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_rsp ), allocatable :: X (:) real ( sp ), allocatable :: H (:, :) ! Normalization & temporary arrays. real ( sp ), allocatable :: R (:, :), E (:, :), em (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_rsp ), allocatable :: Xwrk (:), Cwrk (:) real ( sp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p )) ; allocate ( perm ( p )) ; allocate ( ptrans ( p )) allocate ( X ( p * ( nk + 1 )), source = B ( 1 )) ; allocate ( H ( p * ( nk + 1 ), p * ( nk + 1 ))) allocate ( E ( p * ( nk + 1 ), p * ( nk + 1 ))) ; allocate ( em ( p , p )) ! Scratch arrays. allocate ( Xwrk ( p ), source = B ) ; allocate ( Cwrk ( p ), source = B ( 1 )) ! Normalize input matrix and initialize Krylov subspace. R = 0.0_sp call qr ( Xwrk , R , perm , info ) ; call apply_inverse_permutation_matrix ( R , perm ) if ( norm2 ( abs ( R )) == 0.0_sp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_sp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_sp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_sp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_mat_rsp' ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( one_rsp , X ( j ), E ( j , i )) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( one_rsp , Xwrk ( j ), R ( j , i )) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_sp else em = matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )) err_est = norm2 ( abs ( em )) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est . le . tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_rsp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_rsp' ) info = - 1 endif return end subroutine kexpm_mat_rsp subroutine k_exptA_rsp ( vec_out , A , vec_in , tau , info , trans ) class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rsp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , module = this_module , procedure = 'k_exptA_rsp' ) return end subroutine k_exptA_rsp function expm_rdp ( A , order ) result ( E ) real ( dp ), intent ( in ) :: A (:, :) !! Matrix to be exponentiated. real ( dp ) :: E ( size ( A , 1 ), size ( A , 1 )) !! Output matrix E = exp(tA). integer , intent ( in ), optional :: order !! Order of the Pade approximation. !----- Internal variables ----- real ( dp ), allocatable :: A2 (:, :), Q (:, :), X (:, :) real ( dp ) :: a_norm , c integer :: n , ee , k , s logical :: p integer :: p_order ! Deal with optional args. p_order = optval ( order , 10 ) n = size ( A , 1 ) ! Allocate arrays. allocate ( A2 ( n , n )) ; allocate ( X ( n , n )) ; allocate ( Q ( n , n )) ! Compute the L-infinity norm. a_norm = norml ( A ) ! Determine scaling factor for the matrix. ee = int ( log2 ( a_norm )) + 1 s = max ( 0 , ee + 1 ) ! Scale the input matrix & initialize polynomial. A2 = A / 2.0_dp ** s X = A2 ! Initialize P & Q and add first step. c = 0.5_dp E = eye ( n ) ; E = E + c * A2 Q = eye ( n ) ; Q = Q - c * A2 ! Iteratively compute the Pade approximation. p = . true . do k = 2 , p_order c = c * ( p_order - k + 1 ) / ( k * ( 2 * p_order - k + 1 )) X = matmul ( A2 , X ) E = E + c * X if ( p ) then Q = Q + c * X else Q = Q - c * X endif p = . not . p enddo E = matmul ( inv ( Q ), E ) do k = 1 , s E = matmul ( E , E ) enddo return end function expm_rdp subroutine kexpm_vec_rdp ( c , A , b , tau , tol , info , trans , kdim ) class ( abstract_vector_rdp ), intent ( out ) :: c !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_rdp ), allocatable :: X (:) real ( dp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. real ( dp ), allocatable :: E (:, :) class ( abstract_vector_rdp ), allocatable :: Xwrk real ( dp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), source = b ) ; allocate ( H ( nk + 1 , nk + 1 )) allocate ( E ( nk + 1 , nk + 1 )) ; allocate ( Xwrk , source = b ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_dp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_dp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_rdp / beta ) H = 0.0_dp expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_dp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_vec_rdp' ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( zero_rdp , Xwrk , one_rdp * beta ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). if ( info == k ) then ! Approximation is exact. err_est = 0.0_dp else err_est = abs ( E ( kp , 1 ) * beta ) endif ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_rdp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_rdp' ) info = - 1 endif return end subroutine kexpm_vec_rdp subroutine kexpm_mat_rdp ( C , A , B , tau , tol , info , trans , kdim ) class ( abstract_vector_rdp ), intent ( out ) :: C (:) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B} . class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_rdp ), allocatable :: X (:) real ( dp ), allocatable :: H (:, :) ! Normalization & temporary arrays. real ( dp ), allocatable :: R (:, :), E (:, :), em (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_rdp ), allocatable :: Xwrk (:), Cwrk (:) real ( dp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p )) ; allocate ( perm ( p )) ; allocate ( ptrans ( p )) allocate ( X ( p * ( nk + 1 )), source = B ( 1 )) ; allocate ( H ( p * ( nk + 1 ), p * ( nk + 1 ))) allocate ( E ( p * ( nk + 1 ), p * ( nk + 1 ))) ; allocate ( em ( p , p )) ! Scratch arrays. allocate ( Xwrk ( p ), source = B ) ; allocate ( Cwrk ( p ), source = B ( 1 )) ! Normalize input matrix and initialize Krylov subspace. R = 0.0_dp call qr ( Xwrk , R , perm , info ) ; call apply_inverse_permutation_matrix ( R , perm ) if ( norm2 ( abs ( R )) == 0.0_dp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_dp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_dp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_dp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_mat_rdp' ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( one_rdp , X ( j ), E ( j , i )) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( one_rdp , Xwrk ( j ), R ( j , i )) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_dp else em = matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )) err_est = norm2 ( abs ( em )) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est . le . tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_rdp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_rdp' ) info = - 1 endif return end subroutine kexpm_mat_rdp subroutine k_exptA_rdp ( vec_out , A , vec_in , tau , info , trans ) class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_rdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , module = this_module , procedure = 'k_exptA_rdp' ) return end subroutine k_exptA_rdp function expm_csp ( A , order ) result ( E ) complex ( sp ), intent ( in ) :: A (:, :) !! Matrix to be exponentiated. complex ( sp ) :: E ( size ( A , 1 ), size ( A , 1 )) !! Output matrix E = exp(tA). integer , intent ( in ), optional :: order !! Order of the Pade approximation. !----- Internal variables ----- complex ( sp ), allocatable :: A2 (:, :), Q (:, :), X (:, :) real ( sp ) :: a_norm , c integer :: n , ee , k , s logical :: p integer :: p_order ! Deal with optional args. p_order = optval ( order , 10 ) n = size ( A , 1 ) ! Allocate arrays. allocate ( A2 ( n , n )) ; allocate ( X ( n , n )) ; allocate ( Q ( n , n )) ! Compute the L-infinity norm. a_norm = norml ( A ) ! Determine scaling factor for the matrix. ee = int ( log2 ( a_norm )) + 1 s = max ( 0 , ee + 1 ) ! Scale the input matrix & initialize polynomial. A2 = A / 2.0_sp ** s X = A2 ! Initialize P & Q and add first step. c = 0.5_sp E = eye ( n ) ; E = E + c * A2 Q = eye ( n ) ; Q = Q - c * A2 ! Iteratively compute the Pade approximation. p = . true . do k = 2 , p_order c = c * ( p_order - k + 1 ) / ( k * ( 2 * p_order - k + 1 )) X = matmul ( A2 , X ) E = E + c * X if ( p ) then Q = Q + c * X else Q = Q - c * X endif p = . not . p enddo E = matmul ( inv ( Q ), E ) do k = 1 , s E = matmul ( E , E ) enddo return end function expm_csp subroutine kexpm_vec_csp ( c , A , b , tau , tol , info , trans , kdim ) class ( abstract_vector_csp ), intent ( out ) :: c !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_csp ), allocatable :: X (:) complex ( sp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. complex ( sp ), allocatable :: E (:, :) class ( abstract_vector_csp ), allocatable :: Xwrk real ( sp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), source = b ) ; allocate ( H ( nk + 1 , nk + 1 )) allocate ( E ( nk + 1 , nk + 1 )) ; allocate ( Xwrk , source = b ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_sp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_sp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_csp / beta ) H = 0.0_sp expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_sp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_vec_csp' ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( zero_csp , Xwrk , one_csp * beta ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). if ( info == k ) then ! Approximation is exact. err_est = 0.0_sp else err_est = abs ( E ( kp , 1 ) * beta ) endif ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_csp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_csp' ) info = - 1 endif return end subroutine kexpm_vec_csp subroutine kexpm_mat_csp ( C , A , B , tau , tol , info , trans , kdim ) class ( abstract_vector_csp ), intent ( out ) :: C (:) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B} . class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( sp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_csp ), allocatable :: X (:) complex ( sp ), allocatable :: H (:, :) ! Normalization & temporary arrays. complex ( sp ), allocatable :: R (:, :), E (:, :), em (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_csp ), allocatable :: Xwrk (:), Cwrk (:) real ( sp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p )) ; allocate ( perm ( p )) ; allocate ( ptrans ( p )) allocate ( X ( p * ( nk + 1 )), source = B ( 1 )) ; allocate ( H ( p * ( nk + 1 ), p * ( nk + 1 ))) allocate ( E ( p * ( nk + 1 ), p * ( nk + 1 ))) ; allocate ( em ( p , p )) ! Scratch arrays. allocate ( Xwrk ( p ), source = B ) ; allocate ( Cwrk ( p ), source = B ( 1 )) ! Normalize input matrix and initialize Krylov subspace. R = 0.0_sp call qr ( Xwrk , R , perm , info ) ; call apply_inverse_permutation_matrix ( R , perm ) if ( norm2 ( abs ( R )) == 0.0_sp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_sp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_sp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_sp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_mat_csp' ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( one_csp , X ( j ), E ( j , i )) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( one_csp , Xwrk ( j ), R ( j , i )) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_sp else em = matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )) err_est = norm2 ( abs ( em )) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est . le . tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_csp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_csp' ) info = - 1 endif return end subroutine kexpm_mat_csp subroutine k_exptA_csp ( vec_out , A , vec_in , tau , info , trans ) class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_csp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( sp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- real ( sp ) :: tol integer :: kdim tol = atol_sp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , module = this_module , procedure = 'k_exptA_csp' ) return end subroutine k_exptA_csp function expm_cdp ( A , order ) result ( E ) complex ( dp ), intent ( in ) :: A (:, :) !! Matrix to be exponentiated. complex ( dp ) :: E ( size ( A , 1 ), size ( A , 1 )) !! Output matrix E = exp(tA). integer , intent ( in ), optional :: order !! Order of the Pade approximation. !----- Internal variables ----- complex ( dp ), allocatable :: A2 (:, :), Q (:, :), X (:, :) real ( dp ) :: a_norm , c integer :: n , ee , k , s logical :: p integer :: p_order ! Deal with optional args. p_order = optval ( order , 10 ) n = size ( A , 1 ) ! Allocate arrays. allocate ( A2 ( n , n )) ; allocate ( X ( n , n )) ; allocate ( Q ( n , n )) ! Compute the L-infinity norm. a_norm = norml ( A ) ! Determine scaling factor for the matrix. ee = int ( log2 ( a_norm )) + 1 s = max ( 0 , ee + 1 ) ! Scale the input matrix & initialize polynomial. A2 = A / 2.0_dp ** s X = A2 ! Initialize P & Q and add first step. c = 0.5_dp E = eye ( n ) ; E = E + c * A2 Q = eye ( n ) ; Q = Q - c * A2 ! Iteratively compute the Pade approximation. p = . true . do k = 2 , p_order c = c * ( p_order - k + 1 ) / ( k * ( 2 * p_order - k + 1 )) X = matmul ( A2 , X ) E = E + c * X if ( p ) then Q = Q + c * X else Q = Q - c * X endif p = . not . p enddo E = matmul ( inv ( Q ), E ) do k = 1 , s E = matmul ( E , E ) enddo return end function expm_cdp subroutine kexpm_vec_cdp ( c , A , b , tau , tol , info , trans , kdim ) class ( abstract_vector_cdp ), intent ( out ) :: c !! Best approximation of  \\exp(\\tau \\mathbf{A}) \\mathbf{b}  in the computed Krylov subspace class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: b !! Input vector on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution tolerance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: k , km , kp , nk ! Arnoldi factorization. class ( abstract_vector_cdp ), allocatable :: X (:) complex ( dp ), allocatable :: H (:, :) ! Normaliztion & temporary arrays. complex ( dp ), allocatable :: E (:, :) class ( abstract_vector_cdp ), allocatable :: Xwrk real ( dp ) :: err_est , beta ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Deals with optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps info = 0 ! Allocate arrays. allocate ( X ( nk + 1 ), source = b ) ; allocate ( H ( nk + 1 , nk + 1 )) allocate ( E ( nk + 1 , nk + 1 )) ; allocate ( Xwrk , source = b ) ! Normalize input vector and initialize Krylov subspace. beta = b % norm () if ( beta == 0.0_dp ) then ! Input is zero => Output is zero. call c % zero () err_est = 0.0_dp kp = 1 else call zero_basis ( X ) call X ( 1 )% add ( b ) ; call X ( 1 )% scal ( one_cdp / beta ) H = 0.0_dp expm_arnoldi : do k = 1 , nk km = k - 1 ; kp = k + 1 ! Reset work arrays. E = 0.0_dp ! Compute k-th step Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_vec_cdp' ) ! Compute approximation. if ( info == k ) then ! Arnoldi breakdown, do not consider extended matrix. kp = k info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kp , : kp ) = expm ( tau * H (: kp , : kp )) ! Project back into original space. call linear_combination ( Xwrk , X (: kp ), E (: kp , 1 )) call c % axpby ( zero_cdp , Xwrk , one_cdp * beta ) ! Cheap error esimate (this actually is the magnitude of the included correction ! and thus is very conservative). if ( info == k ) then ! Approximation is exact. err_est = 0.0_dp else err_est = abs ( E ( kp , 1 ) * beta ) endif ! Check convergence. if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est <= tol ) then info = kp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_cdp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , nk + 1 , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_vec_cdp' ) info = - 1 endif return end subroutine kexpm_vec_cdp subroutine kexpm_mat_cdp ( C , A , B , tau , tol , info , trans , kdim ) class ( abstract_vector_cdp ), intent ( out ) :: C (:) !! Best Krylov approximation of  \\mathbf{C} = \\exp(\\tau \\mathbf{A}) \\mathbf{B} . class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: B (:) !! Input matrix on which to apply  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. real ( dp ), intent ( in ) :: tol !! Solution toleance based on error estimates. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use transpose ? integer , optional , intent ( in ) :: kdim !! Maximum size of the Krylov subspace. ! ----- Internal variables ----- integer , parameter :: kmax = 100 integer :: i , j , k , p , kpm , kp , kpp , nk ! Block-Arnoldi factorization. class ( abstract_vector_cdp ), allocatable :: X (:) complex ( dp ), allocatable :: H (:, :) ! Normalization & temporary arrays. complex ( dp ), allocatable :: R (:, :), E (:, :), em (:, :) integer , allocatable :: perm (:), ptrans (:) class ( abstract_vector_cdp ), allocatable :: Xwrk (:), Cwrk (:) real ( dp ) :: err_est ! Optional arguments. logical :: transpose integer :: nsteps character ( len = 256 ) :: msg ! Determine block size. p = size ( B ) ! Deals with the optional args. transpose = optval ( trans , . false .) nsteps = optval ( kdim , kmax ) nk = nsteps * p info = 0 ! Allocate arrays. allocate ( R ( p , p )) ; allocate ( perm ( p )) ; allocate ( ptrans ( p )) allocate ( X ( p * ( nk + 1 )), source = B ( 1 )) ; allocate ( H ( p * ( nk + 1 ), p * ( nk + 1 ))) allocate ( E ( p * ( nk + 1 ), p * ( nk + 1 ))) ; allocate ( em ( p , p )) ! Scratch arrays. allocate ( Xwrk ( p ), source = B ) ; allocate ( Cwrk ( p ), source = B ( 1 )) ! Normalize input matrix and initialize Krylov subspace. R = 0.0_dp call qr ( Xwrk , R , perm , info ) ; call apply_inverse_permutation_matrix ( R , perm ) if ( norm2 ( abs ( R )) == 0.0_dp ) then ! Input matrix is zero. call zero_basis ( C ) err_est = 0.0_dp ; k = 0 ; kpp = p else call initialize_krylov_subspace ( X , Xwrk ) ; H = 0.0_dp expm_arnoldi : do k = 1 , nk ! Set counters. kpm = ( k - 1 ) * p ; kp = kpm + p ; kpp = kp + p ! Reset working arrays. E = 0.0_dp ; call zero_basis ( Xwrk ) ! Compute the k-th step of the Arnoldi factorization. call arnoldi ( A , X , H , info , kstart = k , kend = k , transpose = transpose , blksize = p ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'kexpm_mat_cdp' ) if ( info == kp ) then ! Arnoldi breakdown. Do not consider extended matrix. kpp = kp info = - 2 endif ! Compute the (dense) matrix exponential of the extended Hessenberg matrix. E (: kpp , : kpp ) = expm ( tau * H (: kpp , : kpp )) ! Project back to original space. do i = 1 , size ( Xwrk ) call Xwrk ( i )% zero () do j = 1 , kpp call Xwrk ( i )% axpby ( one_cdp , X ( j ), E ( j , i )) enddo enddo do i = 1 , p call C ( i )% zero () do j = 1 , p call C ( i )% axpby ( one_cdp , Xwrk ( j ), R ( j , i )) enddo enddo ! Cheap error estimate. if ( info == kp ) then ! Approximation is exact. err_est = 0.0_dp else em = matmul ( E ( kp + 1 : kpp , : p ), R (: p , : p )) err_est = norm2 ( abs ( em )) endif if ( err_est <= tol ) exit expm_arnoldi enddo expm_arnoldi endif if ( err_est . le . tol ) then info = kpp write ( msg , '(A,I0,2(A,E9.2))' ) 'Converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_cdp' ) else write ( msg , '(A,I0,2(A,E9.2))' ) 'Not converged. kp= ' , kpp , ', err_est= ' , err_est , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'kexpm_mat_cdp' ) info = - 1 endif return end subroutine kexpm_mat_cdp subroutine k_exptA_cdp ( vec_out , A , vec_in , tau , info , trans ) class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Solution vector. class ( abstract_linop_cdp ), intent ( inout ) :: A !! Linear operator to be exponentiated. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Input vector to be multiplied by  \\exp(\\tau \\mathbf{A}) . real ( dp ), intent ( in ) :: tau !! Time horizon for the exponentiation. integer , intent ( out ) :: info !! Information flag. logical , optional , intent ( in ) :: trans !! Use adjoint ? ! ----- Internal variables ----- real ( dp ) :: tol integer :: kdim tol = atol_dp kdim = 30 call kexpm ( vec_out , A , vec_in , tau , tol , info , trans = trans , kdim = kdim ) call check_info ( info , 'kexpm' , module = this_module , procedure = 'k_exptA_cdp' ) return end subroutine k_exptA_cdp end module LightKrylov_expmlib","tags":"","loc":"sourcefile/expmlib.f90.html"},{"title":"NewtonKrylov.f90 – LightKrylov","text":"Source Code module LightKrylov_NewtonKrylov use stdlib_optval , only : optval use LightKrylov_Constants use LightKrylov_Logger use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_AbstractSystems use LightKrylov_IterativeSolvers use LightKrylov_Utils implicit none private character ( len = 128 ), parameter :: this_module = 'LightKrylov_NewtonKrylov' public :: newton public :: constant_atol_sp public :: dynamic_tol_sp public :: constant_atol_dp public :: dynamic_tol_dp interface newton !! Implements the simple Newton-Krylov method for finding roots (fixed points) of a nonlinear vector-valued function !!  F(\\mathbf{X}) , i.e. solutions  \\mathbf{X}&#94;*  such that  F(\\mathbf{X}&#94;*) - \\mathbf{X}&#94;* = \\mathbf{0}  !! starting from an initial guess via successive solution increments based on local linearization  \\mathbf{J}_\\mathbf{X}  !! (the Jacobian) of the nonlinear function in the vicinity of the current solution. !! !! **Algorthmic Features** !! !! - At iteration k, the standard Newton step  \\mathbf{\\delta x}_k is computed as the solution of the linear system !! !!  \\mathbf{J}_\\mathbf{X_k} \\mathbf{\\delta x}_k = \\mathbf{r}_k  !! !!   where  \\mathbf{r}_k = -F(\\mathbf{X}_k)  is the residual of the nonlinear function. The new guess for the fixed !!   point is then given by: !! !!  \\mathbf{X}_{k+1} = \\mathbf{X}_k + \\alpha \\mathbf{\\delta x}_k !! !!   where  \\alpha \\in \\left( 0, 1 \\right]  parametrizes the step length. The standard Newton algorithm sets  \\alpha = 1 . !! !! - The Jacobian is never assembled and the linear system is solved using one of the available iterative solvers. !! - When the residual norm does not decrease during iteration indicating that the linearization is not a very !!   accurate model of the function's behaviour, which often happens during the initial iterations, a 1D step bisection !!   method based on the golden ratio is implemented to dampen the step and improve convergence of the method. !! - The implementation allows for dynamic tolerances (also known as inexact Newton), where the approximation for !!   the residual and the linear system can be solved with relaxed tolerances to reduce overall time to solution. !! - The method is suitable to both fixed points and periodic orbits via the choice of residual and corresponding !!   Jacobian matrix. In the case of unforced periodic orbits, the period is itself an unknown that must be included !!   in the iteration. !! !! **Advantages** !! !! - The iterative solution of the linear systems has a comparatively low storage footprint. !! - If the Newton iteration converges, the convergence is formally asymptotically of second order. Using dynamic !!   tolerances and line searches slightly reduce this convergence rate in exchange for a larger convergence region. !! !! **Limitations** !! !! - The method is not guaranteed to converge if the initial guess is too far from the fixed point. !!   If the Newton iteration diverges even with step bisection, the best suggestion is to find a !!   better initial guess. If this is not feasible, some alternatives to improve the convergence !!   of the Newton iteration are possible (but not implemented to date), including various line search !!   algorithms and trust region methods (doglog, double dogleg, hookstep, ...). !! !! **References** !! !! - Sánchez, J., Net, M., Garcıa-Archilla, B., & Simó, C. (2004). \"Newton–Krylov continuation of periodic orbits !!   for Navier–Stokes flows\". Journal of Computational Physics, 201(1), 13-33. !! - Viswanath, D. (2007). \"Recurrent motions within plane Couette turbulence\". Journal of Fluid Mechanics, 580, 339-358. !! - Duguet, Y., Pringle, C. C. T., Kerswell, R. R. (2008). \"Relative periodic orbits in transitional pipe flow\". Physics !!   of Fluids, 20(11), 114102. !! - Frantz, R. A., Loiseau, J. C., & Robinet, J. C. (2023). \"Krylov methods for large-scale dynamical systems: Application !!   in fluid dynamics\". Applied Mechanics Reviews, 75(3), 030802. module procedure newton_rsp module procedure newton_rdp module procedure newton_csp module procedure newton_cdp end interface abstract interface subroutine abstract_scheduler_sp ( tol , target_tol , rnorm , iter , info ) import sp !! Abstract interface to define a tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag end subroutine abstract_scheduler_sp subroutine abstract_scheduler_dp ( tol , target_tol , rnorm , iter , info ) import dp !! Abstract interface to define a tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag end subroutine abstract_scheduler_dp end interface contains subroutine newton_rsp ( sys , X , solver , info , tolerance , options , linear_solver_options , preconditioner , scheduler ) class ( abstract_system_rsp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_rsp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_rsp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( sp ), optional , intent ( in ) :: tolerance real ( sp ) :: target_tol !! Target absolute solver tolerance type ( newton_sp_opts ), optional , intent ( in ) :: options type ( newton_sp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_sp ), optional :: scheduler !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- procedure ( abstract_scheduler_sp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_rsp ), allocatable :: residual , increment real ( sp ) :: rnorm , tol logical :: converged integer :: i , maxiter , maxstep_bisection character ( len = 256 ) :: msg ! Newton-solver tolerance target_tol = optval ( tolerance , atol_sp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_sp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_atol_sp endif ! Initialisation maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection converged = . false . allocate ( residual , source = X ); call residual % zero () allocate ( increment , source = X ); call increment % zero () call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rsp' ) converged = . true . return end if write ( msg , '(A)' ) 'Starting Newton iteration ...' call logger % log_information ( msg , module = this_module , procedure = 'newton_rsp' ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E9.2))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call logger % log_message ( msg , module = this_module , procedure = 'newton_rsp' ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , module = this_module , procedure = 'newton_rsp' ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_rsp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_sp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call logger % log_message ( msg , module = this_module , procedure = 'newton_rsp' ) converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue iteration.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rsp' ) end if end if end if enddo newton if (. not . converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rsp' ) info = - 1 endif return end subroutine newton_rsp subroutine newton_rdp ( sys , X , solver , info , tolerance , options , linear_solver_options , preconditioner , scheduler ) class ( abstract_system_rdp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_rdp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_rdp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( dp ), optional , intent ( in ) :: tolerance real ( dp ) :: target_tol !! Target absolute solver tolerance type ( newton_dp_opts ), optional , intent ( in ) :: options type ( newton_dp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_dp ), optional :: scheduler !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- procedure ( abstract_scheduler_dp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_rdp ), allocatable :: residual , increment real ( dp ) :: rnorm , tol logical :: converged integer :: i , maxiter , maxstep_bisection character ( len = 256 ) :: msg ! Newton-solver tolerance target_tol = optval ( tolerance , atol_dp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_dp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_atol_dp endif ! Initialisation maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection converged = . false . allocate ( residual , source = X ); call residual % zero () allocate ( increment , source = X ); call increment % zero () call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rdp' ) converged = . true . return end if write ( msg , '(A)' ) 'Starting Newton iteration ...' call logger % log_information ( msg , module = this_module , procedure = 'newton_rdp' ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E9.2))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call logger % log_message ( msg , module = this_module , procedure = 'newton_rdp' ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , module = this_module , procedure = 'newton_rdp' ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_rdp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_dp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call logger % log_message ( msg , module = this_module , procedure = 'newton_rdp' ) converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue iteration.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rdp' ) end if end if end if enddo newton if (. not . converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_rdp' ) info = - 1 endif return end subroutine newton_rdp subroutine newton_csp ( sys , X , solver , info , tolerance , options , linear_solver_options , preconditioner , scheduler ) class ( abstract_system_csp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_csp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_csp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( sp ), optional , intent ( in ) :: tolerance real ( sp ) :: target_tol !! Target absolute solver tolerance type ( newton_sp_opts ), optional , intent ( in ) :: options type ( newton_sp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_sp ), optional :: scheduler !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- procedure ( abstract_scheduler_sp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_csp ), allocatable :: residual , increment real ( sp ) :: rnorm , tol logical :: converged integer :: i , maxiter , maxstep_bisection character ( len = 256 ) :: msg ! Newton-solver tolerance target_tol = optval ( tolerance , atol_sp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_sp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_atol_sp endif ! Initialisation maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection converged = . false . allocate ( residual , source = X ); call residual % zero () allocate ( increment , source = X ); call increment % zero () call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call logger % log_warning ( msg , module = this_module , procedure = 'newton_csp' ) converged = . true . return end if write ( msg , '(A)' ) 'Starting Newton iteration ...' call logger % log_information ( msg , module = this_module , procedure = 'newton_csp' ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E9.2))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call logger % log_message ( msg , module = this_module , procedure = 'newton_csp' ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , module = this_module , procedure = 'newton_csp' ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_csp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_sp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call logger % log_message ( msg , module = this_module , procedure = 'newton_csp' ) converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue iteration.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_csp' ) end if end if end if enddo newton if (. not . converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_csp' ) info = - 1 endif return end subroutine newton_csp subroutine newton_cdp ( sys , X , solver , info , tolerance , options , linear_solver_options , preconditioner , scheduler ) class ( abstract_system_cdp ), intent ( inout ) :: sys !! Dynamical system for which we wish to compute a fixed point class ( abstract_vector_cdp ), intent ( inout ) :: X !! Initial guess for the fixed point, will be overwritten with solution procedure ( abstract_linear_solver_cdp ) :: solver !! Linear solver to be used to find Newton step integer , intent ( out ) :: info !! Information flag real ( dp ), optional , intent ( in ) :: tolerance real ( dp ) :: target_tol !! Target absolute solver tolerance type ( newton_dp_opts ), optional , intent ( in ) :: options type ( newton_dp_opts ) :: opts !! Options for the Newton-Krylov iteration class ( abstract_opts ), optional , intent ( in ) :: linear_solver_options !! Options for the linear solver class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner for the linear solver procedure ( abstract_scheduler_dp ), optional :: scheduler !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- procedure ( abstract_scheduler_dp ), pointer :: tolerance_scheduler => null () class ( abstract_vector_cdp ), allocatable :: residual , increment real ( dp ) :: rnorm , tol logical :: converged integer :: i , maxiter , maxstep_bisection character ( len = 256 ) :: msg ! Newton-solver tolerance target_tol = optval ( tolerance , atol_dp ) ! Newton-Krylov options if ( present ( options )) then opts = options else opts = newton_dp_opts () end if ! Scheduler if ( present ( scheduler )) then tolerance_scheduler => scheduler else tolerance_scheduler => constant_atol_dp endif ! Initialisation maxiter = opts % maxiter maxstep_bisection = opts % maxstep_bisection converged = . false . allocate ( residual , source = X ); call residual % zero () allocate ( increment , source = X ); call increment % zero () call sys % eval ( X , residual , target_tol ) rnorm = residual % norm () ! Check for lucky convergence. if ( rnorm < target_tol ) then write ( msg , '(A)' ) 'Initial guess is a fixed point to tolerance!' call logger % log_warning ( msg , module = this_module , procedure = 'newton_cdp' ) converged = . true . return end if write ( msg , '(A)' ) 'Starting Newton iteration ...' call logger % log_information ( msg , module = this_module , procedure = 'newton_cdp' ) ! Newton iteration newton : do i = 1 , maxiter ! Set dynamic tolerances for Newton iteration and linear solves. call tolerance_scheduler ( tol , target_tol , rnorm , i , info ) write ( msg , \"(A,I0,3(A,E9.2))\" ) 'Start step ' , i , ': rnorm= ' , rnorm , ', tol= ' , tol , ', target= ' , target_tol call logger % log_message ( msg , module = this_module , procedure = 'newton_cdp' ) ! Define the Jacobian sys % jacobian % X = X ! Solve the linear system using GMRES. call residual % chsgn () call solver ( sys % jacobian , residual , increment , info , atol = tol , & & preconditioner = preconditioner , options = linear_solver_options , transpose = . false .) call check_info ( info , 'linear_solver' , module = this_module , procedure = 'newton_cdp' ) ! Update the solution and overwrite X0 if ( opts % ifbisect ) then call increment_bisection_cdp ( X , sys , increment , rnorm , tol , maxstep_bisection ) else call X % add ( increment ) endif ! Evaluate new residual call sys % eval ( X , residual , tol ) rnorm = residual % norm () ! Check for convergence. if ( rnorm < tol ) then if ( tol >= target_tol . and . tol < 10 0.0_dp * target_tol ) then ! the tolerances are not at the target, check the accurate residual call sys % eval ( X , residual , target_tol ) if ( rnorm < target_tol ) then write ( msg , '(A,I0,A)' ) 'Newton iteration converged after ' , i , ' iterations.' call logger % log_message ( msg , module = this_module , procedure = 'newton_cdp' ) converged = . true . exit newton else write ( msg , '(A)' ) 'Dynamic tolerance but not target tolerance reached. Continue iteration.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_cdp' ) end if end if end if enddo newton if (. not . converged ) then write ( msg , '(A,I0,A)' ) 'Newton iteration did not converge within' , maxiter , 'steps.' call logger % log_warning ( msg , module = this_module , procedure = 'newton_cdp' ) info = - 1 endif return end subroutine newton_cdp subroutine increment_bisection_rsp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_rsp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_rsp ), intent ( in ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_rsp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( sp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( sp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals integer :: i , j , idx ( 1 ) real ( sp ) :: invphi , invphi2 real ( sp ) :: alpha ( 4 ), step real ( sp ) :: res ( 4 ) class ( abstract_vector_rsp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , source = X ) allocate ( residual , source = X ); call residual % zero () step = one_rsp invphi = ( sqrt ( 5.0 ) - 1.0 ) / 2.0 ! 1 / phi invphi2 = ( 3.0 - sqrt ( 5.0 )) / 2.0 ! 1 / phi**2 alpha = ( / zero_rsp , invphi2 * one_rsp , invphi * one_rsp , one_rsp / ) res = ( / rold , zero_rsp , zero_rsp , zero_rsp / ) call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rsp' ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rsp' ) end do ! set new vector to optimal step idx = minloc ( res ) write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rsp' ) call copy ( X , Xin ) call X % axpby ( one_rsp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rsp' ) end if return end subroutine subroutine increment_bisection_rdp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_rdp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_rdp ), intent ( in ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_rdp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( dp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( dp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals integer :: i , j , idx ( 1 ) real ( dp ) :: invphi , invphi2 real ( dp ) :: alpha ( 4 ), step real ( dp ) :: res ( 4 ) class ( abstract_vector_rdp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , source = X ) allocate ( residual , source = X ); call residual % zero () step = one_rdp invphi = ( sqrt ( 5.0 ) - 1.0 ) / 2.0 ! 1 / phi invphi2 = ( 3.0 - sqrt ( 5.0 )) / 2.0 ! 1 / phi**2 alpha = ( / zero_rdp , invphi2 * one_rdp , invphi * one_rdp , one_rdp / ) res = ( / rold , zero_rdp , zero_rdp , zero_rdp / ) call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rdp' ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rdp' ) end do ! set new vector to optimal step idx = minloc ( res ) write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rdp' ) call copy ( X , Xin ) call X % axpby ( one_rdp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_rdp' ) end if return end subroutine subroutine increment_bisection_csp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_csp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_csp ), intent ( in ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_csp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( sp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( sp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals integer :: i , j , idx ( 1 ) real ( sp ) :: invphi , invphi2 complex ( sp ) :: alpha ( 4 ), step real ( sp ) :: res ( 4 ) class ( abstract_vector_csp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , source = X ) allocate ( residual , source = X ); call residual % zero () step = one_csp invphi = ( sqrt ( 5.0 ) - 1.0 ) / 2.0 ! 1 / phi invphi2 = ( 3.0 - sqrt ( 5.0 )) / 2.0 ! 1 / phi**2 alpha = ( / zero_csp , invphi2 * one_csp , invphi * one_csp , one_csp / ) res = ( / rold , zero_rsp , zero_rsp , zero_rsp / ) call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_csp' ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_csp' ) end do ! set new vector to optimal step idx = minloc ( res ) write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_csp' ) call copy ( X , Xin ) call X % axpby ( one_csp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_csp' ) end if return end subroutine subroutine increment_bisection_cdp ( X , sys , increment , rold , tol , maxstep ) !! Classic 1D bisection method based on the golden ratio to damped the Newton step in !! order to maximally reduce the residual at each iteration. class ( abstract_vector_cdp ), intent ( inout ) :: X !! Current system state to be updated class ( abstract_system_cdp ), intent ( in ) :: sys !! Dynamical system for which the residual is minimized class ( abstract_vector_cdp ), intent ( in ) :: increment !! Newton step computed from the standard method real ( dp ), intent ( in ) :: rold !! Residual of the current system state to determine improvement real ( dp ), intent ( in ) :: tol integer , intent ( in ) :: maxstep !! Maximum number of bisection steps. Each additional bisection step requires an evaluation of the nonlinear function ! internals integer :: i , j , idx ( 1 ) real ( dp ) :: invphi , invphi2 complex ( dp ) :: alpha ( 4 ), step real ( dp ) :: res ( 4 ) class ( abstract_vector_cdp ), allocatable :: Xin , residual character ( len = 256 ) :: msg allocate ( Xin , source = X ) allocate ( residual , source = X ); call residual % zero () step = one_cdp invphi = ( sqrt ( 5.0 ) - 1.0 ) / 2.0 ! 1 / phi invphi2 = ( 3.0 - sqrt ( 5.0 )) / 2.0 ! 1 / phi**2 alpha = ( / zero_cdp , invphi2 * one_cdp , invphi * one_cdp , one_cdp / ) res = ( / rold , zero_rdp , zero_rdp , zero_rdp / ) call X % add ( increment ) ! evaluate residual norm call sys % eval ( X , residual , tol ) res ( 4 ) = residual % norm () if ( res ( 4 ) > rold ) then write ( msg , '(A)' ) 'Start Newton step bisection ... ' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_cdp' ) ! compute new trial solutions do j = 2 , 3 call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( j )) call sys % eval ( X , residual , tol ) res ( j ) = residual % norm () end do do i = 1 , maxstep step = step * invphi if ( res ( 2 ) < res ( 3 )) then ! alphas ! a1 is kept alpha ( 3 : 4 ) = alpha ( 2 : 3 ) ! residuals ! r1 is kept res ( 3 : 4 ) = res ( 2 : 3 ) ! new point --> a2, r2 alpha ( 2 ) = alpha ( 1 ) + step * invphi2 call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( 2 )) call sys % eval ( X , residual , tol ) res ( 2 ) = residual % norm () else ! alphas alpha ( 1 : 2 ) = alpha ( 2 : 3 ) ! a4 is kept ! residuals res ( 1 : 2 ) = res ( 2 : 3 ) ! r4 is kept ! new point --> a3, r3 alpha ( 3 ) = alpha ( 1 ) + step * invphi call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( 3 )) call sys % eval ( X , residual , tol ) res ( 3 ) = residual % norm () end if write ( msg , '(4X,I0,2(A,F6.4))' ) i , ': New interval: ' , alpha ( 1 ), ' <= alpha <= ' , alpha ( 4 ) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_cdp' ) end do ! set new vector to optimal step idx = minloc ( res ) write ( msg , '(A,F6.4)' ) 'Optimal damping: alpha= ' , alpha ( idx ( 1 )) call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_cdp' ) call copy ( X , Xin ) call X % axpby ( one_cdp , increment , alpha ( idx ( 1 ))) else write ( msg , '(A)' ) 'Full Newton step reduces the residual. Skip bisection.' call logger % log_information ( msg , module = this_module , procedure = 'increment_bisection_cdp' ) end if return end subroutine !-------------------------------------------------------------------- !-----     Definition of two basic tolerance schedulers (sp)    ----- !-------------------------------------------------------------------- subroutine constant_atol_sp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag character ( len = 256 ) :: msg tol = target_tol write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'constant_atol_sp' ) return end subroutine constant_atol_sp subroutine dynamic_tol_sp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( sp ), intent ( out ) :: tol !! Tolerance to be used real ( sp ), intent ( in ) :: target_tol !! Target tolerance real ( sp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals real ( sp ) :: tol_old character ( len = 256 ) :: msg tol_old = tol tol = max ( 0.1 * rnorm , target_tol ) if ( tol /= tol_old ) then if ( tol == target_tol ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call logger % log_information ( msg , module = this_module , procedure = 'dynamic_tol_sp' ) end if return end subroutine dynamic_tol_sp !-------------------------------------------------------------------- !-----     Definition of two basic tolerance schedulers (dp)    ----- !-------------------------------------------------------------------- subroutine constant_atol_dp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag character ( len = 256 ) :: msg tol = target_tol write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'constant_atol_dp' ) return end subroutine constant_atol_dp subroutine dynamic_tol_dp ( tol , target_tol , rnorm , iter , info ) !! Abstract interface to define tolerance scheduler for the Newton iteration real ( dp ), intent ( out ) :: tol !! Tolerance to be used real ( dp ), intent ( in ) :: target_tol !! Target tolerance real ( dp ), intent ( in ) :: rnorm !! Norm of the residual of the current iterate integer , intent ( in ) :: iter !! Newton iteration count integer , intent ( out ) :: info !! Information flag ! internals real ( dp ) :: tol_old character ( len = 256 ) :: msg tol_old = tol tol = max ( 0.1 * rnorm , target_tol ) if ( tol /= tol_old ) then if ( tol == target_tol ) then write ( msg , '(A,E9.2)' ) 'Solver tolerance set to input target. tol= ' , tol else write ( msg , '(A,E9.2)' ) 'Solver tolerance set to tol= ' , tol end if call logger % log_information ( msg , module = this_module , procedure = 'dynamic_tol_dp' ) end if return end subroutine dynamic_tol_dp end module LightKrylov_NewtonKrylov","tags":"","loc":"sourcefile/newtonkrylov.f90.html"},{"title":"AbstractLinops.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractLinops !!  This module provides the base classes `abtract_linop_rsp`, `abstract_linop_rdp`, !!  `abstract_linop_csp` and `abstract_linop_cdp` which can be used to define your own !!  linear operators. To do so, you simply need to provide two type-bound procedures: !! !!  - `matvec(self, vec_in, vec_out)` : Computes the matrix-vector product. !!  - `rmatvec(self, vec_in, vec_out)`: Computes the transpose matrix-vector product. !! !!  It also provides extended types to define the identity operator, symmetric linear !!  operators, scalar-multiplication of a linear multiplication, as well as addition !!  of two linear operators. use LightKrylov_Constants use LightKrylov_Utils use LightKrylov_AbstractVectors implicit none private character ( len = 128 ), parameter :: this_module = 'Lightkrylov_AbstractLinops' type , abstract , public :: abstract_linop !!  Base type to define an abstract linear operator. All other types defined in !!  `LightKrylov` derive from this fundamental one. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_linop !------------------------------------------------------------------------------ !-----     Definition of an abstract real(sp) operator with kind=sp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_rsp !! Base type to extend in order to define a real(sp)-valued linear operator. contains private procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rsp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . end type abstract interface subroutine abstract_matvec_rsp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use LightKrylov_AbstractVectors import abstract_linop_rsp class ( abstract_linop_rsp ) , intent ( in ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rsp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rsp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_rsp end interface type , extends ( abstract_linop_rsp ), public :: adjoint_linop_rsp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` being switched. class ( abstract_linop_rsp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rsp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rsp end type !------------------------------------------------------------------------------ !-----     Definition of an abstract real(dp) operator with kind=dp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_rdp !! Base type to extend in order to define a real(dp)-valued linear operator. contains private procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_rdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . end type abstract interface subroutine abstract_matvec_rdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use LightKrylov_AbstractVectors import abstract_linop_rdp class ( abstract_linop_rdp ) , intent ( in ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_rdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_rdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_rdp end interface type , extends ( abstract_linop_rdp ), public :: adjoint_linop_rdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` being switched. class ( abstract_linop_rdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_rdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_rdp end type !------------------------------------------------------------------------------ !-----     Definition of an abstract complex(sp) operator with kind=sp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_csp !! Base type to extend in order to define a complex(sp)-valued linear operator. contains private procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_csp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . end type abstract interface subroutine abstract_matvec_csp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use LightKrylov_AbstractVectors import abstract_linop_csp class ( abstract_linop_csp ) , intent ( in ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_csp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_csp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_csp end interface type , extends ( abstract_linop_csp ), public :: adjoint_linop_csp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` being switched. class ( abstract_linop_csp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_csp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_csp end type !------------------------------------------------------------------------------ !-----     Definition of an abstract complex(dp) operator with kind=dp     ----- !------------------------------------------------------------------------------ type , abstract , extends ( abstract_linop ), public :: abstract_linop_cdp !! Base type to extend in order to define a complex(dp)-valued linear operator. contains private procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: matvec !! Procedure to compute the matrix-vector product  \\mathbf{y} = \\mathbf{Ax} . procedure ( abstract_matvec_cdp ), pass ( self ), deferred , public :: rmatvec !! Procedure to compute the reversed matrix-vector product  \\mathbf{y} = \\mathbf{A}&#94;H \\mathbf{x} . end type abstract interface subroutine abstract_matvec_cdp ( self , vec_in , vec_out ) !! Interface for the matrix-vector product. use LightKrylov_AbstractVectors import abstract_linop_cdp class ( abstract_linop_cdp ) , intent ( in ) :: self !! Linear operator \\mathbf{A}. class ( abstract_vector_cdp ), intent ( in ) :: vec_in !! Vector to be multiplied by \\mathbf{A}. class ( abstract_vector_cdp ), intent ( out ) :: vec_out !! Result of the matrix-vector product. end subroutine abstract_matvec_cdp end interface type , extends ( abstract_linop_cdp ), public :: adjoint_linop_cdp !! Utility type to define an adjoint linear operator. The definition of `matvec` and `rmatvec` !! are directly inherited from those used to define `A`. Note that this utility does not !! compute the adjoint for you. It simply provides a utility to define a new operator !! with `matvec` and `rmatvec` being switched. class ( abstract_linop_cdp ), allocatable :: A !! Linear operator whose adjoint needs to be defined. contains private procedure , pass ( self ), public :: matvec => adjoint_matvec_cdp procedure , pass ( self ), public :: rmatvec => adjoint_rmatvec_cdp end type !-------------------------------------------------- !-----     Definition of the Identity map     ----- !-------------------------------------------------- type , extends ( abstract_linop_rsp ), public :: Id_rsp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rsp procedure , pass ( self ), public :: rmatvec => id_matvec_rsp end type type , extends ( abstract_linop_rdp ), public :: Id_rdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_rdp procedure , pass ( self ), public :: rmatvec => id_matvec_rdp end type type , extends ( abstract_linop_csp ), public :: Id_csp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_csp procedure , pass ( self ), public :: rmatvec => id_matvec_csp end type type , extends ( abstract_linop_cdp ), public :: Id_cdp !! Utility type to define the Identity operator. Note that the type-bound procedures !! for `matvec` and `rmatvec` do not have to be defined by the user. contains private procedure , pass ( self ), public :: matvec => id_matvec_cdp procedure , pass ( self ), public :: rmatvec => id_matvec_cdp end type !---------------------------------------------- !-----     Definition of scaled linop     ----- !---------------------------------------------- type , extends ( abstract_linop_rsp ), public :: scaled_linop_rsp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and  \\sigma \\in \\mathbb{R} . The definitions of `matvec` !! and `rmatvec` are directly inherited from those used to define `A` and do not have to !! be defined by the user. class ( abstract_linop_rsp ), allocatable :: A !! Base linear operator to be scaled. real ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rsp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rsp end type type , extends ( abstract_linop_rdp ), public :: scaled_linop_rdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a real-valued operator and  \\sigma \\in \\mathbb{R} . The definitions of `matvec` !! and `rmatvec` are directly inherited from those used to define `A` and do not have to !! be defined by the user. class ( abstract_linop_rdp ), allocatable :: A !! Base linear operator to be scaled. real ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_rdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_rdp end type type , extends ( abstract_linop_csp ), public :: scaled_linop_csp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex-valued operator and  \\sigma \\in \\mathbb{C} . class ( abstract_linop_csp ), allocatable :: A !! Base linear operator to be scaled. complex ( sp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_csp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_csp end type type , extends ( abstract_linop_cdp ), public :: scaled_linop_cdp !! Defines a scaled linear operator  \\mathbf{B} = \\sigma \\mathbf{A}  with  \\mathbf{A}  a complex-valued operator and  \\sigma \\in \\mathbb{C} . class ( abstract_linop_cdp ), allocatable :: A !! Base linear operator to be scaled. complex ( dp ) :: sigma !! Scaling factor. contains private procedure , pass ( self ), public :: matvec => scaled_matvec_cdp procedure , pass ( self ), public :: rmatvec => scaled_rmatvec_cdp end type !------------------------------------------------ !-----     Definition of axpby operator     ----- !------------------------------------------------ type , extends ( abstract_linop_rsp ), public :: axpby_linop_rsp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to !! define `A` and `B`. class ( abstract_linop_rsp ), allocatable :: A , B !! Underlying linear operators. real ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rsp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rsp end type type , extends ( abstract_linop_rdp ), public :: axpby_linop_rdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to !! define `A` and `B`. class ( abstract_linop_rdp ), allocatable :: A , B !! Underlying linear operators. real ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_rdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_rdp end type type , extends ( abstract_linop_csp ), public :: axpby_linop_csp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to !! define `A` and `B`. class ( abstract_linop_csp ), allocatable :: A , B !! Underlying linear operators. complex ( sp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_csp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_csp end type type , extends ( abstract_linop_cdp ), public :: axpby_linop_cdp !! Utility type to define a composite linear operator  \\mathbf{C} = \\alpha \\mathbf{A} + \\beta \\mathbf{B} . !! The definitions of `matvec` and `rmatvec` are directly inherited from those used to !! define `A` and `B`. class ( abstract_linop_cdp ), allocatable :: A , B !! Underlying linear operators. complex ( dp ) :: alpha , beta !! Scaling factors. logical :: transA = . false ., transB = . false . !! Logical flag to control whether  \\mathbf{A}  and/or  \\mathbf{B}  need to be transposed. contains private procedure , pass ( self ), public :: matvec => axpby_matvec_cdp procedure , pass ( self ), public :: rmatvec => axpby_rmatvec_cdp end type !---------------------------------------------------------------- !-----     Definition of an abstract symmetric operator     ----- !---------------------------------------------------------------- type , abstract , extends ( abstract_linop_rsp ), public :: abstract_sym_linop_rsp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains end type !---------------------------------------------------------------- !-----     Definition of an abstract symmetric operator     ----- !---------------------------------------------------------------- type , abstract , extends ( abstract_linop_rdp ), public :: abstract_sym_linop_rdp !! Abstract representation of an abstract symmetric (real valued) linear operator. contains end type !---------------------------------------------------------------------------------- !-----     Definition of an abstract Hermitian positive definite operator     ----- !---------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_csp ), public :: abstract_hermitian_linop_csp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains end type !---------------------------------------------------------------------------------- !-----     Definition of an abstract Hermitian positive definite operator     ----- !---------------------------------------------------------------------------------- type , abstract , extends ( abstract_linop_cdp ), public :: abstract_hermitian_linop_cdp !! Abstract representation of an abstract hermitian (complex-valued) linear operator. contains end type contains subroutine id_matvec_rsp ( self , vec_in , vec_out ) class ( Id_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) return end subroutine id_matvec_rsp subroutine id_matvec_rdp ( self , vec_in , vec_out ) class ( Id_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) return end subroutine id_matvec_rdp subroutine id_matvec_csp ( self , vec_in , vec_out ) class ( Id_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) return end subroutine id_matvec_csp subroutine id_matvec_cdp ( self , vec_in , vec_out ) class ( Id_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call copy ( vec_out , vec_in ) return end subroutine id_matvec_cdp subroutine scaled_matvec_rsp ( self , vec_in , vec_out ) class ( scaled_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_matvec_rsp subroutine scaled_rmatvec_rsp ( self , vec_in , vec_out ) class ( scaled_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_rmatvec_rsp subroutine scaled_matvec_rdp ( self , vec_in , vec_out ) class ( scaled_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_matvec_rdp subroutine scaled_rmatvec_rdp ( self , vec_in , vec_out ) class ( scaled_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_rmatvec_rdp subroutine scaled_matvec_csp ( self , vec_in , vec_out ) class ( scaled_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_matvec_csp subroutine scaled_rmatvec_csp ( self , vec_in , vec_out ) class ( scaled_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_rmatvec_csp subroutine scaled_matvec_cdp ( self , vec_in , vec_out ) class ( scaled_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_matvec_cdp subroutine scaled_rmatvec_cdp ( self , vec_in , vec_out ) class ( scaled_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) ; call vec_out % scal ( self % sigma ) return end subroutine scaled_rmatvec_cdp subroutine axpby_matvec_rsp ( self , vec_in , vec_out ) class ( axpby_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rsp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % rmatvec ( vec_in , wrk ) else call self % A % matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % rmatvec ( vec_in , vec_out ) else call self % B % matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_matvec_rsp subroutine axpby_rmatvec_rsp ( self , vec_in , vec_out ) class ( axpby_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rsp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % matvec ( vec_in , wrk ) else call self % A % rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % matvec ( vec_in , vec_out ) else call self % B % rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_rmatvec_rsp subroutine axpby_matvec_rdp ( self , vec_in , vec_out ) class ( axpby_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rdp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % rmatvec ( vec_in , wrk ) else call self % A % matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % rmatvec ( vec_in , vec_out ) else call self % B % matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_matvec_rdp subroutine axpby_rmatvec_rdp ( self , vec_in , vec_out ) class ( axpby_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_rdp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % matvec ( vec_in , wrk ) else call self % A % rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % matvec ( vec_in , vec_out ) else call self % B % rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_rmatvec_rdp subroutine axpby_matvec_csp ( self , vec_in , vec_out ) class ( axpby_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_csp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % rmatvec ( vec_in , wrk ) else call self % A % matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % rmatvec ( vec_in , vec_out ) else call self % B % matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_matvec_csp subroutine axpby_rmatvec_csp ( self , vec_in , vec_out ) class ( axpby_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_csp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % matvec ( vec_in , wrk ) else call self % A % rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % matvec ( vec_in , vec_out ) else call self % B % rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_rmatvec_csp subroutine axpby_matvec_cdp ( self , vec_in , vec_out ) class ( axpby_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_cdp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % rmatvec ( vec_in , wrk ) else call self % A % matvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % rmatvec ( vec_in , vec_out ) else call self % B % matvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_matvec_cdp subroutine axpby_rmatvec_cdp ( self , vec_in , vec_out ) class ( axpby_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out ! Working array. class ( abstract_vector_cdp ), allocatable :: wrk ! Allocate working array. allocate ( wrk , source = vec_in ) ; call wrk % zero () ! w = A @ x if ( self % transA ) then call self % A % matvec ( vec_in , wrk ) else call self % A % rmatvec ( vec_in , wrk ) endif ! y = B @ x if ( self % transB ) then call self % B % matvec ( vec_in , vec_out ) else call self % B % rmatvec ( vec_in , vec_out ) endif ! y = alpha*w + beta*y call vec_out % axpby ( self % beta , wrk , self % alpha ) return end subroutine axpby_rmatvec_cdp subroutine adjoint_matvec_rsp ( self , vec_in , vec_out ) class ( adjoint_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) return end subroutine adjoint_matvec_rsp subroutine adjoint_rmatvec_rsp ( self , vec_in , vec_out ) class ( adjoint_linop_rsp ), intent ( in ) :: self class ( abstract_vector_rsp ), intent ( in ) :: vec_in class ( abstract_vector_rsp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) return end subroutine adjoint_rmatvec_rsp subroutine adjoint_matvec_rdp ( self , vec_in , vec_out ) class ( adjoint_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) return end subroutine adjoint_matvec_rdp subroutine adjoint_rmatvec_rdp ( self , vec_in , vec_out ) class ( adjoint_linop_rdp ), intent ( in ) :: self class ( abstract_vector_rdp ), intent ( in ) :: vec_in class ( abstract_vector_rdp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) return end subroutine adjoint_rmatvec_rdp subroutine adjoint_matvec_csp ( self , vec_in , vec_out ) class ( adjoint_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) return end subroutine adjoint_matvec_csp subroutine adjoint_rmatvec_csp ( self , vec_in , vec_out ) class ( adjoint_linop_csp ), intent ( in ) :: self class ( abstract_vector_csp ), intent ( in ) :: vec_in class ( abstract_vector_csp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) return end subroutine adjoint_rmatvec_csp subroutine adjoint_matvec_cdp ( self , vec_in , vec_out ) class ( adjoint_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % rmatvec ( vec_in , vec_out ) return end subroutine adjoint_matvec_cdp subroutine adjoint_rmatvec_cdp ( self , vec_in , vec_out ) class ( adjoint_linop_cdp ), intent ( in ) :: self class ( abstract_vector_cdp ), intent ( in ) :: vec_in class ( abstract_vector_cdp ), intent ( out ) :: vec_out call self % A % matvec ( vec_in , vec_out ) return end subroutine adjoint_rmatvec_cdp end module LightKrylov_AbstractLinops","tags":"","loc":"sourcefile/abstractlinops.f90.html"},{"title":"IterativeSolvers.f90 – LightKrylov","text":"Source Code module LightKrylov_IterativeSolvers !!  This module provides some of the most important computational routines provided by !!  `LightKrylov`. These include: !! !!  - `eigs` : Compute the leading eigenpairs of a square linear operator  A . !!  - `eighs` : Compute the leading eigenpairs of a symmetric positive definite !!              operator  A . !!  - `svds` : Compute the leading singular triplets of a linear operator  A . !!  - `gmres` : Solve the linear system  Ax = b  using the *generalized minimum !!              residual method*. !!  - `cg` : Solve the linear system  Ax = b  where  A  is symmetric !!           positive definite using the *Conjugate Gradient* method. !! !!  It also provides abstract interfaces to pass user-defined solvers and preconditioners !!  to `LightKrylov`. Note that these features are still experimental however. !-------------------------------------------- !-----     Fortran Standard Library     ----- !-------------------------------------------- use iso_fortran_env , only : output_unit use stdlib_sorting , only : sort_index use stdlib_optval , only : optval use stdlib_io_npy , only : save_npy use stdlib_linalg , only : lstsq , svd , eigh use stdlib_stats , only : median !------------------------------- !-----     LightKrylov     ----- !------------------------------- use LightKrylov_Constants Use LightKrylov_Logger use LightKrylov_Utils use LightKrylov_AbstractVectors use LightKrylov_AbstractLinops use LightKrylov_BaseKrylov implicit none private character ( len = 128 ), parameter :: this_module = 'LightKrylov_IterativeSolvers' public :: abstract_linear_solver_rsp public :: abstract_linear_solver_rdp public :: abstract_linear_solver_csp public :: abstract_linear_solver_cdp public :: save_eigenspectrum public :: eigs public :: eighs public :: svds public :: gmres public :: gmres_rsp public :: gmres_rdp public :: gmres_csp public :: gmres_cdp public :: cg public :: cg_rsp public :: cg_rdp public :: cg_csp public :: cg_cdp interface save_eigenspectrum !!  ### Description !! !!  Utility function to save the eigenspectrum computed from the Arnoldi factorization. !!  It outpost a .npy file. !! !!  ### Syntax !! !!  ```fortran !!      call save_eigenspectrum(eigvals, residuals, fname) !!  ``` !! !!  ### Arguments !! !!  `eigvals` : `complex` rank-1 array containing the eigenvalues. !! !!  `residuals` : `real` rank-1 array containing the residuals associated to each !!                eigenvalues. !! !!  `fname` : Name of the file to save the eigenspectrum. module procedure save_eigenspectrum_sp module procedure save_eigenspectrum_dp end interface interface eighs !!  ### Description !! !!  Computes the leading eigenpairs of a symmetric operator A !!  using the Lanczos iterative process. Given a square linear operator A, it finds !!  the leading eigvalues and eigvectors such that: !! !!   !!      Ax = \\lambda x !!   !! !!  The subspace X is constructed via Lanczos factorization, resulting in a symmetric !!  tridiagonal matrix T. The eigenvalues of A are approximated by those of T !!  and the eigenvectors are computed accordingly. !! !!  **References** !! !!  - Lanczos, C. (1950). \"An Iteration Method for the Solution of the Eigenvalue Problem !!  of Linear Differential and Integral Operators\". United States Governm. Press Office. !! !!  ### Syntax !! !!  ```fortran !!      call eighs(A, X, eigvals, residuals, info [, kdim] [,tolerance]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!        eigenpairs need to be computed. It is an `intent(in)` argument. !! !!  `X` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!        contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes !!        the number of eigenpairs computed. !! !!  `eigvals` : Rank-1 array of `real` numbers. On exit, it contains the leading !!              eigenvalues of `A`. It is an `intent(out)` argument. !! !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals !!                associated with each eigenpairs. It is an `intent(out)` argument. !! !!  `info` : `integer` Information flag. !! !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to !!                        approximate the leading eigenpairs. It is an `intent(in)` !!                        argument. By default, `kdim = 4*size(X)`. !! !!  `tolerance` (*optional*) : `real` tolerance below which an eigenpair is considered as !!                             being converged. It is an `intent(in)` agument. By default, !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`. module procedure eighs_rsp module procedure eighs_rdp module procedure eighs_csp module procedure eighs_cdp end interface interface eigs !!  ### Description !! !!  Computes the leading eigenpairs of a square linear operator A !!  using the Arnoldi iterative process. Given a square linear operator A, it finds !!  the leading eigvalues and eigvectorss such that: !! !!   !!      Ax = \\lambda x !!   !! !!  or !! !!   !!      A&#94;H x = \\lambda x. !!   !! !!  The subspace X is constructed via Arnoldi factorization, resulting in an upper !!  Hessenberg matrix H. The eigenvalues of A are approximated by those of H !!  and the eigenvectors are computed accordingly. !! !!  **References** !! !!  - Arnoldi, W. E. (1951). \"The Principle of Minimized Iterations in the Solution of !!    the Matrix Eigenvalue Problem.\" Quarterly of Applied Mathematics, 9(1), 17–29. !! !!  ### Syntax !! !!  ```fortran !!      call eigs(A, X, eigvals, residuals, info [, kdim] [, select] [,tolerance] [, transpose]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!        eigenpairs need to be computed. It is an `intent(in)` argument. !! !!  `X` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!        contains the leading eigenvectors of `A`. Note that the dimension of `X` fixes !!        the number of eigenpairs computed. !! !!  `eigvals` : Rank-1 array of `real` numbers. On exit, it contains the leading !!              eigenvalues of `A`. It is an `intent(out)` argument. !! !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals !!                associated with each eigenpairs. It is an `intent(out)` argument. !! !!  `info` : `integer` Information flag. !! !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to !!                        approximate the leading eigenpairs. It is an `intent(in)` !!                        argument. By default, `kdim = 4*size(X)`. !! !!  `select` (*optional*) : Function to select which eigenvalues to compute. !! !!  `tolerance` (*optional*) : `real` tolerance below which an eigenpair is considered as !!                             being converged. It is an `intent(in)` agument. By default, !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`. !! !!  `transpose` (*optional*) : `logical` flag determining whether the eigenvalues of A !!                             or A&#94;H need to be computed. module procedure eigs_rsp module procedure eigs_rdp module procedure eigs_csp module procedure eigs_cdp end interface interface svds !!  ### Description !! !!  Computes the leading singular triplets of an arbitrary linear operator A !!  using the Lanczos iterative process. Given a linear operator A, it finds !!  the leading singular values and singular vectors such that: !! !!   !!      \\begin{aligned} !!      Av & = \\sigma u \\\\ !!      A&#94;H u & = \\sigma v. !!      \\end{aligned} !!   !! !!  The subspaces U and V are constructed via Lanczos factorization, resulting in !!  a bidiagonal matrix B. The singular values of A are approximated by those of !!  B and the singular vectors are computed accordingly. !! !!  **References** !! !!  - Golub, G. H., & Kahan, W. (1965). \"Calculating the Singular Values and !!   Pseudo-Inverse of a Matrix.\" !!  - Baglama, J., & Reichel, L. (2005). \"Augmented implicitly restarted Lanczos !!   bidiagonalization methods.\" !!  - R. M. Larsen. \"Lanczos bidiagonalization with partial reorthogonalization.\" !!   Technical Report, 1998. !! !!  ### Syntax !! !!  ```fortran !!      call svds(A, U, S, V, residuals, info [, kdim] [,tolerance]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from `abstract_sym_linop_rsp`, `abstract_sym_linop_rdp`, !!        `abstract_hermitian_linop_csp` or `abstract_hermitian_linop_cdp` whose leading !!        eigenpairs need to be computed. It is an `intent(in)` argument. !! !!  `U` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!        contains the left singular vectors of `A`. Note that the dimension of `U` fixes !!        the number of eigenpairs computed. !! !!  `S` : Rank-1 array of `real` numbers. On exit, it contains the leading !!        singular values of `A`. It is an `intent(out)` argument. !! !!  `V` : Array of `abstract_vectors` with the same type and kind as `A`. On exit, it !!        contains the left singular vectors of `A`. Note that the dimension of `U` fixes !!        the number of eigenpairs computed. !! !!  `residuals` : Rank-1 array of `real` numbers. On exit, it contains the residuals !!                associated with each singular triplet. It is an `intent(out)` argument. !! !!  `info` : `integer` Information flag. !! !!  `kdim` (*optional*) : `integer`, maximum dimension of the Krylov subspace used to !!                        approximate the leading singular triplets. It is an `intent(in)` !!                        argument. By default, `kdim = 4*size(X)`. !! !!  `tolerance` (*optional*) : `real` tolerance below which a triplet is considered as !!                             being converged. It is an `intent(in)` agument. By default, !!                             `tolerance = rtol_sp` or `tolerance = rtol_dp`. module procedure svds_rsp module procedure svds_rdp module procedure svds_csp module procedure svds_cdp end interface interface gmres !!  ### Description !! !!  Solve a square linear system of equations !! !!   !!      Ax = b !!   !! !!  using the *Generalized Minimum RESidual* (GMRES) method. !! !!  **References** !! !!  - Saad Y. and Schultz M. H. \"GMRES: A generalized minimal residual algorithm for !!  solving nonsymmetric linear systems.\" SIAM Journal on Scientific and Statistical !!  Computing, 7(3), 1986. !! !!  ### Syntax !! !!  ```fortran !!      call gmres(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options] [, transpose]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from one of the `abstract_linop` provided by the !!  `AbstractLinops` module. It is an `intent(in)` argument. !! !!  `b` : Right-hand side vector derived from one the `abstract_vector` types provided !!  by the `AbstractVectors` module. It needs to have the same type and kind as `A`. !!  It is an `intent(in)` argument. !! !!  `x` : On entry, initial guess for the solution. On exit, the solution computed by !!  gmres. It is a vector derived from one the `abstract_vector` types provided by the !!  `AbstractVectors` module. It needs to have the same type and kind as `A`. It is !!  an `intent(inout)` argument. !! !!  `info` : `integer` information flag. !! !!  `rtol` (optional) : `real` relative tolerance for the solver. !! !!  `atol` (optional) : `real` absolute tolerance for the solver. !! !!  `preconditioner` (optional) : Right preconditioner used to solve the system. It needs !!  to be consistent with the `abstract_preconditioner` interface. It is an `intent(in)` !!  argument. !! !!  `options` (optional) : Container for the gmres options given by the `gmres_opts` type. !!  It is an `intent(in)` argument. !! !!  `transpose` (optional) : `logical` flag controlling whether  Ax = b or !!   A&#94;H x = b  is being solver. module procedure gmres_rsp module procedure gmres_rdp module procedure gmres_csp module procedure gmres_cdp end interface interface cg !!  ### Description !! !!  Given a symmetric (positive definite) matrix  A , solves the linear system !! !!   !!      Ax = b !!   !! !!  using the *Conjugate Gradient* method. !! !!  **References** !! !!  - Hestenes, M. R., and Stiefel, E. (1952). \"Methods of Conjugate Gradients for Solving !!  Linear Systems,\" Journal of Research of the National Bureau of Standards, !!  49(6), 409–436. !! !!  ### Syntax !! !!  ```fortran !!      call cg(A, b, x, info [, rtol] [, atol] [, preconditioner] [, options]) !!  ``` !! !!  ### Arguments !! !!  `A` : Linear operator derived from one of the `abstract_sym_linop` or !!  `abstract_hermitian_linop` types provided by the `AbstractLinops` module. It is an !!  `intent(in)` argument. !! !!  `b` : Right-hand side vector derived from one the `abstract_vector` types provided !!  by the `AbstractVectors` module. It needs to have the same type and kind as `A`. !!  It is an `intent(in)` argument. !! !!  `x` : On entry, initial guess for the solution. On exit, the solution computed by !!  cg. It is a vector derived from one the `abstract_vector` types provided by the !!  `AbstractVectors` module. It needs to have the same type and kind as `A`. It is !!  an `intent(inout)` argument. !! !!  `info` : `integer` information flag. !! !!  `rtol` (optional) : `real` relative tolerance for the solver. !! !!  `atol` (optional) : `real` absolute tolerance for the solver. !! !!  `preconditioner` (optional) : Right preconditioner used to solve the system. It needs !!  to be consistent with the `abstract_preconditioner` interface. It is an `intent(in)` !!  argument. !! !!  `options` (optional) : Container for the gmres options given by the `cg_opts` type. !!  It is an `intent(in)` argument. !! !!  @note !!  Although the interface to pass a preconditioner is exposed, it is not currently !!  implemented. !!  @endnote module procedure cg_rsp module procedure cg_rdp module procedure cg_csp module procedure cg_cdp end interface !------------------------------------------------------ !-----     ABSTRACT PRECONDITIONER DEFINITION     ----- !------------------------------------------------------ type , abstract , public :: abstract_precond_rsp contains private procedure ( abstract_apply_rsp ), pass ( self ), public , deferred :: apply end type abstract interface subroutine abstract_apply_rsp ( self , vec ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_rsp , abstract_vector_rsp class ( abstract_precond_rsp ), intent ( in ) :: self !! Preconditioner. class ( abstract_vector_rsp ), intent ( inout ) :: vec !! Input/Output vector. end subroutine abstract_apply_rsp end interface type , abstract , public :: abstract_precond_rdp contains private procedure ( abstract_apply_rdp ), pass ( self ), public , deferred :: apply end type abstract interface subroutine abstract_apply_rdp ( self , vec ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_rdp , abstract_vector_rdp class ( abstract_precond_rdp ), intent ( in ) :: self !! Preconditioner. class ( abstract_vector_rdp ), intent ( inout ) :: vec !! Input/Output vector. end subroutine abstract_apply_rdp end interface type , abstract , public :: abstract_precond_csp contains private procedure ( abstract_apply_csp ), pass ( self ), public , deferred :: apply end type abstract interface subroutine abstract_apply_csp ( self , vec ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_csp , abstract_vector_csp class ( abstract_precond_csp ), intent ( in ) :: self !! Preconditioner. class ( abstract_vector_csp ), intent ( inout ) :: vec !! Input/Output vector. end subroutine abstract_apply_csp end interface type , abstract , public :: abstract_precond_cdp contains private procedure ( abstract_apply_cdp ), pass ( self ), public , deferred :: apply end type abstract interface subroutine abstract_apply_cdp ( self , vec ) !! Abstract interface to apply a preconditioner in `LightKrylov`. import abstract_precond_cdp , abstract_vector_cdp class ( abstract_precond_cdp ), intent ( in ) :: self !! Preconditioner. class ( abstract_vector_cdp ), intent ( inout ) :: vec !! Input/Output vector. end subroutine abstract_apply_cdp end interface !-------------------------------------------------------- !-----                                              ----- !-----     GENERIC INTERFACE FOR LINEAR SOLVERS     ----- !-----                                              ----- !-------------------------------------------------------- abstract interface subroutine abstract_linear_solver_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_rsp , abstract_vector_rsp , abstract_opts , abstract_precond_rsp , sp class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to invert. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. end subroutine abstract_linear_solver_rsp subroutine abstract_linear_solver_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_rdp , abstract_vector_rdp , abstract_opts , abstract_precond_rdp , dp class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to invert. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. end subroutine abstract_linear_solver_rdp subroutine abstract_linear_solver_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_csp , abstract_vector_csp , abstract_opts , abstract_precond_csp , sp class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to invert. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. end subroutine abstract_linear_solver_csp subroutine abstract_linear_solver_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) !! Abstract interface to use a user-defined linear solver in `LightKrylov`. import abstract_linop_cdp , abstract_vector_cdp , abstract_opts , abstract_precond_cdp , dp class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to invert. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. In case of successful exit, the flag should return the number of iterations required for convergence. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner. class ( abstract_opts ), optional , intent ( in ) :: options !! Options passed to the linear solver. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} (`.false.`) or \\mathbf{A}&#94;T (`.true.`) is being used. end subroutine abstract_linear_solver_cdp end interface contains !------------------------------------- !-----     UTILITY FUNCTIONS     ----- !------------------------------------- elemental pure function compute_residual_rsp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) return end function compute_residual_rsp elemental pure function compute_residual_rdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. real ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. real ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) return end function compute_residual_rdp elemental pure function compute_residual_csp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( sp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( sp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( sp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) return end function compute_residual_csp elemental pure function compute_residual_cdp ( beta , x ) result ( residual ) !! Computes the residual associated with a Ritz eigenpair. complex ( dp ), intent ( in ) :: beta !! Norm of the residual Krylov vector. complex ( dp ), intent ( in ) :: x !! Last entry of the low-dimensional Ritz eigenvector. real ( dp ) :: residual !! Residual associated to the corresponding Ritz eigenpair. residual = abs ( beta * x ) return end function compute_residual_cdp subroutine save_eigenspectrum_sp ( eigvals , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. complex ( sp ), intent ( in ) :: eigvals (:) !! Eigenalues. real ( sp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. ! Internal variables. real ( sp ) :: data ( size ( eigvals ), 3 ) ! Store data. data (:, 1 ) = eigvals % re ; data (:, 2 ) = eigvals % im ; data (:, 3 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , data ) return end subroutine save_eigenspectrum_sp function median_eigvals_selector_sp ( lambda ) result ( selected ) complex ( sp ), intent ( in ) :: lambda (:) logical :: selected ( size ( lambda )) selected = abs ( lambda ) > median ( abs ( lambda )) return end function median_eigvals_selector_sp subroutine save_eigenspectrum_dp ( eigvals , residuals , fname ) !! Saves the eigenspectrum and corresponding residuals to disk use the `npy` binary format. complex ( dp ), intent ( in ) :: eigvals (:) !! Eigenalues. real ( dp ), intent ( in ) :: residuals (:) !! Residual of the corresponding Ritz eigenpairs. character ( len =* ), intent ( in ) :: fname !! Name of the output file. ! Internal variables. real ( dp ) :: data ( size ( eigvals ), 3 ) ! Store data. data (:, 1 ) = eigvals % re ; data (:, 2 ) = eigvals % im ; data (:, 3 ) = residuals ! Save the eigenspectrum to disk. call save_npy ( fname , data ) return end subroutine save_eigenspectrum_dp function median_eigvals_selector_dp ( lambda ) result ( selected ) complex ( dp ), intent ( in ) :: lambda (:) logical :: selected ( size ( lambda )) selected = abs ( lambda ) > median ( abs ( lambda )) return end function median_eigvals_selector_dp !--------------------------------------------------- !-----     GENERAL EIGENVALUE COMPUTATIONS     ----- !--------------------------------------------------- subroutine eigs_rsp ( A , X , eigvals , residuals , info , kdim , select , tolerance , transpose ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim procedure ( eigvals_select_sp ), optional :: select !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_rsp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. real ( sp ), allocatable :: eigvecs_wrk (:, :) complex ( sp ), allocatable :: eigvals_wrk (:) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nev , conv integer :: i , j , k , niter , krst real ( sp ) :: tol real ( sp ) :: beta real ( sp ) :: alpha character ( len = 256 ) :: msg ! Eigenvalue selection. procedure ( eigvals_select_sp ), pointer :: select_ ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) if ( present ( select )) then select_ => select else select_ => median_eigvals_selector_sp endif ! Allocate eigenvalues. allocate ( eigvals ( nev )) ; eigvals = 0.0_sp ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( H ( kdim_ + 1 , kdim_ )) ; H = 0.0_sp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = 0.0_sp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp ! Ritz eigenpairs computation. H = 0.0_sp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'eigs_rsp' ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = 0.0_sp call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Compute residuals. beta = H ( k + 1 , k ) do i = 1 , k if ( eigvals_wrk ( i )% im > 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i ), eigvecs_wrk ( k , i + 1 ), kind = sp )) else if ( eigvals_wrk ( i )% im < 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i - 1 ), eigvecs_wrk ( k , i ), kind = sp )) else alpha = abs ( eigvecs_wrk ( k , i )) endif residuals_wrk ( i ) = compute_residual_rsp ( beta , alpha ) enddo ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_rsp' ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_rsp' ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , select_ ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( sp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ) ; call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_rsp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = niter return end subroutine eigs_rsp subroutine eigs_rdp ( A , X , eigvals , residuals , info , kdim , select , tolerance , transpose ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim procedure ( eigvals_select_dp ), optional :: select !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_rdp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. real ( dp ), allocatable :: eigvecs_wrk (:, :) complex ( dp ), allocatable :: eigvals_wrk (:) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nev , conv integer :: i , j , k , niter , krst real ( dp ) :: tol real ( dp ) :: beta real ( dp ) :: alpha character ( len = 256 ) :: msg ! Eigenvalue selection. procedure ( eigvals_select_dp ), pointer :: select_ ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) if ( present ( select )) then select_ => select else select_ => median_eigvals_selector_dp endif ! Allocate eigenvalues. allocate ( eigvals ( nev )) ; eigvals = 0.0_dp ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( H ( kdim_ + 1 , kdim_ )) ; H = 0.0_dp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = 0.0_dp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp ! Ritz eigenpairs computation. H = 0.0_dp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'eigs_rdp' ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = 0.0_dp call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Compute residuals. beta = H ( k + 1 , k ) do i = 1 , k if ( eigvals_wrk ( i )% im > 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i ), eigvecs_wrk ( k , i + 1 ), kind = dp )) else if ( eigvals_wrk ( i )% im < 0 ) then alpha = abs ( cmplx ( eigvecs_wrk ( k , i - 1 ), eigvecs_wrk ( k , i ), kind = dp )) else alpha = abs ( eigvecs_wrk ( k , i )) endif residuals_wrk ( i ) = compute_residual_rdp ( beta , alpha ) enddo ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_rdp' ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_rdp' ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , select_ ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( dp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ) ; call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_rdp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = niter return end subroutine eigs_rdp subroutine eigs_csp ( A , X , eigvals , residuals , info , kdim , select , tolerance , transpose ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_csp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim procedure ( eigvals_select_sp ), optional :: select !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_csp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. complex ( sp ), allocatable :: eigvecs_wrk (:, :) complex ( sp ), allocatable :: eigvals_wrk (:) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nev , conv integer :: i , j , k , niter , krst real ( sp ) :: tol complex ( sp ) :: beta character ( len = 256 ) :: msg ! Eigenvalue selection. procedure ( eigvals_select_sp ), pointer :: select_ ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) if ( present ( select )) then select_ => select else select_ => median_eigvals_selector_sp endif ! Allocate eigenvalues. allocate ( eigvals ( nev )) ; eigvals = 0.0_sp ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( H ( kdim_ + 1 , kdim_ )) ; H = 0.0_sp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = 0.0_sp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp ! Ritz eigenpairs computation. H = 0.0_sp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'eigs_csp' ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = 0.0_sp call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Compute residuals. beta = H ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_csp ( beta , eigvecs_wrk ( k ,: k )) ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_csp' ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_csp' ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , select_ ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( sp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ) ; call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_csp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = niter return end subroutine eigs_csp subroutine eigs_cdp ( A , X , eigvals , residuals , info , kdim , select , tolerance , transpose ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: X (:) !! Leading eigenvectors of \\mathbf{A}. complex ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of \\mathbf{A}. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim procedure ( eigvals_select_dp ), optional :: select !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. logical , optional , intent ( in ) :: transpose !! Determine whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Krylov subspace and Krylov subspace dimension. class ( abstract_vector_cdp ), allocatable :: Xwrk (:) integer :: kdim_ , kstart ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Working arrays for the eigenvectors and eigenvalues. complex ( dp ), allocatable :: eigvecs_wrk (:, :) complex ( dp ), allocatable :: eigvals_wrk (:) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nev , conv integer :: i , j , k , niter , krst real ( dp ) :: tol complex ( dp ) :: beta character ( len = 256 ) :: msg ! Eigenvalue selection. procedure ( eigvals_select_dp ), pointer :: select_ ! Deals with optional parameters. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) if ( present ( select )) then select_ => select else select_ => median_eigvals_selector_dp endif ! Allocate eigenvalues. allocate ( eigvals ( nev )) ; eigvals = 0.0_dp ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( H ( kdim_ + 1 , kdim_ )) ; H = 0.0_dp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = 0.0_dp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp ! Ritz eigenpairs computation. H = 0.0_dp kstart = 1 ; conv = 0 ; niter = 0 ; krst = 1 krylovschur : do while ( conv < nev ) arnoldi_factorization : do k = kstart , kdim_ ! Arnoldi step. call arnoldi ( A , Xwrk , H , info , kstart = k , kend = k , transpose = transpose ) call check_info ( info , 'arnoldi' , module = this_module , procedure = 'eigs_cdp' ) ! Spectral decomposition of the k x k Hessenberg matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = 0.0_dp call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Compute residuals. beta = H ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_cdp ( beta , eigvecs_wrk ( k ,: k )) ! Check convergence. niter = niter + 1 conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , niter , & & ' steps of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_cdp' ) if ( conv >= nev ) exit arnoldi_factorization enddo arnoldi_factorization write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , krst , & & ' Krylov-Schur restarts of the Arnoldi process.' call logger % log_information ( msg , module = this_module , procedure = 'eigs_cdp' ) ! Krylov-Schur restarting procedure. krst = krst + 1 call krylov_schur ( kstart , Xwrk , H , select_ ) ; kstart = kstart + 1 end do krylovschur !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) real ( dp ) :: abs_eigvals ( kdim_ ) ! Re-compute eigenvalues and eigenvectors. k = min ( k , kdim_ ) ; call eig ( H (: k , : k ), eigvecs_wrk (: k , : k ), eigvals_wrk (: k )) ! Sort eigenvalues. abs_eigvals = abs ( eigvals_wrk ) ; call sort_index ( abs_eigvals , indices , reverse = . true .) eigvals_wrk = eigvals_wrk ( indices ) ; eigvecs_wrk = eigvecs_wrk (:, indices ) residuals_wrk = residuals_wrk ( indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_cdp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = niter return end subroutine eigs_cdp !----------------------------------------------------------------------------- !-----      EIGENVALUE COMPUTATIONS FOR SYMMETRIC/HERMITIAN MATRICES     ----- !----------------------------------------------------------------------------- subroutine eighs_rsp ( A , X , eigvals , residuals , info , kdim , tolerance ) class ( abstract_sym_linop_rsp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- class ( abstract_vector_rsp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. real ( sp ), allocatable :: T (:, :) ! Tridiagonal matrix. real ( sp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( sp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( sp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. ! Miscellaneous. integer :: i , j , k , nev , conv real ( sp ) :: tol real ( sp ) :: beta character ( len = 256 ) :: msg ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( T ( kdim_ + 1 , kdim_ )) ; T = zero_rsp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = zero_rsp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , module = this_module , procedure = 'eighs_rsp' ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = zero_rsp call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_rsp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'eighs_rsp' ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) !eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk (:, indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_rsp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = k return end subroutine eighs_rsp subroutine eighs_rdp ( A , X , eigvals , residuals , info , kdim , tolerance ) class ( abstract_sym_linop_rdp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- class ( abstract_vector_rdp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. real ( dp ), allocatable :: T (:, :) ! Tridiagonal matrix. real ( dp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( dp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( dp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. ! Miscellaneous. integer :: i , j , k , nev , conv real ( dp ) :: tol real ( dp ) :: beta character ( len = 256 ) :: msg ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( T ( kdim_ + 1 , kdim_ )) ; T = zero_rdp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = zero_rdp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , module = this_module , procedure = 'eighs_rdp' ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = zero_rdp call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_rdp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'eighs_rdp' ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) !eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk (:, indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_rdp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = k return end subroutine eighs_rdp subroutine eighs_csp ( A , X , eigvals , residuals , info , kdim , tolerance ) class ( abstract_hermitian_linop_csp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_csp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- class ( abstract_vector_csp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. complex ( sp ), allocatable :: T (:, :) ! Tridiagonal matrix. complex ( sp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( sp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( sp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. ! Miscellaneous. integer :: i , j , k , nev , conv real ( sp ) :: tol complex ( sp ) :: beta character ( len = 256 ) :: msg ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_sp ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( T ( kdim_ + 1 , kdim_ )) ; T = zero_csp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = zero_csp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , module = this_module , procedure = 'eighs_csp' ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_sp ; eigvecs_wrk = zero_csp call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_csp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'eighs_csp' ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) !eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk (:, indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_csp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = k return end subroutine eighs_csp subroutine eighs_cdp ( A , X , eigvals , residuals , info , kdim , tolerance ) class ( abstract_hermitian_linop_cdp ), intent ( in ) :: A !! Linear operator whose leading eigenpairs need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: X (:) !! Leading eigevectors of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: eigvals (:) !! Leading eigenvalues of  \\mathbf{A} . real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpairs. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- class ( abstract_vector_cdp ), allocatable :: Xwrk (:) ! Krylov subspace. integer :: kdim_ ! Krylov subspace dimension. complex ( dp ), allocatable :: T (:, :) ! Tridiagonal matrix. complex ( dp ), allocatable :: eigvecs_wrk (:, :) ! Working array for the Ritz eigenvectors. real ( dp ), allocatable :: eigvals_wrk (:) ! Working array for the Ritz eigenvalues. real ( dp ), allocatable :: residuals_wrk (:) ! Working array for the Ritz residuals. ! Miscellaneous. integer :: i , j , k , nev , conv real ( dp ) :: tol complex ( dp ) :: beta character ( len = 256 ) :: msg ! Deaks with the optional args. nev = size ( X ) kdim_ = optval ( kdim , 4 * nev ) tol = optval ( tolerance , rtol_dp ) ! Allocate working variables. allocate ( Xwrk ( kdim_ + 1 ), source = X ( 1 )) ; call zero_basis ( Xwrk ) ; call Xwrk ( 1 )% rand (. true .) allocate ( T ( kdim_ + 1 , kdim_ )) ; T = zero_cdp allocate ( eigvecs_wrk ( kdim_ , kdim_ )) ; eigvecs_wrk = zero_cdp allocate ( eigvals_wrk ( kdim_ )) ; eigvals_wrk = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp ! Ritz eigenpairs computation. lanczos_iter : do k = 1 , kdim_ ! Symmetric Lanczos step. call lanczos ( A , Xwrk , T , info , kstart = k , kend = k ) call check_info ( info , 'lanczos' , module = this_module , procedure = 'eighs_cdp' ) ! Spectral decomposition of the k x k tridiagonal matrix. eigvals_wrk = 0.0_dp ; eigvecs_wrk = zero_cdp call eigh ( T (: k , : k ), eigvals_wrk (: k ), vectors = eigvecs_wrk (: k , : k )) ! Compute residuals. beta = T ( k + 1 , k ) residuals_wrk (: k ) = compute_residual_cdp ( beta , eigvecs_wrk ( k , : k )) ! Check convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nev , ' eigenvalues converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'eighs_cdp' ) if ( conv >= nev ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- block integer :: indices ( kdim_ ) call sort_index ( eigvals_wrk , indices , reverse = . true .) !eigvals_wrk = eigvals_wrk(indices) ; eigvecs_wrk = eigvecs_wrk (:, indices ) ! Store converged eigenvalues. eigvals = eigvals_wrk (: nev ) ; residuals = residuals_wrk (: nev ) end block ! Construct eigenvectors. k = min ( k , kdim_ ) do i = 1 , nev call X ( i )% zero () do j = 1 , k call X ( i )% axpby ( one_cdp , Xwrk ( j ), eigvecs_wrk ( j , i )) enddo enddo info = k return end subroutine eighs_cdp !------------------------------------------------ !-----     SINGULAR VALUE DECOMPOSITION     ----- !------------------------------------------------ subroutine svds_rsp ( A , U , S , V , residuals , info , kdim , tolerance ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_rsp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( sp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_rsp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_rsp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. real ( sp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( sp ), allocatable :: svdvals_wrk (:) real ( sp ), allocatable :: umat (:, :), vmat (:, :) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nsv , conv integer :: i , j , k real ( sp ) :: tol character ( len = 256 ) :: msg ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_sp ) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), source = U ( 1 )) ; call zero_basis ( Uwrk ) ; call Uwrk ( 1 )% rand (. true .) allocate ( Vwrk ( kdim_ + 1 ), source = V ( 1 )) ; call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ )) ; svdvals_wrk = 0.0_sp allocate ( umat ( kdim_ , kdim_ )) ; umat = 0.0_sp allocate ( vmat ( kdim_ , kdim_ )) ; vmat = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp allocate ( B ( kdim_ + 1 , kdim_ )) ; B = 0.0_sp info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , module = this_module , procedure = 'svds_rsp' ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_sp ; umat = 0.0_sp ; vmat = 0.0_sp call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) vmat (: k , : k ) = transpose ( vmat (: k , : k )) residuals_wrk (: k ) = compute_residual_rsp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'svds_rsp' ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k do i = 1 , nsv call U ( i )% zero () ; call V ( i )% zero () do j = 1 , k call U ( i )% axpby ( one_rsp , Uwrk ( j ), umat ( j , i )) call V ( i )% axpby ( one_rsp , Vwrk ( j ), vmat ( j , i )) enddo enddo return end subroutine svds_rsp subroutine svds_rdp ( A , U , S , V , residuals , info , kdim , tolerance ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_rdp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( dp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_rdp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_rdp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. real ( dp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( dp ), allocatable :: svdvals_wrk (:) real ( dp ), allocatable :: umat (:, :), vmat (:, :) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nsv , conv integer :: i , j , k real ( dp ) :: tol character ( len = 256 ) :: msg ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_dp ) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), source = U ( 1 )) ; call zero_basis ( Uwrk ) ; call Uwrk ( 1 )% rand (. true .) allocate ( Vwrk ( kdim_ + 1 ), source = V ( 1 )) ; call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ )) ; svdvals_wrk = 0.0_dp allocate ( umat ( kdim_ , kdim_ )) ; umat = 0.0_dp allocate ( vmat ( kdim_ , kdim_ )) ; vmat = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp allocate ( B ( kdim_ + 1 , kdim_ )) ; B = 0.0_dp info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , module = this_module , procedure = 'svds_rdp' ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_dp ; umat = 0.0_dp ; vmat = 0.0_dp call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) vmat (: k , : k ) = transpose ( vmat (: k , : k )) residuals_wrk (: k ) = compute_residual_rdp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'svds_rdp' ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k do i = 1 , nsv call U ( i )% zero () ; call V ( i )% zero () do j = 1 , k call U ( i )% axpby ( one_rdp , Uwrk ( j ), umat ( j , i )) call V ( i )% axpby ( one_rdp , Vwrk ( j ), vmat ( j , i )) enddo enddo return end subroutine svds_rdp subroutine svds_csp ( A , U , S , V , residuals , info , kdim , tolerance ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_csp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( sp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_csp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( sp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( sp ), optional , intent ( in ) :: tolerance !! Tolerance. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_csp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. complex ( sp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( sp ), allocatable :: svdvals_wrk (:) complex ( sp ), allocatable :: umat (:, :), vmat (:, :) real ( sp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nsv , conv integer :: i , j , k real ( sp ) :: tol character ( len = 256 ) :: msg ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_sp ) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), source = U ( 1 )) ; call zero_basis ( Uwrk ) ; call Uwrk ( 1 )% rand (. true .) allocate ( Vwrk ( kdim_ + 1 ), source = V ( 1 )) ; call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ )) ; svdvals_wrk = 0.0_sp allocate ( umat ( kdim_ , kdim_ )) ; umat = 0.0_sp allocate ( vmat ( kdim_ , kdim_ )) ; vmat = 0.0_sp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_sp allocate ( B ( kdim_ + 1 , kdim_ )) ; B = 0.0_sp info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , module = this_module , procedure = 'svds_csp' ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_sp ; umat = 0.0_sp ; vmat = 0.0_sp call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) vmat (: k , : k ) = conjg ( transpose ( vmat (: k , : k ))) residuals_wrk (: k ) = compute_residual_csp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'svds_csp' ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k do i = 1 , nsv call U ( i )% zero () ; call V ( i )% zero () do j = 1 , k call U ( i )% axpby ( one_csp , Uwrk ( j ), umat ( j , i )) call V ( i )% axpby ( one_csp , Vwrk ( j ), vmat ( j , i )) enddo enddo return end subroutine svds_csp subroutine svds_cdp ( A , U , S , V , residuals , info , kdim , tolerance ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator whose leading singular triplets need to be computed. class ( abstract_vector_cdp ), intent ( out ) :: U (:) !! Leading left singular vectors. real ( dp ), allocatable , intent ( out ) :: S (:) !! Leading singular values. class ( abstract_vector_cdp ), intent ( out ) :: V (:) !! Leading right singular vectors. real ( dp ), allocatable , intent ( out ) :: residuals (:) !! Residuals associated to each Ritz eigenpair. integer , intent ( out ) :: info !! Information flag. integer , optional , intent ( in ) :: kdim !! Desired number of eigenpairs. real ( dp ), optional , intent ( in ) :: tolerance !! Tolerance. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Left and right Krylov subspaces. integer :: kdim_ class ( abstract_vector_cdp ), allocatable :: Uwrk (:), Vwrk (:) ! Bidiagonal matrix. complex ( dp ), allocatable :: B (:, :) ! Working arrays for the singular vectors and singular values. real ( dp ), allocatable :: svdvals_wrk (:) complex ( dp ), allocatable :: umat (:, :), vmat (:, :) real ( dp ), allocatable :: residuals_wrk (:) ! Miscellaneous. integer :: nsv , conv integer :: i , j , k real ( dp ) :: tol character ( len = 256 ) :: msg ! Deals with the optional arguments. nsv = size ( U ) kdim_ = optval ( kdim , 4 * nsv ) tol = optval ( tolerance , rtol_dp ) ! Allocate working variables. allocate ( Uwrk ( kdim_ + 1 ), source = U ( 1 )) ; call zero_basis ( Uwrk ) ; call Uwrk ( 1 )% rand (. true .) allocate ( Vwrk ( kdim_ + 1 ), source = V ( 1 )) ; call zero_basis ( Vwrk ) allocate ( svdvals_wrk ( kdim_ )) ; svdvals_wrk = 0.0_dp allocate ( umat ( kdim_ , kdim_ )) ; umat = 0.0_dp allocate ( vmat ( kdim_ , kdim_ )) ; vmat = 0.0_dp allocate ( residuals_wrk ( kdim_ )) ; residuals_wrk = 0.0_dp allocate ( B ( kdim_ + 1 , kdim_ )) ; B = 0.0_dp info = 0 ! Ritz singular triplets computation. lanczos_iter : do k = 1 , kdim_ ! Lanczos bidiag. step. call bidiagonalization ( A , Uwrk , Vwrk , B , info , kstart = k , kend = k , tol = tol ) call check_info ( info , 'bidiagonalization' , module = this_module , procedure = 'svds_cdp' ) ! SVD of the k x k bidiagonal matrix and residual computation. svdvals_wrk = 0.0_dp ; umat = 0.0_dp ; vmat = 0.0_dp call svd ( B (: k , : k ), svdvals_wrk (: k ), umat (: k , : k ), vmat (: k , : k )) vmat (: k , : k ) = conjg ( transpose ( vmat (: k , : k ))) residuals_wrk (: k ) = compute_residual_cdp ( B ( k + 1 , k ), vmat ( k , : k )) ! Check for convergence. conv = count ( residuals_wrk (: k ) < tol ) write ( msg , '(I0,A,I0,A,I0,A)' ) conv , '/' , nsv , ' singular values converged after ' , k , & & ' iterations of the Lanczos process.' call logger % log_information ( msg , module = this_module , procedure = 'svds_cdp' ) if ( conv >= nsv ) exit lanczos_iter enddo lanczos_iter !-------------------------------- !-----     POST-PROCESS     ----- !-------------------------------- ! Singular values. S = svdvals_wrk (: nsv ) ; residuals = residuals_wrk (: nsv ) ! Singular vectors. k = min ( k , kdim_ ) ; info = k do i = 1 , nsv call U ( i )% zero () ; call V ( i )% zero () do j = 1 , k call U ( i )% axpby ( one_cdp , Uwrk ( j ), umat ( j , i )) call V ( i )% axpby ( one_cdp , Vwrk ( j ), vmat ( j , i )) enddo enddo return end subroutine svds_cdp !------------------------------------------------------- !-----     GENERALIZED MINIMUM RESIDUAL METHOD     ----- !------------------------------------------------------- subroutine gmres_rsp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_rsp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts ! Krylov subspace class ( abstract_vector_rsp ), allocatable :: V (:) ! Hessenberg matrix. real ( sp ), allocatable :: H (:, :) ! Least-squares variables. real ( sp ), allocatable :: y (:), e (:) real ( sp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_rsp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter real ( sp ), allocatable :: alpha (:) class ( abstract_vector_rsp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_sp allocate ( y ( kdim )) ; y = 0.0_sp allocate ( alpha ( kdim )) ; alpha = 0.0_sp allocate ( e ( kdim + 1 )) ; e = 0.0_sp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_rsp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_sp ; y = 0.0_sp ; e = 0.0_sp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_rsp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_rsp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rsp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_rsp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rsp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_rsp subroutine gmres_rdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_rdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts ! Krylov subspace class ( abstract_vector_rdp ), allocatable :: V (:) ! Hessenberg matrix. real ( dp ), allocatable :: H (:, :) ! Least-squares variables. real ( dp ), allocatable :: y (:), e (:) real ( dp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_rdp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter real ( dp ), allocatable :: alpha (:) class ( abstract_vector_rdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_dp allocate ( y ( kdim )) ; y = 0.0_dp allocate ( alpha ( kdim )) ; alpha = 0.0_dp allocate ( e ( kdim + 1 )) ; e = 0.0_dp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_rdp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_dp ; y = 0.0_dp ; e = 0.0_dp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_rdp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_rdp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rdp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_rdp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_rdp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_rdp subroutine gmres_csp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_csp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( sp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_sp_opts ) :: opts ! Krylov subspace class ( abstract_vector_csp ), allocatable :: V (:) ! Hessenberg matrix. complex ( sp ), allocatable :: H (:, :) ! Least-squares variables. complex ( sp ), allocatable :: y (:), e (:) complex ( sp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_csp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter complex ( sp ), allocatable :: alpha (:) class ( abstract_vector_csp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then select type ( options ) type is ( gmres_sp_opts ) opts = options end select else opts = gmres_sp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_sp allocate ( y ( kdim )) ; y = 0.0_sp allocate ( alpha ( kdim )) ; alpha = 0.0_sp allocate ( e ( kdim + 1 )) ; e = 0.0_sp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_csp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_sp ; y = 0.0_sp ; e = 0.0_sp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_csp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_csp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_csp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_csp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_csp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_csp subroutine gmres_cdp ( A , b , x , info , rtol , atol , preconditioner , options , transpose ) class ( abstract_linop_cdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (optional). class ( abstract_opts ), optional , intent ( in ) :: options !! GMRES options. logical , optional , intent ( in ) :: transpose !! Whether \\mathbf{A} or \\mathbf{A}&#94;H is being used. !-------------------------------------- !-----     Internal variables     ----- !-------------------------------------- ! Options. integer :: kdim , maxiter real ( dp ) :: tol , rtol_ , atol_ logical :: trans type ( gmres_dp_opts ) :: opts ! Krylov subspace class ( abstract_vector_cdp ), allocatable :: V (:) ! Hessenberg matrix. complex ( dp ), allocatable :: H (:, :) ! Least-squares variables. complex ( dp ), allocatable :: y (:), e (:) complex ( dp ) :: beta ! Preconditioner logical :: has_precond class ( abstract_precond_cdp ), allocatable :: precond ! Miscellaneous. integer :: i , k , niter complex ( dp ), allocatable :: alpha (:) class ( abstract_vector_cdp ), allocatable :: dx , wrk character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then select type ( options ) type is ( gmres_dp_opts ) opts = options end select else opts = gmres_dp_opts () endif kdim = opts % kdim ; maxiter = opts % maxiter tol = atol_ + rtol_ * b % norm () trans = optval ( transpose , . false .) ! Deals with the preconditioner. if ( present ( preconditioner )) then has_precond = . true . allocate ( precond , source = preconditioner ) else has_precond = . false . endif ! Initialize working variables. allocate ( wrk , source = b ) ; call wrk % zero () allocate ( V ( kdim + 1 ), source = b ) ; call zero_basis ( V ) allocate ( H ( kdim + 1 , kdim )) ; H = 0.0_dp allocate ( y ( kdim )) ; y = 0.0_dp allocate ( alpha ( kdim )) ; alpha = 0.0_dp allocate ( e ( kdim + 1 )) ; e = 0.0_dp info = 0 ; niter = 0 ! Initial Krylov vector. if ( x % norm () > 0 ) then if ( trans ) then call A % rmatvec ( x , V ( 1 )) else call A % matvec ( x , V ( 1 )) endif endif call V ( 1 )% sub ( b ) ; call V ( 1 )% chsgn () beta = V ( 1 )% norm () ; call V ( 1 )% scal ( one_cdp / beta ) ! Iterative solver. gmres_iter : do i = 1 , maxiter ! Zero-out variables. H = 0.0_dp ; y = 0.0_dp ; e = 0.0_dp ; e ( 1 ) = beta call zero_basis ( V ( 2 :)) ! Arnoldi factorization. arnoldi_fact : do k = 1 , kdim ! Preconditioner. wrk = V ( k ) ; if ( has_precond ) call precond % apply ( wrk ) ! Matrix-vector product. if ( trans ) then call A % rmatvec ( wrk , V ( k + 1 )) else call A % matvec ( wrk , V ( k + 1 )) endif ! Double Gram-Schmid orthogonalization call double_gram_schmidt_step ( V ( k + 1 ), V (: k ), info , if_chk_orthonormal = . false ., beta = H (: k , k )) call check_info ( info , 'double_gram_schmidt_step' , module = this_module , procedure = 'gmres_cdp' ) ! Update Hessenberg matrix and normalize residual Krylov vector. H ( k + 1 , k ) = V ( k + 1 )% norm () if ( abs ( H ( k + 1 , k )) > tol ) then call V ( k + 1 )% scal ( one_cdp / H ( k + 1 , k )) endif ! Least-squares problem. y (: k ) = lstsq ( H (: k + 1 , : k ), e (: k + 1 )) ! Compute residual. beta = norm2 ( abs ( e (: k + 1 ) - matmul ( H (: k + 1 , : k ), y (: k )))) ! Current number of iterations performed. niter = niter + 1 ! Check convergence. write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k)   inner step ' , k , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_cdp' ) if ( abs ( beta ) <= tol ) then exit arnoldi_fact endif enddo arnoldi_fact ! Update solution. k = min ( k , kdim ) ; call linear_combination ( dx , V (: k ), y (: k )) if ( has_precond ) call precond % apply ( dx ) ; call x % add ( dx ) ! Recompute residual for sanity check. if ( trans ) then call A % rmatvec ( x , v ( 1 )) else call A % matvec ( x , v ( 1 )) endif call v ( 1 )% sub ( b ) ; call v ( 1 )% chsgn () ! Initialize new starting Krylov vector if needed. beta = v ( 1 )% norm () ; call v ( 1 )% scal ( one_cdp / beta ) write ( msg , '(A,I3,2(A,E9.2))' ) 'GMRES(k) outer step   ' , i , ': |res|= ' , & & abs ( beta ), ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'gmres_cdp' ) ! Exit gmres if desired accuracy is reached. if ( abs ( beta ) <= tol ) exit gmres_iter enddo gmres_iter ! Returns the number of iterations. info = niter return end subroutine gmres_cdp !--------------------------------------------- !-----     CONJUGATE GRADIENT METHOD     ----- !--------------------------------------------- subroutine cg_rsp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_sym_linop_rsp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rsp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rsp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rsp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts ! Working variables. class ( abstract_vector_rsp ), allocatable :: r , p , Ap real ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_rsp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_rsp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_rsp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_rsp' ) enddo cg_loop return end subroutine cg_rsp subroutine cg_rdp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_sym_linop_rdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_rdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_rdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_rdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts ! Working variables. class ( abstract_vector_rdp ), allocatable :: r , p , Ap real ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_rdp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_rdp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( r_dot_r_new ) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_rdp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_rdp' ) enddo cg_loop return end subroutine cg_rdp subroutine cg_csp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_hermitian_linop_csp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_csp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_csp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( sp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( sp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_csp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_sp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( sp ) :: tol , rtol_ , atol_ type ( cg_sp_opts ) :: opts ! Working variables. class ( abstract_vector_csp ), allocatable :: r , p , Ap complex ( sp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( sp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_sp ) atol_ = optval ( atol , atol_sp ) if ( present ( options )) then opts = options else opts = cg_sp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_csp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_csp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_csp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_csp' ) enddo cg_loop return end subroutine cg_csp subroutine cg_cdp ( A , b , x , info , rtol , atol , preconditioner , options ) class ( abstract_hermitian_linop_cdp ), intent ( in ) :: A !! Linear operator to be inverted. class ( abstract_vector_cdp ), intent ( in ) :: b !! Right-hand side vector. class ( abstract_vector_cdp ), intent ( inout ) :: x !! Solution vector. integer , intent ( out ) :: info !! Information flag. real ( dp ), optional , intent ( in ) :: rtol !! Relative solver tolerance real ( dp ), optional , intent ( in ) :: atol !! Absolute solver tolerance class ( abstract_precond_cdp ), optional , intent ( in ) :: preconditioner !! Preconditioner (not yet supported). type ( cg_dp_opts ), optional , intent ( in ) :: options !! Options for the conjugate gradient solver. !---------------------------------------- !-----     Internal variables      ------ !---------------------------------------- ! Options. integer :: maxiter real ( dp ) :: tol , rtol_ , atol_ type ( cg_dp_opts ) :: opts ! Working variables. class ( abstract_vector_cdp ), allocatable :: r , p , Ap complex ( dp ) :: alpha , beta , r_dot_r_old , r_dot_r_new real ( dp ) :: residual ! Miscellaneous. integer :: i character ( len = 256 ) :: msg ! Deals with the optional args. rtol_ = optval ( rtol , rtol_dp ) atol_ = optval ( atol , atol_dp ) if ( present ( options )) then opts = options else opts = cg_dp_opts () endif tol = atol_ + rtol_ * b % norm () ; maxiter = opts % maxiter ! Initialize vectors. allocate ( r , source = b ) ; call r % zero () allocate ( p , source = b ) ; call p % zero () allocate ( Ap , source = b ) ; call Ap % zero () info = 0 ! Compute initial residual r = b - Ax. if ( x % norm () > 0 ) call A % matvec ( x , r ) call r % sub ( b ) ; call r % chsgn () ! Initialize direction vector. p = r ! Initialize dot product of residual r_dot_r_old = r' * r r_dot_r_old = r % dot ( r ) ! Conjugate gradient iteration. cg_loop : do i = 1 , maxiter ! Compute A @ p call A % matvec ( p , Ap ) ! Compute step size. alpha = r_dot_r_old / p % dot ( Ap ) ! Update solution x = x + alpha*p call x % axpby ( one_cdp , p , alpha ) ! Update residual r = r - alpha*Ap call r % axpby ( one_cdp , Ap , - alpha ) ! Compute new dot product of residual r_dot_r_new = r' * r. r_dot_r_new = r % dot ( r ) ! Check for convergence. residual = sqrt ( abs ( r_dot_r_new )) ! Current number of iterations performed. info = info + 1 if ( residual < tol ) exit cg_loop ! Compute new direction beta = r_dot_r_new / r_dot_r_old. beta = r_dot_r_new / r_dot_r_old ! Update direction p = beta*p + r call p % axpby ( beta , r , one_cdp ) ! Update r_dot_r_old for next iteration. r_dot_r_old = r_dot_r_new write ( msg , '(A,I3,2(A,E9.2))' ) 'CG step ' , i , ': res= ' , residual , ', tol= ' , tol call logger % log_information ( msg , module = this_module , procedure = 'cg_cdp' ) enddo cg_loop return end subroutine cg_cdp end module LightKrylov_IterativeSolvers","tags":"","loc":"sourcefile/iterativesolvers.f90.html"},{"title":"AbstractVectors.f90 – LightKrylov","text":"Source Code module LightKrylov_AbstractVectors !! This module provides the base class `absract_vector` from which all Krylov vectors !! needs to be derived. To use `LightKrylov`, you need to extend one of the !! followings: !! !! - `abstract_vector_rsp`: Real-valued vector with single precision arithmetic. !! - `abstract_vector_rdp`: Real-valued vector with double precision arithmetic. !! - `abstract_vector_csp`: Complex-valued vector with single precision arithmetic. !! - `abstract_vector_cdp`: Complex-valued vector with double precision arithmetic. !! !! To extend either of these abstract types, you need to provide an associated implementation !! for the following type-bound procedures: !! !! - `zero(self)`: A subroutine zeroing-out the vector. !! - `rand(self, ifnorm)`: A subroutine creating a random vector, possibily normalized to have unit-norm (`ifnorm = .true.`). !! - `scal(self, alpha)`: A subroutine computing *in-place* the scalar multiplication  \\mathbf{x} = \\alpha \\mathbf{x} . !! - `axpby(self, alpha, vec, beta)`: A subroutine computing *in-place* the product  \\mathbf{x} = \\alpha \\mathbf{x} + \\beta \\mathbf{y} . !! - `dot(self, vec)`: A function computing the inner product  \\alpha = \\langle \\mathbf{x} \\vert \\mathbf{y} \\rangle . !! - `get_size(self)`: A function returning the dimension  n  of the vector  \\mathbf{x} . !! !! Once these type-bound procedures have been implemented by the user, they will automatically !! be used to define: !! !! - vector addition `add(self, vec) = axpby(self, 1, vec, 1)` !! - vector subtraction `sub(self, vec) = axpby(self, 1, vec, -1)` !! - vector norm `norm(self) = sqrt(dot_product(self, self))`. !! !! This module also provides the following utility subroutines: !! !! - `innerprod(v, X, y)` and `innerprod(M, X, Y)`: Subroutine to compute the !! inner-product matrix/vector between a Krylov basis `X` and a Krylov vector !! (resp. basis) `y` (resp. `Y`). !! - `linear_combination(y, X, v)` and `linear_combination(Y, X, B)`: Subroutine to !! compute the linear combination  \\mathbf{y}_j = \\sum_{i=1}&#94;n \\mathbf{x}_i v_{ij} . !! - `axpby_basis(X, alpha, Y, beta)`: In-place computation of  \\mathbf{X} = \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  !! where  \\mathbf{X}  and  \\mathbf{Y}  are two arrays of `abstract_vector`s. !! - `zero_basis(X)`: Zero-out a collection of `abstract_vectors`. !! - `copy(out, from)`: Copy a collection of `abstract_vectors`. !! - `rand_basis(X, ifnorm)`: Create a collection of random `abstract_vectors`. If `ifnorm = .true.`, the vectors are normalized to have unit-norm. use stdlib_optval , only : optval use LightKrylov_Constants use LightKrylov_Utils use LightKrylov_Logger implicit none private character ( len = 128 ), parameter :: this_module = 'Lightkrylov_AbstractVectors' public :: innerprod public :: linear_combination public :: axpby_basis public :: zero_basis public :: copy public :: rand_basis interface innerprod !!  Compute the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{y}  or matrix !!   \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y} . !! !!  ### Description !! !!  This interface provides methods for computing the inner products between a basis !!  of `real` or `complex` vectors  \\mathbf{X}  and a single vector !!   \\mathbf{y}  or another basis  \\mathbf{Y} . Depending on the case, it !!  returns a one-dimensional array  \\mathbf{v}  or a two-dimensional array !!   \\mathbf{M}  with the same type as  \\mathbf{X} . !! !!  ### Example !! !!  The example below assumes that you have already extended the `abstract_vector_rdp` !!  class to define your own `my_real_vector` type. It then computes the inner product !!  vector  \\mathbf{v}  defined as  v_i = \\mathbf{x}_i&#94;H \\mathbf{y} . !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector)                :: y !!      real(dp), dimension(:), allocatable :: v !! !!      ! ... Part of your code where you initialize everything ... !! !!      call innerprod(v, X, y) !! !!      ! ... Rest of your code ... !!  ``` !! !!  Similarly, computing the matrix of inner products between two bases can be done !!  as shown below. !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !!      real(dp), dimension(:, :), allocatable :: M !! !!      ! ... Part of your code where you initialize everything ... !! !!      call innerprod(M, X, Y) !! !!      ! ... Rest of your code ... !!  ``` module procedure innerprod_vector_rsp module procedure innerprod_matrix_rsp module procedure innerprod_vector_rdp module procedure innerprod_matrix_rdp module procedure innerprod_vector_csp module procedure innerprod_matrix_csp module procedure innerprod_vector_cdp module procedure innerprod_matrix_cdp end interface interface linear_combination !!  Given a set of extended `abstract_vectors` and coefficients, return the corresponding !!  linear combinations. !! !!  ### Description !! !!  This interface provides methods for computing linear combinations of a set of extended !!  `abstract_vectors`. Depending on its input, it either computes !! !!   !!      \\mathbf{y} = \\sum_{i=1}&#94;n \\alpha_i \\mathbf{x}_i, !!   !! !!  i.e. a single vector, or !! !!   !!      \\mathbf{y}_j = \\sum_{i=1}&#94;n \\alpha_{ij} \\mathbf{x}_i, !!   !! !!  i.e. a set of vectors of the same type as  \\mathbf{X} . !! !!  ### Example !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      real(dp), dimension(m, n)           :: B !!      type(my_real_vector)                :: Y !! !!      ! ... Whatever your code is doing ... !! !!      call linear_combination(Y, X, B) !! !!      ! ... Rest of your code ... !!  ``` module procedure linear_combination_vector_rsp module procedure linear_combination_matrix_rsp module procedure linear_combination_vector_rdp module procedure linear_combination_matrix_rdp module procedure linear_combination_vector_csp module procedure linear_combination_matrix_csp module procedure linear_combination_vector_cdp module procedure linear_combination_matrix_cdp end interface interface axpby_basis !!  In-place addition of two arrays of extended `abstract_vector`. !! !!  ### Description !! !!  This interface provides methods to add in-place two arrays of !!  extended `abstract_vector`, i.e. !! !!   !!      \\mathbf{x}_i \\leftarrow \\alpha_i \\mathbf{x}_i + \\beta_i \\mathbf{y}_i. !!   !! !!  No out-of-place alternative is currently available in `LightKrylov`. !!  If you do need an out-of-place version, you can combine `axpby_basis` !!  with `copy`. !! !!  ### Example !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !!      real(dp), dimension(10)             :: alpha, beta !! !!      ! ... Whatever your code is doing ... !! !!      call axpby_basis(X, alpha, Y, beta) !! !!      ! ... Rest of your code ... !!  ``` module procedure axpby_basis_rsp module procedure axpby_basis_rdp module procedure axpby_basis_csp module procedure axpby_basis_cdp end interface interface zero_basis !!  This interface provides methods to zero-out a collection of `abstract_vector` `X`. !!  It is a simple wrapper around `X(i)%zero()`. !! !!  ### Example !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !! !!      ! ... Your code ... !! !!      call zero_basis(X) !! !!      ! ... Your code ... !!  ``` module procedure zero_basis_rsp module procedure zero_basis_rdp module procedure zero_basis_csp module procedure zero_basis_cdp end interface interface copy !!  This interface provides methods to copy an array `X` of `abstract_vector` into !!  another array `Y`. Note that `Y` needs to be pre-allocated. !! !!  ### Example !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      type(my_real_vector), dimension(10) :: Y !! !!      ! ... Your code ... !! !!      call copy(Y, X) !! !!      ! ... Your code ... !!  ``` module procedure copy_vector_rsp module procedure copy_basis_rsp module procedure copy_vector_rdp module procedure copy_basis_rdp module procedure copy_vector_csp module procedure copy_basis_csp module procedure copy_vector_cdp module procedure copy_basis_cdp end interface interface rand_basis !!  This interface provides methods to create an array `X` of random `abstract_vector`. !!  It is a simple wrapper around `X(i)%rand(ifnorm)`. !! !!  ### Example !! !!  ``` !!      type(my_real_vector), dimension(10) :: X !!      logical                             :: ifnorm = .true. !! !!      ! ... Your code ... !! !!      call rand_basis(X, ifnorm) !! !!      ! ... Your code ... !!  ``` module procedure rand_basis_rsp module procedure rand_basis_rdp module procedure rand_basis_csp module procedure rand_basis_cdp end interface type , abstract , public :: abstract_vector !!  Base abstract type from which all other types of vectors used in `LightKrylov` !!  are being derived from. !! !!  @warning !!  Users should not extend this abstract class to define their own types. !!  @endwarning end type abstract_vector !---------------------------------------------------------------------------- !-----     Definition of an abstract real(sp) vector with kind=sp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_rsp !!  Abstract type to define real(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rsp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rsp` to zero. procedure ( abstract_rand_rsp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rsp`. procedure ( abstract_scal_rsp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rsp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{x} = \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rsp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rsp`. procedure ( abstract_get_size_rsp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rsp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rsp !! Adds two `abstract_vector`. procedure , pass ( self ), public :: sub => sub_rsp !! Subtracts two `abstract_vector`. procedure , pass ( self ), public :: chsgn => chsgn_rsp end type abstract interface subroutine abstract_zero_rsp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_rsp class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_rsp subroutine abstract_rand_rsp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_rsp class ( abstract_vector_rsp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_rsp subroutine abstract_scal_rsp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_rsp , sp class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. real ( sp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_rsp subroutine abstract_axpby_rsp ( self , alpha , vec , beta ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_rsp , sp class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be added/subtracted. real ( sp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_rsp function abstract_dot_rsp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_rsp , sp class ( abstract_vector_rsp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. real ( sp ) :: alpha !! Result of the dot product. end function abstract_dot_rsp function abstract_get_size_rsp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_rsp class ( abstract_vector_rsp ), intent ( in ) :: self !! Vectors whose dot product will be computed. integer :: N !! Size of the vector end function abstract_get_size_rsp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract real(dp) vector with kind=dp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_rdp !!  Abstract type to define real(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_rdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_rdp` to zero. procedure ( abstract_rand_rdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_rdp`. procedure ( abstract_scal_rdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_rdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{x} = \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_rdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_rdp`. procedure ( abstract_get_size_rdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_rdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_rdp !! Adds two `abstract_vector`. procedure , pass ( self ), public :: sub => sub_rdp !! Subtracts two `abstract_vector`. procedure , pass ( self ), public :: chsgn => chsgn_rdp end type abstract interface subroutine abstract_zero_rdp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_rdp class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_rdp subroutine abstract_rand_rdp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_rdp class ( abstract_vector_rdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_rdp subroutine abstract_scal_rdp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_rdp , dp class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. real ( dp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_rdp subroutine abstract_axpby_rdp ( self , alpha , vec , beta ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_rdp , dp class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be added/subtracted. real ( dp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_rdp function abstract_dot_rdp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_rdp , dp class ( abstract_vector_rdp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. real ( dp ) :: alpha !! Result of the dot product. end function abstract_dot_rdp function abstract_get_size_rdp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_rdp class ( abstract_vector_rdp ), intent ( in ) :: self !! Vectors whose dot product will be computed. integer :: N !! Size of the vector end function abstract_get_size_rdp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract complex(sp) vector with kind=sp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_csp !!  Abstract type to define complex(sp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_csp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_csp` to zero. procedure ( abstract_rand_csp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_csp`. procedure ( abstract_scal_csp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_csp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{x} = \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_csp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_csp`. procedure ( abstract_get_size_csp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_csp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_csp !! Adds two `abstract_vector`. procedure , pass ( self ), public :: sub => sub_csp !! Subtracts two `abstract_vector`. procedure , pass ( self ), public :: chsgn => chsgn_csp end type abstract interface subroutine abstract_zero_csp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_csp class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_csp subroutine abstract_rand_csp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_csp class ( abstract_vector_csp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_csp subroutine abstract_scal_csp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_csp , sp class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. complex ( sp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_csp subroutine abstract_axpby_csp ( self , alpha , vec , beta ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_csp , sp class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be added/subtracted. complex ( sp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_csp function abstract_dot_csp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_csp , sp class ( abstract_vector_csp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. complex ( sp ) :: alpha !! Result of the dot product. end function abstract_dot_csp function abstract_get_size_csp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_csp class ( abstract_vector_csp ), intent ( in ) :: self !! Vectors whose dot product will be computed. integer :: N !! Size of the vector end function abstract_get_size_csp end interface !---------------------------------------------------------------------------- !-----     Definition of an abstract complex(dp) vector with kind=dp     ----- !---------------------------------------------------------------------------- type , abstract , extends ( abstract_vector ), public :: abstract_vector_cdp !!  Abstract type to define complex(dp)-valued vectors. !!  Derived-types defined by the user should be extending one such class. contains private procedure ( abstract_zero_cdp ), pass ( self ), deferred , public :: zero !! Sets an `abstract_vector_cdp` to zero. procedure ( abstract_rand_cdp ), pass ( self ), deferred , public :: rand !! Creates a random `abstract_vector_cdp`. procedure ( abstract_scal_cdp ), pass ( self ), deferred , public :: scal !! Compute the scalar-vector product. procedure ( abstract_axpby_cdp ), pass ( self ), deferred , public :: axpby !! In-place computation of  \\mathbf{x} = \\alpha \\mathbf{x} + \\beta \\mathbf{y} . procedure ( abstract_dot_cdp ), pass ( self ), deferred , public :: dot !! Computes the dot product between two `abstract_vector_cdp`. procedure ( abstract_get_size_cdp ), pass ( self ), deferred , public :: get_size !! Return size of specific abstract vector procedure , pass ( self ), public :: norm => norm_cdp !! Computes the norm of the `abstract_vector`. procedure , pass ( self ), public :: add => add_cdp !! Adds two `abstract_vector`. procedure , pass ( self ), public :: sub => sub_cdp !! Subtracts two `abstract_vector`. procedure , pass ( self ), public :: chsgn => chsgn_cdp end type abstract interface subroutine abstract_zero_cdp ( self ) !! Abstract interface to zero-out a vector in-place. import abstract_vector_cdp class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector to be zeroed-out. end subroutine abstract_zero_cdp subroutine abstract_rand_cdp ( self , ifnorm ) !! Abstract interface to generate a random (normalized) vector. import abstract_vector_cdp class ( abstract_vector_cdp ), intent ( inout ) :: self logical , optional , intent ( in ) :: ifnorm end subroutine abstract_rand_cdp subroutine abstract_scal_cdp ( self , alpha ) !! Abstract interface to scale a vector. import abstract_vector_cdp , dp class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. complex ( dp ), intent ( in ) :: alpha !! Scaling factor. end subroutine abstract_scal_cdp subroutine abstract_axpby_cdp ( self , alpha , vec , beta ) !! Abstract interface to add/scale two vectors in-place. import abstract_vector_cdp , dp class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be added/subtracted. complex ( dp ), intent ( in ) :: alpha , beta end subroutine abstract_axpby_cdp function abstract_dot_cdp ( self , vec ) result ( alpha ) !! Abstract interface to compute the dot product. import abstract_vector_cdp , dp class ( abstract_vector_cdp ), intent ( in ) :: self , vec !! Vectors whose dot product will be computed. complex ( dp ) :: alpha !! Result of the dot product. end function abstract_dot_cdp function abstract_get_size_cdp ( self ) result ( N ) !! Abstract interface to return the size of the specific abstract vector. import abstract_vector_cdp class ( abstract_vector_cdp ), intent ( in ) :: self !! Vectors whose dot product will be computed. integer :: N !! Size of the vector end function abstract_get_size_cdp end interface contains function norm_rsp ( self ) result ( alpha ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_rsp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( sp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_rsp subroutine sub_rsp ( self , vec ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rsp , vec , - one_rsp ) end subroutine sub_rsp subroutine add_rsp ( self , vec ) !! Add two `abstract_vector` in-place. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rsp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rsp , vec , one_rsp ) end subroutine add_rsp subroutine chsgn_rsp ( self ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_rsp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_rsp ) end subroutine chsgn_rsp function norm_rdp ( self ) result ( alpha ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_rdp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( dp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_rdp subroutine sub_rdp ( self , vec ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rdp , vec , - one_rdp ) end subroutine sub_rdp subroutine add_rdp ( self , vec ) !! Add two `abstract_vector` in-place. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_rdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_rdp , vec , one_rdp ) end subroutine add_rdp subroutine chsgn_rdp ( self ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_rdp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_rdp ) end subroutine chsgn_rdp function norm_csp ( self ) result ( alpha ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_csp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( sp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_csp subroutine sub_csp ( self , vec ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_csp , vec , - one_csp ) end subroutine sub_csp subroutine add_csp ( self , vec ) !! Add two `abstract_vector` in-place. class ( abstract_vector_csp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_csp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_csp , vec , one_csp ) end subroutine add_csp subroutine chsgn_csp ( self ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_csp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_csp ) end subroutine chsgn_csp function norm_cdp ( self ) result ( alpha ) !! Compute the norm of an `abstract_vector`. class ( abstract_vector_cdp ), intent ( in ) :: self !! Vector whose norm needs to be computed. real ( dp ) :: alpha !! Norm of the vector. alpha = abs ( self % dot ( self )) ; alpha = sqrt ( alpha ) end function norm_cdp subroutine sub_cdp ( self , vec ) !! Subtract two `abstract_vector` in-place. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_cdp , vec , - one_cdp ) end subroutine sub_cdp subroutine add_cdp ( self , vec ) !! Add two `abstract_vector` in-place. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Input/Output vector. class ( abstract_vector_cdp ), intent ( in ) :: vec !! Vector to be added. call self % axpby ( one_cdp , vec , one_cdp ) end subroutine add_cdp subroutine chsgn_cdp ( self ) !! Changes the sign of the `abstract_vector`. class ( abstract_vector_cdp ), intent ( inout ) :: self !! Vector whose entries need to change sign. call self % scal ( - one_cdp ) end subroutine chsgn_cdp !-------------------------------------- !-----      UTILITY FUNCTIONS     ----- !-------------------------------------- subroutine linear_combination_vector_rsp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. class ( abstract_vector_rsp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Krylov basis. real ( sp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & module = this_module , procedure = 'linear_combination_vector_rsp' ) endif ! Initialize output vector. if (. not . allocated ( y )) allocate ( y , source = X ( 1 )) ; call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( one_rsp , X ( i ), v ( i )) enddo return end subroutine linear_combination_vector_rsp subroutine linear_combination_matrix_rsp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. class ( abstract_vector_rsp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_rsp ), intent ( in ) :: X (:) !! Krylov basis. real ( sp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_rsp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 )) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_rsp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( one_rsp , X ( i ), B ( i , j )) enddo enddo return end subroutine linear_combination_matrix_rsp subroutine innerprod_vector_rsp ( v , X , y ) !! Computes the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. class ( abstract_vector_rsp ), intent ( in ) :: X (:), y !! Bases of `abstract_vector` whose inner products need to be computed. real ( sp ), intent ( out ) :: v ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i v = zero_rsp do i = 1 , size ( X ) v ( i ) = X ( i )% dot ( y ) enddo return end subroutine innerprod_vector_rsp subroutine innerprod_matrix_rsp ( M , X , Y ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. class ( abstract_vector_rsp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. real ( sp ), intent ( out ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_rsp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo return end subroutine innerprod_matrix_rsp subroutine axpby_basis_rsp ( x , alpha , y , beta ) !! Compute in-place  \\mathbf{X} = \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are real(sp) !! numbers. class ( abstract_vector_rsp ), intent ( inout ) :: X (:) !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_rsp ), intent ( in ) :: Y (:) !! Array of `abstract_vector` to be added/subtracted to `X`. real ( sp ), intent ( in ) :: alpha , beta !! Scalar multipliers. ! Internal variable. integer :: i ! Check size. if ( size ( X ) /= size ( Y )) then call stop_error ( \"X and Y have incompatible dimensions.\" , & & module = this_module , procedure = 'axpby_basis_rsp' ) endif ! Add basis. do i = 1 , size ( X ) call X ( i )% axpby ( alpha , Y ( i ), beta ) enddo return end subroutine axpby_basis_rsp subroutine zero_basis_rsp ( X ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% zero () end do return end subroutine zero_basis_rsp subroutine copy_vector_rsp ( out , from ) class ( abstract_vector_rsp ), intent ( in ) :: from class ( abstract_vector_rsp ), intent ( out ) :: out ! Copy array. call out % axpby ( zero_rsp , from , one_rsp ) return end subroutine copy_vector_rsp subroutine copy_basis_rsp ( out , from ) class ( abstract_vector_rsp ), intent ( in ) :: from (:) class ( abstract_vector_rsp ), intent ( out ) :: out (:) integer :: i ! Check size. if ( size ( out ) /= size ( from )) then call stop_error ( \"from and out have incompatible dimensions.\" , & & module = this_module , procedure = 'copy_basis_rsp' ) endif ! Copy array. do i = 1 , size ( out ) call copy_vector_rsp ( out ( i ), from ( i )) enddo return end subroutine copy_basis_rsp subroutine rand_basis_rsp ( X , ifnorm ) class ( abstract_vector_rsp ), intent ( inout ) :: X (:) logical , optional , intent ( in ) :: ifnorm ! internal integer :: i do i = 1 , size ( X ) call X ( i )% rand ( ifnorm = ifnorm ) end do return end subroutine rand_basis_rsp subroutine linear_combination_vector_rdp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. class ( abstract_vector_rdp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Krylov basis. real ( dp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & module = this_module , procedure = 'linear_combination_vector_rdp' ) endif ! Initialize output vector. if (. not . allocated ( y )) allocate ( y , source = X ( 1 )) ; call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( one_rdp , X ( i ), v ( i )) enddo return end subroutine linear_combination_vector_rdp subroutine linear_combination_matrix_rdp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. class ( abstract_vector_rdp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_rdp ), intent ( in ) :: X (:) !! Krylov basis. real ( dp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_rdp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 )) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_rdp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( one_rdp , X ( i ), B ( i , j )) enddo enddo return end subroutine linear_combination_matrix_rdp subroutine innerprod_vector_rdp ( v , X , y ) !! Computes the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. class ( abstract_vector_rdp ), intent ( in ) :: X (:), y !! Bases of `abstract_vector` whose inner products need to be computed. real ( dp ), intent ( out ) :: v ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i v = zero_rdp do i = 1 , size ( X ) v ( i ) = X ( i )% dot ( y ) enddo return end subroutine innerprod_vector_rdp subroutine innerprod_matrix_rdp ( M , X , Y ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. class ( abstract_vector_rdp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. real ( dp ), intent ( out ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_rdp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo return end subroutine innerprod_matrix_rdp subroutine axpby_basis_rdp ( x , alpha , y , beta ) !! Compute in-place  \\mathbf{X} = \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are real(dp) !! numbers. class ( abstract_vector_rdp ), intent ( inout ) :: X (:) !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_rdp ), intent ( in ) :: Y (:) !! Array of `abstract_vector` to be added/subtracted to `X`. real ( dp ), intent ( in ) :: alpha , beta !! Scalar multipliers. ! Internal variable. integer :: i ! Check size. if ( size ( X ) /= size ( Y )) then call stop_error ( \"X and Y have incompatible dimensions.\" , & & module = this_module , procedure = 'axpby_basis_rdp' ) endif ! Add basis. do i = 1 , size ( X ) call X ( i )% axpby ( alpha , Y ( i ), beta ) enddo return end subroutine axpby_basis_rdp subroutine zero_basis_rdp ( X ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% zero () end do return end subroutine zero_basis_rdp subroutine copy_vector_rdp ( out , from ) class ( abstract_vector_rdp ), intent ( in ) :: from class ( abstract_vector_rdp ), intent ( out ) :: out ! Copy array. call out % axpby ( zero_rdp , from , one_rdp ) return end subroutine copy_vector_rdp subroutine copy_basis_rdp ( out , from ) class ( abstract_vector_rdp ), intent ( in ) :: from (:) class ( abstract_vector_rdp ), intent ( out ) :: out (:) integer :: i ! Check size. if ( size ( out ) /= size ( from )) then call stop_error ( \"from and out have incompatible dimensions.\" , & & module = this_module , procedure = 'copy_basis_rdp' ) endif ! Copy array. do i = 1 , size ( out ) call copy_vector_rdp ( out ( i ), from ( i )) enddo return end subroutine copy_basis_rdp subroutine rand_basis_rdp ( X , ifnorm ) class ( abstract_vector_rdp ), intent ( inout ) :: X (:) logical , optional , intent ( in ) :: ifnorm ! internal integer :: i do i = 1 , size ( X ) call X ( i )% rand ( ifnorm = ifnorm ) end do return end subroutine rand_basis_rdp subroutine linear_combination_vector_csp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. class ( abstract_vector_csp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Krylov basis. complex ( sp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & module = this_module , procedure = 'linear_combination_vector_csp' ) endif ! Initialize output vector. if (. not . allocated ( y )) allocate ( y , source = X ( 1 )) ; call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( one_csp , X ( i ), v ( i )) enddo return end subroutine linear_combination_vector_csp subroutine linear_combination_matrix_csp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. class ( abstract_vector_csp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_csp ), intent ( in ) :: X (:) !! Krylov basis. complex ( sp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_csp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 )) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_csp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( one_csp , X ( i ), B ( i , j )) enddo enddo return end subroutine linear_combination_matrix_csp subroutine innerprod_vector_csp ( v , X , y ) !! Computes the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. class ( abstract_vector_csp ), intent ( in ) :: X (:), y !! Bases of `abstract_vector` whose inner products need to be computed. complex ( sp ), intent ( out ) :: v ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i v = zero_csp do i = 1 , size ( X ) v ( i ) = X ( i )% dot ( y ) enddo return end subroutine innerprod_vector_csp subroutine innerprod_matrix_csp ( M , X , Y ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. class ( abstract_vector_csp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. complex ( sp ), intent ( out ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_csp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo return end subroutine innerprod_matrix_csp subroutine axpby_basis_csp ( x , alpha , y , beta ) !! Compute in-place  \\mathbf{X} = \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are complex(sp) !! numbers. class ( abstract_vector_csp ), intent ( inout ) :: X (:) !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_csp ), intent ( in ) :: Y (:) !! Array of `abstract_vector` to be added/subtracted to `X`. complex ( sp ), intent ( in ) :: alpha , beta !! Scalar multipliers. ! Internal variable. integer :: i ! Check size. if ( size ( X ) /= size ( Y )) then call stop_error ( \"X and Y have incompatible dimensions.\" , & & module = this_module , procedure = 'axpby_basis_csp' ) endif ! Add basis. do i = 1 , size ( X ) call X ( i )% axpby ( alpha , Y ( i ), beta ) enddo return end subroutine axpby_basis_csp subroutine zero_basis_csp ( X ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% zero () end do return end subroutine zero_basis_csp subroutine copy_vector_csp ( out , from ) class ( abstract_vector_csp ), intent ( in ) :: from class ( abstract_vector_csp ), intent ( out ) :: out ! Copy array. call out % axpby ( zero_csp , from , one_csp ) return end subroutine copy_vector_csp subroutine copy_basis_csp ( out , from ) class ( abstract_vector_csp ), intent ( in ) :: from (:) class ( abstract_vector_csp ), intent ( out ) :: out (:) integer :: i ! Check size. if ( size ( out ) /= size ( from )) then call stop_error ( \"from and out have incompatible dimensions.\" , & & module = this_module , procedure = 'copy_basis_csp' ) endif ! Copy array. do i = 1 , size ( out ) call copy_vector_csp ( out ( i ), from ( i )) enddo return end subroutine copy_basis_csp subroutine rand_basis_csp ( X , ifnorm ) class ( abstract_vector_csp ), intent ( inout ) :: X (:) logical , optional , intent ( in ) :: ifnorm ! internal integer :: i do i = 1 , size ( X ) call X ( i )% rand ( ifnorm = ifnorm ) end do return end subroutine rand_basis_csp subroutine linear_combination_vector_cdp ( y , X , v ) !! Given `X` and `v`, this function return  \\mathbf{y} = \\mathbf{Xv}  where !! `y` is an `abstract_vector`, `X` an array of `abstract_vector` and `v` a !! Fortran array containing the coefficients of the linear combination. class ( abstract_vector_cdp ), allocatable , intent ( out ) :: y !! Ouput vector. class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Krylov basis. complex ( dp ), intent ( in ) :: v (:) !! Coordinates of `y` in the Krylov basis `X`. ! Internal variables integer :: i ! Check sizes. if ( size ( X ) /= size ( v )) then call stop_error ( \"Krylov basis X and low-dimensional vector v have different sizes.\" , & & module = this_module , procedure = 'linear_combination_vector_cdp' ) endif ! Initialize output vector. if (. not . allocated ( y )) allocate ( y , source = X ( 1 )) ; call y % zero () ! Compute linear combination. do i = 1 , size ( X ) call y % axpby ( one_cdp , X ( i ), v ( i )) enddo return end subroutine linear_combination_vector_cdp subroutine linear_combination_matrix_cdp ( Y , X , B ) !! Given `X` and `B`, this function computes \\mathbf{Y} = \\mathbf{XB}  where !! `X` and `Y` are arrays of `abstract_vector`, and `B` is a 2D Fortran array. class ( abstract_vector_cdp ), allocatable , intent ( out ) :: Y (:) !! Output matrix. class ( abstract_vector_cdp ), intent ( in ) :: X (:) !! Krylov basis. complex ( dp ), intent ( in ) :: B (:, :) !! Coefficients of the linear combinations. ! Internal variables. integer :: i , j ! Check sizes. if ( size ( X ) /= size ( B , 1 )) then call stop_error ( \"Krylov basis X and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_cdp' ) endif ! Initialize output basis. if (. not . allocated ( Y )) then allocate ( Y ( size ( B , 2 )), source = X ( 1 )) else if ( size ( Y ) /= size ( B , 2 )) then call stop_error ( \"Krylov basis Y and combination matrix B have incompatible sizes.\" , & & module = this_module , procedure = 'linear_combination_matrix_cdp' ) endif endif do j = 1 , size ( Y ) call Y ( j )% zero () do i = 1 , size ( X ) call Y ( j )% axpby ( one_cdp , X ( i ), B ( i , j )) enddo enddo return end subroutine linear_combination_matrix_cdp subroutine innerprod_vector_cdp ( v , X , y ) !! Computes the inner product vector  \\mathbf{v} = \\mathbf{X}&#94;H \\mathbf{v}  between !! a basis `X` of `abstract_vector` and `v`, a single `abstract_vector`. class ( abstract_vector_cdp ), intent ( in ) :: X (:), y !! Bases of `abstract_vector` whose inner products need to be computed. complex ( dp ), intent ( out ) :: v ( size ( X )) !! Resulting inner-product vector. ! Local variables. integer :: i v = zero_cdp do i = 1 , size ( X ) v ( i ) = X ( i )% dot ( y ) enddo return end subroutine innerprod_vector_cdp subroutine innerprod_matrix_cdp ( M , X , Y ) !! Computes the inner product matrix  \\mathbf{M} = \\mathbf{X}&#94;H \\mathbf{Y}  between !! two bases of `abstract_vector`. class ( abstract_vector_cdp ), intent ( in ) :: X (:), Y (:) !! Bases of `abstract_vector` whose inner products need to be computed. complex ( dp ), intent ( out ) :: M ( size ( X ), size ( Y )) !! Resulting inner-product matrix. ! Local variables. integer :: i , j M = zero_cdp do j = 1 , size ( Y ) do i = 1 , size ( X ) M ( i , j ) = X ( i )% dot ( Y ( j )) enddo enddo return end subroutine innerprod_matrix_cdp subroutine axpby_basis_cdp ( x , alpha , y , beta ) !! Compute in-place  \\mathbf{X} = \\alpha \\mathbf{X} + \\beta \\mathbf{Y}  where !! `X` and `Y` are arrays of `abstract_vector` and `alpha` and `beta` are complex(dp) !! numbers. class ( abstract_vector_cdp ), intent ( inout ) :: X (:) !! Input/Ouput array of `abstract_vector`. class ( abstract_vector_cdp ), intent ( in ) :: Y (:) !! Array of `abstract_vector` to be added/subtracted to `X`. complex ( dp ), intent ( in ) :: alpha , beta !! Scalar multipliers. ! Internal variable. integer :: i ! Check size. if ( size ( X ) /= size ( Y )) then call stop_error ( \"X and Y have incompatible dimensions.\" , & & module = this_module , procedure = 'axpby_basis_cdp' ) endif ! Add basis. do i = 1 , size ( X ) call X ( i )% axpby ( alpha , Y ( i ), beta ) enddo return end subroutine axpby_basis_cdp subroutine zero_basis_cdp ( X ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) integer :: i do i = 1 , size ( X ) call X ( i )% zero () end do return end subroutine zero_basis_cdp subroutine copy_vector_cdp ( out , from ) class ( abstract_vector_cdp ), intent ( in ) :: from class ( abstract_vector_cdp ), intent ( out ) :: out ! Copy array. call out % axpby ( zero_cdp , from , one_cdp ) return end subroutine copy_vector_cdp subroutine copy_basis_cdp ( out , from ) class ( abstract_vector_cdp ), intent ( in ) :: from (:) class ( abstract_vector_cdp ), intent ( out ) :: out (:) integer :: i ! Check size. if ( size ( out ) /= size ( from )) then call stop_error ( \"from and out have incompatible dimensions.\" , & & module = this_module , procedure = 'copy_basis_cdp' ) endif ! Copy array. do i = 1 , size ( out ) call copy_vector_cdp ( out ( i ), from ( i )) enddo return end subroutine copy_basis_cdp subroutine rand_basis_cdp ( X , ifnorm ) class ( abstract_vector_cdp ), intent ( inout ) :: X (:) logical , optional , intent ( in ) :: ifnorm ! internal integer :: i do i = 1 , size ( X ) call X ( i )% rand ( ifnorm = ifnorm ) end do return end subroutine rand_basis_cdp end module LightKrylov_AbstractVectors","tags":"","loc":"sourcefile/abstractvectors.f90.html"},{"title":"Utils.f90 – LightKrylov","text":"Source Code module LightKrylov_utils !!  This module provides a set of utility functions used throughout `LightKrylov`. !!  It includes: !! !!  - `assert_shape`: Assert that the shape of the argument is the expected shape. !!  - `eig`: Compute the eigenvalue decomposition of a general matrix. !!  - `sqrtm`: Compute the non-negative square root of a symmetric positive definite matrix using its SVD. !!  - `sqrtm_eig`: Compute the non-negative square root of a symmetric positive definite matrix using its eigenvalue decomposition. !!  - `schur`: Compute the Schur factorization of a general square matrix. !!  - `ordschur`: Re-order the Schur factorization to have the selected eigenvalues in the upper left block. !! !!  Note that as the development of `stdlib` progresses, some of these functions !!  will be deprecated in favor of the `stdlib` implementations. !-------------------------------------------- !-----     Standard Fortran Library     ----- !-------------------------------------------- use iso_fortran_env , only : output_unit use stdlib_linalg , only : is_hermitian , is_symmetric , diag , svd , eigh ! Eigenvalue problem. use stdlib_linalg_lapack , only : geev ! Schur factorization. use stdlib_linalg_lapack , only : gees , trsen !------------------------------- !-----     LightKrylov     ----- !------------------------------- ! Various constants. use LightKrylov_Logger use LightKrylov_Constants implicit none private character ( len = 128 ), parameter :: this_module = 'LightKrylov_Utils' public :: assert_shape , norml , log2 ! Compute AX = XD for general dense matrices. public :: eig ! Compute matrix sqrt of input symmetric/hermitian positive definite matrix A public :: sqrtm public :: sqrtm_eig ! Compute AX = XS where S is in Schur form. public :: schur ! Re-orders the Schur factorization of A. public :: ordschur interface assert_shape !! This interface provides methods to assert that the shape of its input vector !! or matrix is the expected shape. It throws an error if not. module procedure assert_shape_vector_rsp module procedure assert_shape_matrix_rsp module procedure assert_shape_vector_rdp module procedure assert_shape_matrix_rdp module procedure assert_shape_vector_csp module procedure assert_shape_matrix_csp module procedure assert_shape_vector_cdp module procedure assert_shape_matrix_cdp end interface interface norml !! This interface provides methods to compute the infinity norm of a matrix. !! Note that it'll eventually be superseeded by the `stdlib` implementation. module procedure norml_rsp module procedure norml_rdp module procedure norml_csp module procedure norml_cdp end interface interface log2 !! Utility function to compute the base-2 logarithm of a real number. module procedure log2_rsp module procedure log2_rdp end interface interface eig !!  Computes the eigenvalue decomposition of a general square matrix. !! !!  ### Description !! !!  This interface provides methods to compute the solution to the eigenproblem !!   \\mathbf{Ax} = \\lambda \\mathbf{x} , where $\\mathbf{A}$ is a square `real` !!  or `complex` matrix. !! !!  Result array `lambda` returns the eigenvalues of  \\mathbf{A} , while `vecs` !!  returns the corresponding eigenvectors. Note that it follows the LAPACK convention !!  when  \\mathbf{A}  is `real`. The solver is based on LAPACK's `*GEEV` backends. !! !!  ### Syntax !! !!  `call eig(A, vecs, lambda)` !! !!  ### Arguments !! !!  `A`: `real` or `complex` square array containing the coefficient matrix. It is an `intent(in)` argument. !! !!  `vecs`: Square array of the same size, type, and kind as `A` containing the eigenvectors !!  (following LAPACK's convention for `real` matrices). It is an `intent(out)` argument. !! !!  `lambda`: `complex` rank-1 array of the same kind as `A` containing the eigenvalues. !!  It is an `intent(out)` argument. !! !!  @note !!  Due to the abstrct nature of the vector types defined in `LightKrylov`, it is unlikely !!  that this implementation will be superseeded in favor of the `stdlib` one as the latter !!  does not follow the LAPACK's convention. !!  @endnote module procedure eig_rsp module procedure eig_rdp module procedure eig_csp module procedure eig_cdp end interface interface schur !!  Computes the Schur factorization of a general square matrix. !! !!  ### Description !! !!  This interface provides methods to compute the Schur factorization of a `real` or !!  `complex` square matrix. Note that, if  \\mathbf{A}  is `real`, it returns the !!  real Schur form. !! !!  Result array `eigvals` returns the eigenvalues of  \\mathbf{A}  while `Z` !!  contains the Schur basis. !! !!  ### Syntax !! !!  `call schur(A, Z, eigvals)` !! !!  ### Arguments !! !!  `A`: `real` or `complex` square array containing the coefficient matrix. On exit, it !!  is overwritten with its (real) Schur factorization. It is an `intent(inout)` argument. !! !!  `Z`: Two-dimensional square array of the same size, type and kind as `A`. It contains !!  the Schur basis. It is an `intent(out)` argument. !! !!  `eigvals`: `complex` rank-1 array of the same kind as `A` containing the eigenvalues. !!  It is an `intent(out)` arguement. module procedure schur_rsp module procedure schur_rdp module procedure schur_csp module procedure schur_cdp end interface interface ordschur !!  Given the Schur factorization and basis of a matrix, reorders it to have the selected !!  eigenvalues in the upper left block. !! !!  ### Description !! !!  This interface provides methods to re-order the Schur factorization of a `real` or !!  `complex` square matrix. Note that, if  \\mathbf{A}  is `real`, it returns the !!  real Schur form. !! !!  ### Syntax !! !!  `call ordschur(T, Q, selected)` !! !!  ### Arguments !! !!  `T`: `real` or `complex` square array containing the Schur factorization of a matrix. !!  On exit, it is overwritten with its re-ordered counterpart. It is an `intent(inout)` argument. !! !!  `Q`: Two-dimensional square array of the same size, type and kind as `A`. It contains !!  the original Schur basis on entry and the re-ordered one on exit. !!  It is an `intent(inout)` argument. !! !!  `selected`: `logical` rank-1 array selecting which eigenvalues need to be moved in the !!  upper left block of the Schur factorization. !!  It is an `intent(in)` arguement. module procedure ordschur_rsp module procedure ordschur_rdp module procedure ordschur_csp module procedure ordschur_cdp end interface interface sqrtm !!  Computes the non-negative square root of a symmetric positive definite matrix !!  using its singular value decomposition. !! !!  ### Description !! !!  This interface provides methods to compute the non-negative square root of a symmetric !!  (hermitian) positive definite matrix  \\mathbf{A} . !! !!  ### Syntax !! !!  `call sqrtm(A, sqrtmA, info)` !! !!  ### Arguments !! !!  `A`: Symmetric (hermitian) positive definite matrix whose non-negative square root !!  needs to be computed. It is an `intent(in)` argument. !! !!  `sqrtmA`: Non-negative square root of `A`. It has the same size, kind and type as `A`. !!  It is an `intent(out)` argument. !! !!  `info`: Information flag. It is an `intent(out)` argument. module procedure sqrtm_rsp module procedure sqrtm_rdp module procedure sqrtm_csp module procedure sqrtm_cdp end interface interface sqrtm_eig !!  Computes the non-negative square root of a symmetric positive definite matrix !!  using its eigenvalue decomposition. !! !!  ### Description !! !!  This interface provides methods to compute the non-negative square root of a symmetric !!  (hermitian) positive definite matrix  \\mathbf{A} . !! !!  ### Syntax !! !!  `call sqrtm_eig(A, sqrtmA, info)` !! !!  ### Arguments !! !!  `A`: Symmetric (hermitian) positive definite matrix whose non-negative square root !!  needs to be computed. It is an `intent(in)` argument. !! !!  `sqrtmA`: Non-negative square root of `A`. It has the same size, kind and type as `A`. !!  It is an `intent(out)` argument. !! !!  `info`: Information flag. It is an `intent(out)` argument. module procedure sqrtm_eig_rsp module procedure sqrtm_eig_rdp module procedure sqrtm_eig_csp module procedure sqrtm_eig_cdp end interface !------------------------------------------------ !-----     OPTS TYPE FOR LINEAR SOLVERS     ----- !------------------------------------------------ type , abstract , public :: abstract_opts !! Abstract type container for options from which all others are being extended. end type type , extends ( abstract_opts ), public :: gmres_sp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). end type type , extends ( abstract_opts ), public :: cg_sp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). end type type , extends ( abstract_opts ), public :: newton_sp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. end type type , extends ( abstract_opts ), public :: gmres_dp_opts !! GMRES options. integer :: kdim = 30 !! Dimension of the Krylov subspace (default: 30). integer :: maxiter = 10 !! Maximum number of `gmres` restarts (default: 10). end type type , extends ( abstract_opts ), public :: cg_dp_opts !! Conjugate gradient options. integer :: maxiter = 100 !! Maximum number of `cg` iterations (default: 100). end type type , extends ( abstract_opts ), public :: newton_dp_opts !! Options for Newton-Krylov fixed-point iteration. integer :: maxiter = 100 !! Maximum number of Newton iterations (default = 100) logical :: ifbisect = . false . !! Bisection toggle to enforce residual reduction (default = .false.) integer :: maxstep_bisection = 5 !! Maximum number of bisections (evaluations of F) for step selection (default = 5) !! Ignored if ifbisect = .false. end type contains !------------------------------------- !-----     VARIOUS UTILITIES     ----- !------------------------------------- subroutine assert_shape_vector_rsp ( v , size , vecname , module , procedure ) !! Utility function to assert the shape of a vector. real ( sp ), intent ( in ) :: v (:) !! Vector whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of v. character ( len =* ), intent ( in ) :: vecname !! Name of the asserted vector. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( v ) /= size )) then print * , \"Vector \" // vecname // \" has illegal length \" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Vector length assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_vector_rsp subroutine assert_shape_matrix_rsp ( A , size , matname , module , procedure ) !! Utility function to assert the shape of a matrix. real ( sp ), intent ( in ) :: A (:, :) !! Matrix whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of A. character ( len =* ), intent ( in ) :: matname !! Name of the asserted matrix. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( A ) /= size )) then print * , \"Matrix \" // matname // \" has illegal shape \" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Matrix shape assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_matrix_rsp subroutine assert_shape_vector_rdp ( v , size , vecname , module , procedure ) !! Utility function to assert the shape of a vector. real ( dp ), intent ( in ) :: v (:) !! Vector whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of v. character ( len =* ), intent ( in ) :: vecname !! Name of the asserted vector. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( v ) /= size )) then print * , \"Vector \" // vecname // \" has illegal length \" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Vector length assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_vector_rdp subroutine assert_shape_matrix_rdp ( A , size , matname , module , procedure ) !! Utility function to assert the shape of a matrix. real ( dp ), intent ( in ) :: A (:, :) !! Matrix whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of A. character ( len =* ), intent ( in ) :: matname !! Name of the asserted matrix. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( A ) /= size )) then print * , \"Matrix \" // matname // \" has illegal shape \" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Matrix shape assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_matrix_rdp subroutine assert_shape_vector_csp ( v , size , vecname , module , procedure ) !! Utility function to assert the shape of a vector. complex ( sp ), intent ( in ) :: v (:) !! Vector whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of v. character ( len =* ), intent ( in ) :: vecname !! Name of the asserted vector. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( v ) /= size )) then print * , \"Vector \" // vecname // \" has illegal length \" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Vector length assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_vector_csp subroutine assert_shape_matrix_csp ( A , size , matname , module , procedure ) !! Utility function to assert the shape of a matrix. complex ( sp ), intent ( in ) :: A (:, :) !! Matrix whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of A. character ( len =* ), intent ( in ) :: matname !! Name of the asserted matrix. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( A ) /= size )) then print * , \"Matrix \" // matname // \" has illegal shape \" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Matrix shape assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_matrix_csp subroutine assert_shape_vector_cdp ( v , size , vecname , module , procedure ) !! Utility function to assert the shape of a vector. complex ( dp ), intent ( in ) :: v (:) !! Vector whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of v. character ( len =* ), intent ( in ) :: vecname !! Name of the asserted vector. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( v ) /= size )) then print * , \"Vector \" // vecname // \" has illegal length \" , shape ( v ), & & \". Expected length is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Vector length assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_vector_cdp subroutine assert_shape_matrix_cdp ( A , size , matname , module , procedure ) !! Utility function to assert the shape of a matrix. complex ( dp ), intent ( in ) :: A (:, :) !! Matrix whose dimension need to be asserted. integer , intent ( in ) :: size (:) !! Expected dimensions of A. character ( len =* ), intent ( in ) :: matname !! Name of the asserted matrix. character ( len =* ), intent ( in ) :: module !! Name of the module where assertion is done. character ( len =* ), intent ( in ) :: procedure !! Name of the routine where assertion is done. if ( any ( shape ( A ) /= size )) then print * , \"Matrix \" // matname // \" has illegal shape \" , shape ( A ), & & \". Expected shape is \" , size , \". Aborting due to illegal vector length.\" call stop_error ( 'Matrix shape assertion error' , module = module , procedure = procedure ) endif return end subroutine assert_shape_matrix_cdp !------------------------------------------- !-----     LAPACK MATRIX INVERSION     ----- !------------------------------------------- subroutine eig_rsp ( A , vecs , vals ) !! Eigenvalue decomposition of a dense matrix using LAPACK. real ( sp ), intent ( in ) :: A (:, :) !! Matrix to be factorized. real ( sp ), intent ( out ) :: vecs (:, :) !! Eigenvectors. complex ( sp ), intent ( out ) :: vals (:) ! Internal variables character :: jobvl = \"n\" , jobvr = \"v\" integer :: n , lwork , info , lda , ldvl , ldvr real ( sp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) real ( sp ) :: work ( 4 * size ( A , 1 )), wr ( size ( A , 1 )), wi ( size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 4 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , wr , wi , vl , ldvl , vecs , ldvr , work , lwork , info ) call check_info ( info , 'GEEV' , module = this_module , procedure = 'eig_rsp' ) ! Reconstruct eigenvalues vals = one_csp * wr + one_im_csp * wi return end subroutine eig_rsp subroutine schur_rsp ( A , Z , eigvals ) !! Compute the Schur form (in-place) and Schur vectors of the matrix `A`. real ( sp ), intent ( inout ) :: A (:, :) !! Matrix to be factorized. real ( sp ), intent ( out ) :: Z (:, :) !! Schur basis. complex ( sp ), intent ( out ) :: eigvals (:) !! Eigenvalues. ! Internal variables. character :: jobvs = \"v\" , sort = \"n\" integer :: n , lda , sdim , ldvs , lwork , info logical , allocatable :: bwork (:) real ( sp ), allocatable :: work (:) real ( sp ), allocatable :: wr (:), wi (:) ! Allocate variables. n = size ( A , 1 ) ; lda = n ; ldvs = n ; lwork = 3 * n allocate ( bwork ( n )) ; allocate ( work ( lwork )) ; allocate ( wr ( size ( eigvals )), wi ( size ( eigvals ))) call gees ( jobvs , sort , dummy_select , n , A , lda , sdim , wr , wi , Z , ldvs , work , lwork , bwork , info ) call check_info ( info , 'GEES' , module = this_module , procedure = 'schur_rsp' ) ! Reconstruct eigenvalues eigvals = cmplx ( wr , wi , kind = sp ) return contains pure function dummy_select ( wre , wim ) result ( out ) real ( sp ), intent ( in ) :: wre real ( sp ), intent ( in ) :: wim logical :: out out = . false . return end function end subroutine schur_rsp subroutine ordschur_rsp ( T , Q , selected ) !! Re-order the Schur factorization from `schur` such that the selected eigenvalues !! are in the upper-left block. real ( sp ), intent ( inout ) :: T (:, :) !! Schur matrix to be re-ordered. real ( sp ), intent ( inout ) :: Q (:, :) !! Schur vectors to be re-ordered. logical , intent ( in ) :: selected (:) !! Boolean array defining the selected eigenvalues. ! Internal variables character :: job = \"n\" , compq = \"v\" integer info , ldq , ldt , lwork , m , n real ( sp ) :: s , sep integer :: iwork ( size ( T , 1 )), liwork real ( sp ) :: wi ( size ( T , 1 )), wr ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) liwork = 1 call trsen ( job , compq , selected , n , T , ldt , Q , ldq , wr , wi , m , s , sep , work , lwork , iwork , liwork , info ) call check_info ( info , 'TRSEN' , module = this_module , procedure = 'ordschur_rsp' ) return end subroutine ordschur_rsp subroutine sqrtm_rsp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices real ( sp ), intent ( inout ) :: X (:,:) !! Matrix of which to compute the sqrt real ( sp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internal real ( sp ) :: S ( size ( X , 1 )) real ( sp ) :: U ( size ( X , 1 ), size ( X , 1 )), VT ( size ( X , 1 ), size ( X , 1 )) integer :: i real ( sp ) :: symmetry_error character ( len = 256 ) :: msg info = 0 ! Check if the matrix is symmetric symmetry_error = 0.5_sp * maxval ( X - transpose ( X )) if ( symmetry_error > rtol_sp ) then write ( msg , '(2(A,E9.2))' ) \"Input matrix is not symmetric. 0.5*max(X-X.T) = \" , & & symmetry_error , \", tol = \" , rtol_sp call stop_error ( msg , module = this_module , procedure = 'sqrtm_rsp' ) else if ( symmetry_error > 10 * atol_sp ) then write ( msg , '(A,E9.2)' ) \"Input matrix is not exactly symmetric. 0.5*max(X-X.T) = \" , symmetry_error call logger % log_warning ( msg , module = this_module , procedure = 'sqrtm_rsp' ) end if ! Perform svd call svd ( X , S , U , VT ) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( S ) if ( S ( i ) . gt . 10 * atol_sp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rsp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( U , matmul ( diag ( S ), VT )) return end subroutine subroutine sqrtm_eig_rsp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices real ( sp ), intent ( in ) :: X (:,:) !! Matrix of which to compute the sqrt real ( sp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internals real ( sp ) :: Xtmp ( size ( X , 1 ), size ( X , 1 )) real ( sp ) :: lambda ( size ( X , 1 )) real ( sp ) :: V ( size ( X , 1 ), size ( X , 1 )) integer :: i character ( len = 256 ) :: msg info = 0 ! Check if the matrix is symmetric if (. not . is_symmetric ( X )) then write ( msg , '(A)' ) \"Input matrix is not symmetric.\" call stop_error ( msg , module = this_module , procedure = 'sqrtm_rsp' ) end if ! Perform eigenvalue decomposition Xtmp = X ; call eigh ( Xtmp , lambda , vectors = V , overwrite_a = . true .) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( lambda ) if ( abs ( lambda ( i )) . gt . 10 * atol_sp ) then if ( lambda ( i ) . gt . zero_rsp ) then lambda ( i ) = sqrt ( lambda ( i )) else lambda ( i ) = zero_rsp info = - 1 end if else lambda ( i ) = zero_rsp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( V , matmul ( diag ( lambda ), transpose ( V ))) return end subroutine subroutine eig_rdp ( A , vecs , vals ) !! Eigenvalue decomposition of a dense matrix using LAPACK. real ( dp ), intent ( in ) :: A (:, :) !! Matrix to be factorized. real ( dp ), intent ( out ) :: vecs (:, :) !! Eigenvectors. complex ( dp ), intent ( out ) :: vals (:) ! Internal variables character :: jobvl = \"n\" , jobvr = \"v\" integer :: n , lwork , info , lda , ldvl , ldvr real ( dp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 2 )) real ( dp ) :: work ( 4 * size ( A , 1 )), wr ( size ( A , 1 )), wi ( size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 4 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , wr , wi , vl , ldvl , vecs , ldvr , work , lwork , info ) call check_info ( info , 'GEEV' , module = this_module , procedure = 'eig_rdp' ) ! Reconstruct eigenvalues vals = one_cdp * wr + one_im_cdp * wi return end subroutine eig_rdp subroutine schur_rdp ( A , Z , eigvals ) !! Compute the Schur form (in-place) and Schur vectors of the matrix `A`. real ( dp ), intent ( inout ) :: A (:, :) !! Matrix to be factorized. real ( dp ), intent ( out ) :: Z (:, :) !! Schur basis. complex ( dp ), intent ( out ) :: eigvals (:) !! Eigenvalues. ! Internal variables. character :: jobvs = \"v\" , sort = \"n\" integer :: n , lda , sdim , ldvs , lwork , info logical , allocatable :: bwork (:) real ( dp ), allocatable :: work (:) real ( dp ), allocatable :: wr (:), wi (:) ! Allocate variables. n = size ( A , 1 ) ; lda = n ; ldvs = n ; lwork = 3 * n allocate ( bwork ( n )) ; allocate ( work ( lwork )) ; allocate ( wr ( size ( eigvals )), wi ( size ( eigvals ))) call gees ( jobvs , sort , dummy_select , n , A , lda , sdim , wr , wi , Z , ldvs , work , lwork , bwork , info ) call check_info ( info , 'GEES' , module = this_module , procedure = 'schur_rdp' ) ! Reconstruct eigenvalues eigvals = cmplx ( wr , wi , kind = dp ) return contains pure function dummy_select ( wre , wim ) result ( out ) real ( dp ), intent ( in ) :: wre real ( dp ), intent ( in ) :: wim logical :: out out = . false . return end function end subroutine schur_rdp subroutine ordschur_rdp ( T , Q , selected ) !! Re-order the Schur factorization from `schur` such that the selected eigenvalues !! are in the upper-left block. real ( dp ), intent ( inout ) :: T (:, :) !! Schur matrix to be re-ordered. real ( dp ), intent ( inout ) :: Q (:, :) !! Schur vectors to be re-ordered. logical , intent ( in ) :: selected (:) !! Boolean array defining the selected eigenvalues. ! Internal variables character :: job = \"n\" , compq = \"v\" integer info , ldq , ldt , lwork , m , n real ( dp ) :: s , sep integer :: iwork ( size ( T , 1 )), liwork real ( dp ) :: wi ( size ( T , 1 )), wr ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) liwork = 1 call trsen ( job , compq , selected , n , T , ldt , Q , ldq , wr , wi , m , s , sep , work , lwork , iwork , liwork , info ) call check_info ( info , 'TRSEN' , module = this_module , procedure = 'ordschur_rdp' ) return end subroutine ordschur_rdp subroutine sqrtm_rdp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices real ( dp ), intent ( inout ) :: X (:,:) !! Matrix of which to compute the sqrt real ( dp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internal real ( dp ) :: S ( size ( X , 1 )) real ( dp ) :: U ( size ( X , 1 ), size ( X , 1 )), VT ( size ( X , 1 ), size ( X , 1 )) integer :: i real ( dp ) :: symmetry_error character ( len = 256 ) :: msg info = 0 ! Check if the matrix is symmetric symmetry_error = 0.5_dp * maxval ( X - transpose ( X )) if ( symmetry_error > rtol_dp ) then write ( msg , '(2(A,E9.2))' ) \"Input matrix is not symmetric. 0.5*max(X-X.T) = \" , & & symmetry_error , \", tol = \" , rtol_dp call stop_error ( msg , module = this_module , procedure = 'sqrtm_rdp' ) else if ( symmetry_error > 10 * atol_dp ) then write ( msg , '(A,E9.2)' ) \"Input matrix is not exactly symmetric. 0.5*max(X-X.T) = \" , symmetry_error call logger % log_warning ( msg , module = this_module , procedure = 'sqrtm_rdp' ) end if ! Perform svd call svd ( X , S , U , VT ) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( S ) if ( S ( i ) . gt . 10 * atol_dp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rdp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( U , matmul ( diag ( S ), VT )) return end subroutine subroutine sqrtm_eig_rdp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices real ( dp ), intent ( in ) :: X (:,:) !! Matrix of which to compute the sqrt real ( dp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internals real ( dp ) :: Xtmp ( size ( X , 1 ), size ( X , 1 )) real ( dp ) :: lambda ( size ( X , 1 )) real ( dp ) :: V ( size ( X , 1 ), size ( X , 1 )) integer :: i character ( len = 256 ) :: msg info = 0 ! Check if the matrix is symmetric if (. not . is_symmetric ( X )) then write ( msg , '(A)' ) \"Input matrix is not symmetric.\" call stop_error ( msg , module = this_module , procedure = 'sqrtm_rdp' ) end if ! Perform eigenvalue decomposition Xtmp = X ; call eigh ( Xtmp , lambda , vectors = V , overwrite_a = . true .) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( lambda ) if ( abs ( lambda ( i )) . gt . 10 * atol_dp ) then if ( lambda ( i ) . gt . zero_rdp ) then lambda ( i ) = sqrt ( lambda ( i )) else lambda ( i ) = zero_rdp info = - 1 end if else lambda ( i ) = zero_rdp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( V , matmul ( diag ( lambda ), transpose ( V ))) return end subroutine subroutine eig_csp ( A , vecs , vals ) !! Eigenvalue decomposition of a dense matrix using LAPACK. complex ( sp ), intent ( in ) :: A (:, :) !! Matrix to be factorized. complex ( sp ), intent ( out ) :: vecs (:, :) !! Eigenvectors. complex ( sp ), intent ( out ) :: vals (:) ! Internal variables character :: jobvl = \"n\" , jobvr = \"v\" integer :: n , lwork , info , lda , ldvl , ldvr complex ( sp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 1 )) complex ( sp ) :: work ( 2 * size ( A , 1 )) real ( sp ) :: rwork ( 2 * size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 2 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , vals , vl , ldvl , vecs , ldvr , work , lwork , rwork , info ) call check_info ( info , 'GEEV' , module = this_module , procedure = 'eig_csp' ) return end subroutine eig_csp subroutine schur_csp ( A , Z , eigvals ) !! Compute the Schur form (in-place) and Schur vectors of the matrix `A`. complex ( sp ), intent ( inout ) :: A (:, :) !! Matrix to be factorized. complex ( sp ), intent ( out ) :: Z (:, :) !! Schur basis. complex ( sp ), intent ( out ) :: eigvals (:) !! Eigenvalues. ! Internal variables. character :: jobvs = \"v\" , sort = \"n\" integer :: n , lda , sdim , ldvs , lwork , info logical , allocatable :: bwork (:) complex ( sp ), allocatable :: work (:) real ( sp ), allocatable :: rwork (:) ! Allocate variables. n = size ( A , 1 ) ; lda = n ; ldvs = n ; lwork = 2 * n allocate ( bwork ( n )) ; allocate ( work ( lwork )) ; allocate ( rwork ( n )) call gees ( jobvs , sort , dummy_select , n , A , lda , sdim , eigvals , Z , ldvs , work , lwork , rwork , bwork , info ) call check_info ( info , 'GEES' , module = this_module , procedure = 'schur_csp' ) return contains pure function dummy_select ( w ) result ( out ) complex ( sp ), intent ( in ) :: w logical :: out out = . false . return end function end subroutine schur_csp subroutine ordschur_csp ( T , Q , selected ) !! Re-order the Schur factorization from `schur` such that the selected eigenvalues !! are in the upper-left block. complex ( sp ), intent ( inout ) :: T (:, :) !! Schur matrix to be re-ordered. complex ( sp ), intent ( inout ) :: Q (:, :) !! Schur vectors to be re-ordered. logical , intent ( in ) :: selected (:) !! Boolean array defining the selected eigenvalues. ! Internal variables character :: job = \"n\" , compq = \"v\" integer info , ldq , ldt , lwork , m , n real ( sp ) :: s , sep complex ( sp ) :: w ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) call trsen ( job , compq , selected , n , T , ldt , Q , ldq , w , m , s , sep , work , lwork , info ) call check_info ( info , 'TRSEN' , module = this_module , procedure = 'ordschur_csp' ) return end subroutine ordschur_csp subroutine sqrtm_csp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices complex ( sp ), intent ( inout ) :: X (:,:) !! Matrix of which to compute the sqrt complex ( sp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internal real ( sp ) :: S ( size ( X , 1 )) complex ( sp ) :: U ( size ( X , 1 ), size ( X , 1 )), VT ( size ( X , 1 ), size ( X , 1 )) integer :: i real ( sp ) :: symmetry_error character ( len = 256 ) :: msg info = 0 ! Check if the matrix is hermitian symmetry_error = 0.5_sp * maxval ( abs ( X - conjg ( transpose ( X )))) if ( symmetry_error > rtol_sp ) then write ( msg , '(2(A,E9.2))' ) \"Input matrix is not hermitian. 0.5*max(abs(X-X.H)) = \" , & & symmetry_error , \", tol = \" , rtol_sp call stop_error ( msg , module = this_module , procedure = 'sqrtm_csp' ) else if ( symmetry_error > 10 * atol_sp ) then write ( msg , '(A,E9.2)' ) \"Input matrix is not exactly hermitian. 0.5*max(X-X.T) = \" , symmetry_error call logger % log_warning ( msg , module = this_module , procedure = 'sqrtm_csp' ) end if ! Perform svd call svd ( X , S , U , VT ) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( S ) if ( S ( i ) . gt . 10 * atol_sp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rsp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( U , matmul ( diag ( S ), VT )) return end subroutine subroutine sqrtm_eig_csp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices complex ( sp ), intent ( in ) :: X (:,:) !! Matrix of which to compute the sqrt complex ( sp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internals complex ( sp ) :: Xtmp ( size ( X , 1 ), size ( X , 1 )) real ( sp ) :: lambda ( size ( X , 1 )) complex ( sp ) :: V ( size ( X , 1 ), size ( X , 1 )) integer :: i character ( len = 256 ) :: msg info = 0 ! Check if the matrix is hermitian if (. not . is_hermitian ( X )) then write ( msg , '(A)' ) \"Input matrix is not hermitian\" call stop_error ( msg , module = this_module , procedure = 'sqrtm_csp' ) end if ! Perform eigenvalue decomposition Xtmp = X ; call eigh ( Xtmp , lambda , vectors = V , overwrite_a = . true .) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( lambda ) if ( abs ( lambda ( i )) . gt . 10 * atol_sp ) then if ( lambda ( i ) . gt . zero_rsp ) then lambda ( i ) = sqrt ( lambda ( i )) else lambda ( i ) = zero_rsp info = - 1 end if else lambda ( i ) = zero_rsp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( V , matmul ( diag ( lambda ), conjg ( transpose ( V )))) return end subroutine subroutine eig_cdp ( A , vecs , vals ) !! Eigenvalue decomposition of a dense matrix using LAPACK. complex ( dp ), intent ( in ) :: A (:, :) !! Matrix to be factorized. complex ( dp ), intent ( out ) :: vecs (:, :) !! Eigenvectors. complex ( dp ), intent ( out ) :: vals (:) ! Internal variables character :: jobvl = \"n\" , jobvr = \"v\" integer :: n , lwork , info , lda , ldvl , ldvr complex ( dp ) :: A_tilde ( size ( A , 1 ), size ( A , 2 )), vl ( 1 , size ( A , 1 )) complex ( dp ) :: work ( 2 * size ( A , 1 )) real ( dp ) :: rwork ( 2 * size ( A , 1 )) ! Setup variables. n = size ( A , 1 ) ; lda = n ; ldvl = 1 ; ldvr = n ; a_tilde = a lwork = 2 * n ! Eigendecomposition. call geev ( jobvl , jobvr , n , a_tilde , lda , vals , vl , ldvl , vecs , ldvr , work , lwork , rwork , info ) call check_info ( info , 'GEEV' , module = this_module , procedure = 'eig_cdp' ) return end subroutine eig_cdp subroutine schur_cdp ( A , Z , eigvals ) !! Compute the Schur form (in-place) and Schur vectors of the matrix `A`. complex ( dp ), intent ( inout ) :: A (:, :) !! Matrix to be factorized. complex ( dp ), intent ( out ) :: Z (:, :) !! Schur basis. complex ( dp ), intent ( out ) :: eigvals (:) !! Eigenvalues. ! Internal variables. character :: jobvs = \"v\" , sort = \"n\" integer :: n , lda , sdim , ldvs , lwork , info logical , allocatable :: bwork (:) complex ( dp ), allocatable :: work (:) real ( dp ), allocatable :: rwork (:) ! Allocate variables. n = size ( A , 1 ) ; lda = n ; ldvs = n ; lwork = 2 * n allocate ( bwork ( n )) ; allocate ( work ( lwork )) ; allocate ( rwork ( n )) call gees ( jobvs , sort , dummy_select , n , A , lda , sdim , eigvals , Z , ldvs , work , lwork , rwork , bwork , info ) call check_info ( info , 'GEES' , module = this_module , procedure = 'schur_cdp' ) return contains pure function dummy_select ( w ) result ( out ) complex ( dp ), intent ( in ) :: w logical :: out out = . false . return end function end subroutine schur_cdp subroutine ordschur_cdp ( T , Q , selected ) !! Re-order the Schur factorization from `schur` such that the selected eigenvalues !! are in the upper-left block. complex ( dp ), intent ( inout ) :: T (:, :) !! Schur matrix to be re-ordered. complex ( dp ), intent ( inout ) :: Q (:, :) !! Schur vectors to be re-ordered. logical , intent ( in ) :: selected (:) !! Boolean array defining the selected eigenvalues. ! Internal variables character :: job = \"n\" , compq = \"v\" integer info , ldq , ldt , lwork , m , n real ( dp ) :: s , sep complex ( dp ) :: w ( size ( T , 1 )), work ( size ( T , 1 )) ! Setup variables. n = size ( T , 2 ) ; ldt = n ; ldq = n ; lwork = max ( 1 , n ) call trsen ( job , compq , selected , n , T , ldt , Q , ldq , w , m , s , sep , work , lwork , info ) call check_info ( info , 'TRSEN' , module = this_module , procedure = 'ordschur_cdp' ) return end subroutine ordschur_cdp subroutine sqrtm_cdp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices complex ( dp ), intent ( inout ) :: X (:,:) !! Matrix of which to compute the sqrt complex ( dp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internal real ( dp ) :: S ( size ( X , 1 )) complex ( dp ) :: U ( size ( X , 1 ), size ( X , 1 )), VT ( size ( X , 1 ), size ( X , 1 )) integer :: i real ( dp ) :: symmetry_error character ( len = 256 ) :: msg info = 0 ! Check if the matrix is hermitian symmetry_error = 0.5_dp * maxval ( abs ( X - conjg ( transpose ( X )))) if ( symmetry_error > rtol_dp ) then write ( msg , '(2(A,E9.2))' ) \"Input matrix is not hermitian. 0.5*max(abs(X-X.H)) = \" , & & symmetry_error , \", tol = \" , rtol_dp call stop_error ( msg , module = this_module , procedure = 'sqrtm_cdp' ) else if ( symmetry_error > 10 * atol_dp ) then write ( msg , '(A,E9.2)' ) \"Input matrix is not exactly hermitian. 0.5*max(X-X.T) = \" , symmetry_error call logger % log_warning ( msg , module = this_module , procedure = 'sqrtm_cdp' ) end if ! Perform svd call svd ( X , S , U , VT ) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( S ) if ( S ( i ) . gt . 10 * atol_dp ) then S ( i ) = sqrt ( S ( i )) else S ( i ) = zero_rdp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( U , matmul ( diag ( S ), VT )) return end subroutine subroutine sqrtm_eig_cdp ( X , sqrtmX , info ) !! Matrix-valued sqrt function for dense symmetric/hermitian positive (semi-)definite matrices complex ( dp ), intent ( in ) :: X (:,:) !! Matrix of which to compute the sqrt complex ( dp ), intent ( out ) :: sqrtmX ( size ( X , 1 ), size ( X , 1 )) !! Return matrix integer , intent ( out ) :: info !! Information flag ! internals complex ( dp ) :: Xtmp ( size ( X , 1 ), size ( X , 1 )) real ( dp ) :: lambda ( size ( X , 1 )) complex ( dp ) :: V ( size ( X , 1 ), size ( X , 1 )) integer :: i character ( len = 256 ) :: msg info = 0 ! Check if the matrix is hermitian if (. not . is_hermitian ( X )) then write ( msg , '(A)' ) \"Input matrix is not hermitian\" call stop_error ( msg , module = this_module , procedure = 'sqrtm_cdp' ) end if ! Perform eigenvalue decomposition Xtmp = X ; call eigh ( Xtmp , lambda , vectors = V , overwrite_a = . true .) ! Check if the matrix is positive definite (up to tol) do i = 1 , size ( lambda ) if ( abs ( lambda ( i )) . gt . 10 * atol_dp ) then if ( lambda ( i ) . gt . zero_rdp ) then lambda ( i ) = sqrt ( lambda ( i )) else lambda ( i ) = zero_rdp info = - 1 end if else lambda ( i ) = zero_rdp info = 1 end if end do ! Reconstruct the square root matrix sqrtmX = matmul ( V , matmul ( diag ( lambda ), conjg ( transpose ( V )))) return end subroutine !--------------------------------- !-----     MISCELLANEOUS     ----- !--------------------------------- pure real ( sp ) function log2_rsp ( x ) result ( y ) real ( sp ), intent ( in ) :: x y = log ( x ) / log ( 2.0_sp ) end function pure real ( sp ) function norml_rsp ( A ) result ( norm ) real ( sp ), intent ( in ) :: A (:, :) integer :: i , n real ( sp ) :: row_sum norm = zero_rsp n = size ( A , 1 ) do i = 1 , n row_sum = sum ( abs ( A ( i , :))) norm = max ( norm , row_sum ) enddo end function pure real ( dp ) function log2_rdp ( x ) result ( y ) real ( dp ), intent ( in ) :: x y = log ( x ) / log ( 2.0_dp ) end function pure real ( dp ) function norml_rdp ( A ) result ( norm ) real ( dp ), intent ( in ) :: A (:, :) integer :: i , n real ( dp ) :: row_sum norm = zero_rdp n = size ( A , 1 ) do i = 1 , n row_sum = sum ( abs ( A ( i , :))) norm = max ( norm , row_sum ) enddo end function pure real ( sp ) function norml_csp ( A ) result ( norm ) complex ( sp ), intent ( in ) :: A (:, :) integer :: i , n real ( sp ) :: row_sum norm = zero_rsp n = size ( A , 1 ) do i = 1 , n row_sum = sum ( abs ( A ( i , :))) norm = max ( norm , row_sum ) enddo end function pure real ( dp ) function norml_cdp ( A ) result ( norm ) complex ( dp ), intent ( in ) :: A (:, :) integer :: i , n real ( dp ) :: row_sum norm = zero_rdp n = size ( A , 1 ) do i = 1 , n row_sum = sum ( abs ( A ( i , :))) norm = max ( norm , row_sum ) enddo end function end module LightKrylov_Utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"Constants.f90 – LightKrylov","text":"Source Code module LightKrylov_Constants !! This module defines a list of simple constants used throughout `LightKrylov`. !! It also provides some utility functions related to let `LightKrylov` be aware !! of any MPI-related information (e.g. rank of the current MPI process, dimension !! of the MPI communicator, etc). implicit none private integer , private :: nid = 0 !! Rank of the current process (local MPI variable). integer , private :: comm_size = 1 !! Dimension of the MPI communicator. integer , private :: nio = 0 !! Rank of the processor for logging information. integer , parameter , public :: sp = selected_real_kind ( 6 , 37 ) !! Single precision data type. real ( sp ), parameter , public :: atol_sp = 1 0.0_sp ** - precision ( 1.0_sp ) !! Absolute tolerance for single precision computations. real ( sp ), parameter , public :: rtol_sp = sqrt ( atol_sp ) !! Relative tolerance for single precision computations. real ( sp ), parameter , public :: one_rsp = 1.0_sp !! Real-valued single precision one. real ( sp ), parameter , public :: zero_rsp = 0.0_sp !! Real-valued single precision zero. complex ( sp ), parameter , public :: one_csp = cmplx ( 1.0_sp , 0.0_sp , kind = sp ) !! Complex-valued single precision one. complex ( sp ), parameter , public :: one_im_csp = cmplx ( 0.0_sp , 1.0_sp , kind = sp ) !! Complex-valued single precision imaginary unit. complex ( sp ), parameter , public :: zero_csp = cmplx ( 0.0_sp , 0.0_sp , kind = sp ) !! Complex-value single precision zero. integer , parameter , public :: dp = selected_real_kind ( 15 , 307 ) !! Double precision data type. real ( dp ), parameter , public :: atol_dp = 1 0.0_dp ** - precision ( 1.0_dp ) !! Absolute tolerance for double precision computations. real ( dp ), parameter , public :: rtol_dp = sqrt ( atol_dp ) !! Relative tolerance for double precision computations. real ( dp ), parameter , public :: one_rdp = 1.0_dp !! Real-valued double precision one. real ( dp ), parameter , public :: zero_rdp = 0.0_dp !! Real-valued double precision zero. complex ( dp ), parameter , public :: one_cdp = cmplx ( 1.0_dp , 0.0_dp , kind = dp ) !! Complex-valued double precision one. complex ( sp ), parameter , public :: one_im_cdp = cmplx ( 0.0_dp , 1.0_dp , kind = dp ) !! Complex-valued double precision imaginary unit. complex ( dp ), parameter , public :: zero_cdp = cmplx ( 0.0_dp , 0.0_dp , kind = dp ) !! Complex-valued double precision zero. ! Getter/setter routines public :: set_comm_size public :: set_rank public :: set_io_rank public :: get_rank public :: get_comm_size public :: io_rank contains subroutine set_rank ( rank ) !! Utility function to set the rank of an MPI process. integer :: rank !! Desired rank identification. nid = rank end subroutine set_rank subroutine set_comm_size ( c_size ) !! Utility function to inform `LightKrylov` of the MPI-communicator's dimension. integer :: c_size !! Dimension of the MPI communicator. comm_size = c_size end subroutine set_comm_size subroutine set_io_rank ( rk ) !! Utility function to set the rank of the process doing I/O. integer , intent ( in ) :: rk !! Desired rank for the IO process. if ( rk > comm_size . or . rk < 0 ) then if ( io_rank ()) print * , 'Invalid I/O rank specified!' , rk else nio = rk if ( io_rank ()) print * , 'I/O rank --> rank ' , nio end if end pure integer function get_rank () result ( rank ) !! Utility function to get the rank of the current MPI process. rank = nid end function get_rank pure integer function get_comm_size () result ( c_size ) !! Utility function to get the dimension of the communicator known to `LightKrylov`. c_size = comm_size end function get_comm_size pure logical function io_rank () result ( is_io ) !! Utility function to determine whether the current MPI process can do I/O. is_io = . false . if ( nid == nio ) is_io = . true . end function io_rank end module LightKrylov_Constants","tags":"","loc":"sourcefile/constants.f90.html"}]}